{"version":3,"sources":["webpack:///./node_modules/_codemirror-emmet@1.0.0@codemirror-emmet/dist/codemirror-emmet.js"],"names":["factory","StreamReader","string","this","pos","length","prototype","sol","peek","offset","charCodeAt","prev","eat","match","ok","eatWhile","start","SINGLE_QUOTE","DOUBLE_QUOTE","ESCAPE","isQuote","c","TAB","SPACE","COLON","EQUALS","isAtHTMLTag","stream","isWhiteSpace","eatIdent","eatAttributeWithUnquotedValue","eatAttribute","quote","eatQuoted","eatAttributeWithQuotedValue","isUnquotedValue","isIdent","isAlpha","isNumber","code","ch","SQUARE_BRACE_L","SQUARE_BRACE_R","ROUND_BRACE_L","ROUND_BRACE_R","CURLY_BRACE_L","CURLY_BRACE_R","specialChars","Set","split","map","bracePairs","Map","set","extractAbbreviation$1","line","lookAhead","Math","min","max","isCloseBrace","offsetPastAutoClosed","stack","push","isOpenBrace","pop","get","has","isAbbreviation","abbreviation","slice","replace","location","arr","value","indexOf","defaultOptions$1","indent","tagCase","attributeCase","attributeQuotes","format","formatSkip","formatForce","inlineBreak","compactBooleanAttributes","booleanAttributes","selfClosingStyle","inlineElements","Profile","options","Object","assign","quoteChar","strcase","type","toUpperCase","toLowerCase","name","str","name$1","attribute","attr","isBooleanAttribute","boolean","selfClose","level","output","isInline","node","isTextOnly","field","index","placeholder","Snippet","key","SnippetsStorage","data","_string","_regexp","_disabled","load","prototypeAccessors","disabled","disable","enable","this$1","forEach","k","RegExp","Error","keys","Array","from","i","il","test","reset","clear","values","regexp","concat","defineProperties","SnippetsRegistry","_registry","isArray","snippets","add","item","store","remove","sort","a","b","filter","resolve","snippet","all","result","fillResult","Attribute","clone","valueOf","Node","attributes","repeat","selfClosing","children","parent","next","previous","_attributes","setAttribute","prototypeAccessors$1","attributesMap","isGroup","firstChild","lastChild","childIndex","nextSibling","previousSibling","classList","createAttribute","normalize","String","trim","uniqueClass","reduce","out","getAttribute","create","curAttr","replaceAttribute","hasAttribute","curAttribute","newName","newValue","ix","splice","removeAttribute","clearAttributes","addClass","token","hasClass","join","removeClass","appendChild","insertAt","insertBefore","newNode","refNode","removeChild","deep","child","walk","fn","_level","ctx","use","arguments$1","arguments","args","apply","toString","attrs","opt","implied","count","StreamReader$1","end","eof","limit","constructor","backUp","n","current","substring","error","message","err","originalMessage","SINGLE_QUOTE$1","DOUBLE_QUOTE$1","defaultOptions$2","escape","throws","eatQuoted$1","isQuote$1","isNumber$1","isAlpha$1","to","isAlphaNumeric","isWhiteSpace$1","isSpace","defaultOptions$1$1","eatPair","open","close","fromCharCode","consumeRepeat","consumeQuoted","opt$1","consumeTextNode","EXCL","DOT$1","EQUALS$1","ATTR_OPEN","ATTR_CLOSE","reAttributeName","consumeAttributes","eatUnquoted","parseAttributeName","before","after","isUnquoted","consumeElement","eatName","isName","GROUP_START","GROUP_END","OP_SIBLING","OP_CHILD","OP_CLIMB","abbr","tree","root","groupStack","node$2","lastGroup","node$1","groupCtx","parse","unroll","index$1","registry","delete","childTarget","findDeepestNode","classNames","mergeClassNames","attrMap","i$1","newAttrs","i$2","mergeAttributes","merge","resolveNode","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","resolveImplicitName","parentName","implicitTags","findUnescapedTokens","tlen","size","pos$1","len","replaceRanges","ranges","r","substr","numberingToken","applyNumbering","applyNumbering$1","repeater","findRepeater","replaceNumbering","copy","unescapeString","_value","replaceNumberingRanges","range$$1","lastRange","getNumberingRanges","caret","reUrl","reEmail","reProto","prepare","amount","implicit","insert","content","updated","inserted","insertContentIntoPlaceholder","setNodeContent","findDeepestNode$1","insertContent","state","replaced","replacePlaceholder","_state","defaultOptions$3","element","modifier","reElement","reModifier","blockCandidates1","className","blockCandidates2","getBlockName","lookup","prefix","depth","find","oldName","reSupporterNames","supportedAddons","bem","cl","expandClassNames","createBlockLookup","m","originalClass","expandShortNotation","jsx","xsl","addons","addonOpt","index$2","appliedAddons","replaceVariables","variables","replaceInString","replaceInNode","model","reVariable","tokens","exec","validMatches","token$1","createModel","v","DOLLAR","COLON$1","ESCAPE$1","OPEN_BRACE","CLOSE_BRACE","parse$2$1","fields","cleanString","consumeField","FieldString","createToken","consumeIndex","Field","consumePlaceholder","Number","mark","order","defaultFieldsRenderer","text","OutputNode","fieldsRenderer","_fieldsRenderer","beforeOpen","afterOpen","beforeClose","afterClose","beforeText","afterText","newline","indentText","lines","splitByLines$2","nl","renderFields","_wrap","defaultField","render","formatter","fieldState","run","nodes","notGroup","outNode","largestIndex","getFieldsModel","TOKEN","TOKEN_OPEN","TOKEN_CLOSE","template","lastPos","replacer","left","right","splitByLines$1","isFirstChild","isRoot","isPseudoSnippet","handlePseudoSnippet","fieldsModel","parts","splitFieldsModel","commentOptions","enabled","trigger","shouldFormatNode","profile","adjacentInline","isInlineElement","shouldFormatInline","reId","reClass","defaultAttrOptions","primary","secondary","isBoolean","defaultNodeOptions","omitName","indentFormat","getIndentLevel$1","NAME","SELF_CLOSE","PRIMARY_ATTRS","SECONDARY_ATTRS","getAttributes","reNl","reNl$1","secondaryAttrs","none","round","curly","square","reNl$2","supportedSyntaxed","html","comment","skip","getIndentLevel","nodeName","hasInnerFormatting","setFormatting","attrName","attrValue","formatAttributes","commentNode","haml","nodeOptions","updateFormatting","maxLength","formatNodeValue","slim","attributeWrap","booleanAttr","isInline$1","updateFormatting$1","formatNodeValue$1","pug","updateFormatting$2","formatNodeValue$2","index$3","syntax","supports","CSSValue","prototypeAccessors$2","consumeColor","isHex","base","Color","alpha","raw","g","parseInt","isShortHex","hex","toShortHex","num","toHex","pad$1","isAlphaNumericWord","isAlphaWord","short","toRGB","toFixed","DOT$1$2","DASH$1","consumeNumericValue","negative","hadDot","consumed","eatNumber","NumericValue","unit","DASH$2","consumeKeyword","isVariableName","isKeyword","Keyword","opt$1$1","consumeQuoted$1","QuotedString","LBRACE","RBRACE","COMMA","consumeArgumentList","arg","argsList","consumeArgument","consumeKeywordOrFunction","kw","FunctionCall","EXCL$1","DOLLAR$1$1","DASH","COLON$2","AT","index$4","consumeIdent","consumeValue","isIdentPrefix","isIdent$1","stringScore","ch1","ch2","found","acronym","abbrLength","stringLength","j","score","reProperty","DASH$1$2","cssSnippets","snippetsSort","cur","property","addDependency","nest","CSSSnippet","dependencies","prototypeAccessors$3","defaulValue","isKeyword$1","splitValue","dep","keywords","candidates","j$1","deps","globalKeywords","unitlessProperties","unitAliases","e","x","index$5","convertToCSSSnippets","findBestMatch","setNodeAsText","isKeyword$1$1","isNumericValue","resolveNumericValue","getUnmatchedPart","resolveAsProperty","resolveAsSnippet","resolveNode$1","items","matchedItem","maxScore","getScoringPart","tokenTypeOf","defaultOptions$4","shortHex","between","css","fieldsAmount","shift","delta","injectFields","stringifyAttribute","syntaxFormat","scss","less","sass","stylus","index$6","supports$1","getFormat","index$7","a:link","a:mail","acr|acronym","basefont","br","frame","hr","bdo","bdo:r","bdo:l","col","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:vp","meta:compat","meta:edge","meta:redirect","style","script","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:t|source:type","src:z|source:sizes","src:m|source:media","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","label","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","input:reset","isindex","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","!!!","doc","!|html:5","cc:ie","cc:noie","@f","@ff","@i|@import","@kf","@m|@media","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","ap","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cp","cps","d","ec","f","fef","fem","femp","fems","ff","fl","fs","fsm","fv","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fz","fza","h","jc","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","op","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","q","qen","qru","rsz","t","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","langs","latin","common","words","ru","sp","defaultOptions$5","wordCount","skipCommon","lang","index$8","dict","startWithCommon","isRepeating","isRoot$1","paragraph","rand","floor","random","sample","iterations","sentence","word","val","insertCommas","hasComma","totalCommas","totalWords","parse$1","parse$2","reLorem","snippetsRegistryFactory","registrySnippets","Boolean","loremGenerator","defaultVariables","locale","charset","stylesheetSyntaxes","defaultOptions","index$$1","expand$$1","isStylesheet","createOptions","expand$2","expand$1","createSnippetsRegistry","createProfile","Node$2","prototypeAccessors$4","getIndex","addChild","Token","eatToken","prototypeAccessors$1$1","opt$2","eatPaired","SLASH$1$1","EQUALS$2","RIGHT_ANGLE$1","eatAttributeName","isAttributeName","eatAttributeValue","valueStart","valueEnd","isUnquoted$1","eatUnquoted$1","isTerminator","isNaN","DASH$2$1","DOT$2","COLON$3","UNDERSCORE","tag","isTagName","eatTagName","eatAttributes","eatArray","codes","eatSection","allowUnclosed","toCharCodes","open$1","close$1","cdata","defaultOptions$6","xml","special","empty","consumeSpecial","last$1","knownSyntaxes","stylesheetAutoActivationContext","editor","tokenType","getTokenTypeAt","getCursor","autoActivationContext","detectSyntax","mode","getModeAt","isSupported","emmetOpt","getOption","getIndentation","repeatString","normalizeText","indentation","splitByLines","tabs","containsPos","range","exclude","comparePos","cursorMark","editorField","expandAbbreviation","getExpandOptions","parseAbbreviation","parse$$1","extractAbbreviation","getLine","createAbbreviationModel","ast","expandAndInsert","expanded","cursorMarked","newSelectionSize","matchIndent","newCursorPos","operation","replaceRange","startIx","indexFromPos","newCursor","posFromIndex","setSelection","setCursor","configuration","snippetsFromOptions","stylesheetSnippets","markupSnippets","emmetMarkerClass","markOnEditorChange","marker","findMarker","getRange","isValidMarker","clearMarkers","hasAutoActivateContext","markAbbreviation","markers","findMarksAt","forced","extracted","rootNode","allowedForAutoActivation","marker$1","markText","inclusiveRight","clearWhenEmpty","getAllMarks","autocompleteProvider","abbrModel","abbrPos","cursorPos","abbrRange","EmmetCompletion","getPrefix","prefixRange","completions","getSnippetCompletions","preview","getStylesheetCompletions","getMarkupCompletions","emmetCompletions","cache","expandOpt","match$$1","_inserted","SyntaxModel","dom","nodeForPoint","CodeMirrorStreamReader","call","CodeMirror","Pos","lastLine","_eof","_lineLength","_sof","__proto__","sof","ref","lineStr","NaN","isLast","tag$$1","isEmpty","parse$3","console","warn","getModel","getMode","getSyntax","resetCachedModel","_emmetModel","openTagMark","closeTagMark","matchTag","marked","getMarkedTag","clearTagMatch","getEmmetDocumentModel","findTagPair","createTagMark","inclusiveLeft","renameTag","updateTag","source","dest","text$1","commands","emmetExpandAbbreviation","somethingSelected","Pass","abbrData","emmetInsertLineBreak","cursor","getTokenAt","curIndent","defineOption","on","off","defineExtension","force","fromMarker","getCachedModel","module","exports"],"mappings":"yCAAA,IAAAA,IAIC,WAAqB,aAKtB,IAAAC,EAAA,SAAAC,GACAC,KAAAD,SACAC,KAAAC,IAAAD,KAAAD,OAAAG,QAGAJ,EAAAK,UAAAC,IAAA,WACA,WAAAJ,KAAAC,KAGAH,EAAAK,UAAAE,KAAA,SAAAC,GACA,OAAAN,KAAAD,OAAAQ,WAAAP,KAAAC,IAAA,GAAAK,GAAA,KAGAR,EAAAK,UAAAK,KAAA,WACA,IAAAR,KAAAI,MACA,OAAAJ,KAAAD,OAAAQ,aAAAP,KAAAC,MAIAH,EAAAK,UAAAM,IAAA,SAAAC,GACA,IAAAC,EAAA,mBAAAD,EACAA,EAAAV,KAAAK,QACAK,IAAAV,KAAAK,OAMA,OAJAM,GACAX,KAAAC,MAGAU,GAGAb,EAAAK,UAAAS,SAAA,SAAAF,GAEA,IADA,IAAAG,EAAAb,KAAAC,IACAD,KAAAS,IAAAC,KACA,OAAAV,KAAAC,IAAAY,GAOA,IAAAC,EAAA,GACAC,EAAA,GACAC,EAAA,GAOA,SAAAC,EAAAC,GACA,OAAAA,IAAAJ,GAAAI,IAAAH,EAwBA,IAAAI,EAAA,EACAC,EAAA,GAEAC,EAAA,GACAC,EAAA,GASAC,EAAA,SAAAC,GACA,IAAAX,EAAAW,EAAAvB,IAEA,IAAAuB,EAAAf,IAVA,IAWA,SAGA,IAAAE,GAAA,EAGA,IAFAa,EAAAf,IAnBA,KAqBAe,EAAApB,OAAA,CAGA,GAFAoB,EAAAZ,SAAAa,GAEAC,EAAAF,GAAA,CAGA,GAAAA,EAAAf,IA3BA,IA2BA,CAEAE,EAAAa,EAAAf,IA1BA,IA2BA,MACI,GAAAe,EAAAf,IA5BJ,IA4BI,CAEJE,GAAA,EACA,MACI,GAAAa,EAAAf,IAAAgB,GAEJ,SACI,GAAAD,EAAAf,IAAAa,GAAA,CAEJX,EAAAe,EAAAF,GACA,MACI,GAAAG,EAAAH,GAAA,CAEJb,GAAA,EACA,MAIA,MAGA,IAAAiB,EAAAJ,GAIA,MAIA,OADAA,EAAAvB,IAAAY,EACAF,GAQA,SAAAiB,EAAAJ,GACA,OAOA,SAAAA,GACA,IAAAX,EAAAW,EAAAvB,IACA,GAhGA,SAAAuB,GACA,IAAAX,EAAAW,EAAAvB,IACA4B,EAAAL,EAAAhB,OAEA,GAAAS,EAAAY,GACA,MAAAL,EAAApB,OACA,GAAAoB,EAAAhB,SAAAqB,GAAAL,EAAAnB,SAAAW,EACA,SAMA,OADAQ,EAAAvB,IAAAY,GACA,EAmFAiB,CAAAN,MAAAf,IAAAa,IAAAI,EAAAF,GACA,SAIA,OADAA,EAAAvB,IAAAY,GACA,EAdAkB,CAAAP,IAAAG,EAAAH,GAqBA,SAAAG,EAAAH,GACA,IAAAX,EAAAW,EAAAvB,IACA,SAAAuB,EAAAZ,SAAAoB,IAAAR,EAAAf,IAAAa,IAAAI,EAAAF,MAIAA,EAAAvB,IAAAY,GACA,GAQA,SAAAa,EAAAF,GACA,OAAAA,EAAAZ,SAAAqB,GAQA,SAAAA,EAAAf,GACA,OAAAA,IAAAG,GAQA,SAAAH,GAEA,OADAA,IAAA,KACA,IAAAA,GAAA,GAVAgB,CAAAhB,IAkBA,SAAAA,GACA,OAAAA,EAAA,IAAAA,EAAA,GAnBAiB,CAAAjB,GA2BA,SAAAO,EAAAP,GACA,OAAAA,IAAAE,GAAAF,IAAAC,EAQA,SAAAa,EAAAd,GACA,OAAAA,OAAAI,IAAAG,EAAAP,KAAAD,EAAAC,GAGA,IAAAkB,EAAA,SAAAC,GAA0B,OAAAA,EAAA9B,WAAA,IAC1B+B,EAAAF,EAAA,KACAG,EAAAH,EAAA,KACAI,EAAAJ,EAAA,KACAK,EAAAL,EAAA,KACAM,EAAAN,EAAA,KACAO,EAAAP,EAAA,KAEAQ,EAAA,IAAAC,IAAA,iBAAAC,MAAA,IAAAC,IAAAX,IACAY,GAAA,IAAAC,KACAC,IAAAZ,EAAAC,GACAW,IAAAV,EAAAC,GACAS,IAAAR,EAAAC,GAkBA,SAAAQ,EAAAC,EAAAnD,EAAAoD,GAQA,IAAAnC,EANAjB,EAAAqD,KAAAC,IAAAH,EAAAlD,OAAAoD,KAAAE,IAAA,QAAAvD,EAAAmD,EAAAlD,OAAAD,IAEA,MAAAoD,IAAA,IAAAA,IACApD,EA+CA,SAAAmD,EAAAnD,GAEAgB,EAAAmC,EAAA7C,WAAAN,KACAA,IAIA,KAAAwD,EAAAL,EAAA7C,WAAAN,KACAA,IAGA,OAAAA,EA1DAyD,CAAAN,EAAAnD,IAIA,IAAAuB,EAAA,IAAA1B,EAAAsD,GACA5B,EAAAvB,MAGA,IAFA,IAAA0D,MAEAnC,EAAApB,OAAA,CAGA,GAAAqD,EAFAvC,EAAAM,EAAAnB,QAGAsD,EAAAC,KAAA1C,QACG,GAAA2C,EAAA3C,IACH,GAAAyC,EAAAG,QAAAd,EAAAe,IAAA7C,GAEA,UAEG,IAAA8C,EAAAL,EAAApB,IAAAyB,EAAAL,EAAAhB,GAAA,CAEHnB,EAAAvB,MACA,SACG,GAAAsB,EAAAC,KAAAyC,EAAA/C,GACH,MAGAM,EAAAvB,MAGA,IAAA0D,EAAAzD,QAAAsB,EAAAvB,QAAA,CAGA,IAAAiE,EAAAd,EAAAe,MAAA3C,EAAAvB,OAAAmE,QAAA,mBACA,OACAF,eACAG,SAAApE,EAAAiE,EAAAhE,SA0BA,SAAA8D,EAAAM,EAAAC,GACA,WAAAD,EAAAE,QAAAD,GAGA,SAAAN,EAAA/C,GACA,OAAAA,EAAA,IAAAA,EAAA,IACAA,EAAA,IAAAA,EAAA,KACAA,EAAA,IAAAA,EAAA,IACA0B,EAAAoB,IAAA9C,GAGA,SAAA2C,EAAA3C,GACA,OAAAA,IAAAoB,GAAApB,IAAAsB,GAAAtB,IAAAwB,EAGA,SAAAe,EAAAvC,GACA,OAAAA,IAAAqB,GAAArB,IAAAuB,GAAAvB,IAAAyB,EAGA,IAAA8B,GAKAC,OAAA,KAMAC,QAAA,GAMAC,cAAA,GAMAC,gBAAA,SAMAC,QAAA,EAMAC,YAAA,QAMAC,aAAA,QAQAC,YAAA,EAQAC,0BAAA,EAMAC,mBAAA,iDACA,oEACA,mEACA,kDASAC,iBAAA,OAMAC,gBAAA,mDACA,8DACA,8DACA,iEACA,4BAOAC,EAAA,SAAAC,GACAvF,KAAAuF,QAAAC,OAAAC,UAAuChB,EAAAc,GACvCvF,KAAA0F,UAAA,WAAA1F,KAAAuF,QAAAV,gBAAA,SAsGA,SAAAc,EAAA5F,EAAA6F,GAIA,OAHAA,IACA7F,EAAA,UAAA6F,EAAA7F,EAAA8F,cAAA9F,EAAA+F,eAEA/F,EAlGAuF,EAAAnF,UAAA4D,IAAA,SAAAgC,GACA,OAAA/F,KAAAuF,QAAAQ,IAQAT,EAAAnF,UAAA0B,MAAA,SAAAmE,GACA,SAAAhG,KAAA,iBAAAgG,IAAA,IAAAhG,KAAA,WAQAsF,EAAAnF,UAAA4F,KAAA,SAAAE,GACA,OAAAN,EAAAM,EAAAjG,KAAAuF,QAAAZ,UAQAW,EAAAnF,UAAA+F,UAAA,SAAAC,GACA,OAAAR,EAAAQ,EAAAnG,KAAAuF,QAAAX,gBAQAU,EAAAnF,UAAAiG,mBAAA,SAAAD,GACA,OAAAA,EAAAZ,QAAAc,UACA,IAAArG,KAAA+D,IAAA,qBAAAS,SAAA2B,EAAAJ,MAAA,IAAAD,gBAOAR,EAAAnF,UAAAmG,UAAA,WACA,OAAAtG,KAAAuF,QAAAH,kBACA,uBACA,oBACA,mBASAE,EAAAnF,UAAAuE,OAAA,SAAA6B,GAGAA,KAAA,EAEA,IADA,IAAAC,EAAA,GACAD,KACAC,GALAxG,KAKAuF,QAAAb,OAGA,OAAA8B,GAQAlB,EAAAnF,UAAAsG,SAAA,SAAAC,GACA,uBAAAA,GACA,IAAA1G,KAAA+D,IAAA,kBAAAS,QAAAkC,EAAAZ,eAIA,MAAAY,EAAAX,KAAA/F,KAAAyG,SAAAC,EAAAX,MAAAW,EAAAC,YASArB,EAAAnF,UAAAyG,MAAA,SAAAC,EAAAC,GACA,OAAA9G,KAAAuF,QAAAqB,MAAAC,EAAAC,IAUA,IAAAC,EAAA,SAAAC,EAAAzC,GACAvE,KAAAgH,MACAhH,KAAAuE,SAGA0C,EAAA,SAAAC,GACAlH,KAAAmH,QAAA,IAAAlE,IACAjD,KAAAoH,QAAA,IAAAnE,IACAjD,KAAAqH,WAAA,EAEArH,KAAAsH,KAAAJ,IAGAK,GAA0BC,aAE1BD,EAAAC,SAAAzD,IAAA,WACA,OAAA/D,KAAAqH,WAOAJ,EAAA9G,UAAAsH,QAAA,WACAzH,KAAAqH,WAAA,GAMAJ,EAAA9G,UAAAuH,OAAA,WACA1H,KAAAqH,WAAA,GAQAJ,EAAA9G,UAAA+C,IAAA,SAAA8D,EAAAzC,GACA,IAAAoD,EAAA3H,KAEA,oBAAAgH,EACAA,EAAAlE,MAAA,KAAA8E,QAAA,SAAAC,GAA6C,OAAAF,EAAAR,QAAAjE,IAAA2E,EAAA,IAAAd,EAAAc,EAAAtD,UACxC,MAAAyC,aAAAc,QAGL,UAAAC,MAAA,uBAAAf,GAFAhH,KAAAoH,QAAAlE,IAAA8D,EAAA,IAAAD,EAAAC,EAAAzC,IAKA,OAAAvE,MASAiH,EAAA9G,UAAA4D,IAAA,SAAAiD,GAGA,IAAAhH,KAAAwH,SAAA,CAIA,GAAAxH,KAAAmH,QAAAnD,IAAAgD,GACA,OAAAhH,KAAAmH,QAAApD,IAAAiD,GAIA,IADA,IAAAgB,EAAAC,MAAAC,KAAAlI,KAAAoH,QAAAY,QACAG,EAAA,EAAAC,EAAAJ,EAAA9H,OAAqCiI,EAAAC,EAAQD,IAC7C,GAAAH,EAAAG,GAAAE,KAAArB,GACA,OAbAhH,KAaAoH,QAAArD,IAAAiE,EAAAG,MASAlB,EAAA9G,UAAAmH,KAAA,SAAAJ,GACA,IAAAS,EAAA3H,KAEAA,KAAAsI,QACApB,aAAAjE,IACAiE,EAAAU,QAAA,SAAArD,EAAAyC,GAA4C,OAAAW,EAAAzE,IAAA8D,EAAAzC,KACvC2C,GAAA,iBAAAA,GACL1B,OAAAwC,KAAAd,GAAAU,QAAA,SAAAZ,GAAkD,OAAAW,EAAAzE,IAAA8D,EAAAE,EAAAF,OAOlDC,EAAA9G,UAAAmI,MAAA,WACAtI,KAAAmH,QAAAoB,QACAvI,KAAAoH,QAAAmB,SAMAtB,EAAA9G,UAAAqI,OAAA,WACA,GAAAxI,KAAAwH,SACA,SAGA,IAAAzH,EAAAkI,MAAAC,KAAAlI,KAAAmH,QAAAqB,UACAC,EAAAR,MAAAC,KAAAlI,KAAAoH,QAAAoB,UACA,OAAAzI,EAAA2I,OAAAD,IAGAjD,OAAAmD,iBAAA1B,EAAA9G,UAAAoH,GAOA,IAAAqB,EAAA,SAAA1B,GACA,IAAAS,EAAA3H,KAEAA,KAAA6I,aAEAZ,MAAAa,QAAA5B,GACAA,EAAAU,QAAA,SAAAmB,EAAAxC,GAAiD,OAAAoB,EAAAqB,IAAAzC,EAAAwC,KAC5C,iBAAA7B,GACLlH,KAAAgJ,IAAA9B,IASA0B,EAAAzI,UAAA4D,IAAA,SAAAwC,GAGA,IAFA,IAEA4B,EAAA,EAAmBA,EAAAnI,KAAA6I,UAAA3I,OAA2BiI,IAAA,CAC9C,IAAAc,EAHAjJ,KAGA6I,UAAAV,GACA,GAAAc,EAAA1C,UACA,OAAA0C,EAAAC,QAYAN,EAAAzI,UAAA6I,IAAA,SAAAzC,EAAAwC,GACA,MAAAxC,GAAA,iBAAAA,IACAwC,EAAAxC,EACAA,EAAA,GAGA,IAAA2C,EAAA,IAAAjC,EAAA8B,GAQA,OALA/I,KAAAmJ,OAAA5C,GAEAvG,KAAA6I,UAAAjF,MAAyB2C,QAAA2C,UACzBlJ,KAAA6I,UAAAO,KAAA,SAAAC,EAAAC,GAAyC,OAAAA,EAAA/C,MAAA8C,EAAA9C,QAEzC2C,GAOAN,EAAAzI,UAAAgJ,OAAA,SAAAjC,GACAlH,KAAA6I,UAAA7I,KAAA6I,UACAU,OAAA,SAAAN,GAA6B,OAAAA,EAAA1C,QAAAW,GAAA+B,EAAAC,QAAAhC,KAQ7B0B,EAAAzI,UAAAqJ,QAAA,SAAAzD,GAGA,IAFA,IAEAoC,EAAA,EAAmBA,EAAAnI,KAAA6I,UAAA3I,OAA2BiI,IAAA,CAC9C,IAAAsB,EAHAzJ,KAGA6I,UAAAV,GAAAe,MAAAnF,IAAAgC,GACA,GAAA0D,EACA,OAAAA,IAaAb,EAAAzI,UAAAuJ,IAAA,SAAAnE,GACAA,QACA,IAAAoE,EAAA,IAAA1G,IAEA2G,EAAA,SAAAH,GACA,IAAA7D,EAAA6D,EAAAzC,eAAAc,OAAA,kBACAvC,EAAAK,MAAAL,EAAAK,UAAA+D,EAAA3F,IAAAyF,EAAAzC,MACA2C,EAAAzG,IAAAuG,EAAAzC,IAAAyC,IAQA,OAJAzJ,KAAA6I,UAAAjB,QAAA,SAAAqB,GACAA,EAAAC,MAAAV,SAAAZ,QAAAgC,KAGA3B,MAAAC,KAAAyB,EAAAnB,WAMAI,EAAAzI,UAAAoI,MAAA,WACAvI,KAAA6I,UAAA3I,OAAA,GAYA,IAAA2J,EAAA,SAAA9D,EAAAxB,EAAAgB,GACAvF,KAAA+F,OACA/F,KAAAuE,MAAA,MAAAA,IAAA,KACAvE,KAAAuF,eAOAsE,EAAA1J,UAAA2J,MAAA,WACA,WAAAD,EAAA7J,KAAA+F,KAAA/F,KAAAuE,MAAAiB,OAAAC,UAA6DzF,KAAAuF,WAM7DsE,EAAA1J,UAAA4J,QAAA,WACA,OAAA/J,KAAA,UAAAA,KAAA,WAMA,IAAAgK,EAAA,SAAAjE,EAAAkE,GACA,IAAAtC,EAAA3H,KAGAA,KAAA+F,QAAA,KACA/F,KAAAuE,MAAA,KACAvE,KAAAkK,OAAA,KACAlK,KAAAmK,aAAA,EAEAnK,KAAAoK,YAGApK,KAAAqK,OAAA,KAGArK,KAAAsK,KAAA,KAGAtK,KAAAuK,SAAA,KAEAvK,KAAAwK,eAEAvC,MAAAa,QAAAmB,IACAA,EAAArC,QAAA,SAAAzB,GAAsC,OAAAwB,EAAA8C,aAAAtE,MAItCuE,GAA4BT,cAAeU,iBAAkBC,WAAYjE,cAAekE,cAAeC,aAAcC,cAAeC,eAAgBC,mBAAoBC,cA6YxK,SAAAC,EAAApF,EAAAxB,GACA,OAAAwB,aAAA8D,EACA9D,EAGA,iBAAAA,EACA,IAAA8D,EAAA9D,EAAAxB,GAGAwB,GAAA,iBAAAA,EACA,IAAA8D,EAAA9D,SAAAxB,MAAAwB,EAAAR,cADA,EASA,SAAA6F,EAAApF,GACA,OAAAqF,OAAArF,GAAAsF,OAGA,SAAAC,EAAAtC,EAAAd,EAAA7D,GACA,OAAA2E,GAAA3E,EAAAE,QAAAyE,KAAAd,EA9ZAuC,EAAAT,WAAAlG,IAAA,WACA,OAAA/D,KAAAwK,aAOAE,EAAAC,cAAA5G,IAAA,WACA,OAAA/D,KAAAiK,WAAAuB,OAAA,SAAAC,EAAAtF,GAEA,OADAsF,EAAAtF,EAAAJ,MAAAI,EAAAZ,QAAAc,QAAAF,EAAAJ,KAAAI,EAAA5B,MACAkH,QASAf,EAAAE,QAAA7G,IAAA,WACA,OAAA/D,KAAA+F,OAAA/F,KAAAuE,QAAAvE,KAAAwK,YAAAtK,QAOAwK,EAAA/D,WAAA5C,IAAA,WACA,OAAA/D,KAAA+F,QAAA/F,KAAAuE,QAAAvE,KAAAwK,YAAAtK,QAOAwK,EAAAG,WAAA9G,IAAA,WACA,OAAA/D,KAAAoK,SAAA,IAOAM,EAAAI,UAAA/G,IAAA,WACA,OAAA/D,KAAAoK,SAAApK,KAAAoK,SAAAlK,OAAA,IAOAwK,EAAAK,WAAAhH,IAAA,WACA,OAAA/D,KAAAqK,OAAArK,KAAAqK,OAAAD,SAAA5F,QAAAxE,OAAA,GAOA0K,EAAAM,YAAAjH,IAAA,WACA,OAAA/D,KAAAsK,MAOAI,EAAAO,gBAAAlH,IAAA,WACA,OAAA/D,KAAAuK,UAOAG,EAAAQ,UAAAnH,IAAA,WACA,IAAAoC,EAAAnG,KAAA0L,aAAA,SACA,OAAAvF,KAAA5B,MACA4B,EAAA5B,MAAAzB,MAAA,QAAAyG,OAAAgC,OAUAvB,EAAA7J,UAAAwL,OAAA,SAAA5F,EAAAkE,GACA,WAAAD,EAAAjE,EAAAkE,IAQAD,EAAA7J,UAAAsK,aAAA,SAAA1E,EAAAxB,GACA,IAAA4B,EAAAgF,EAAApF,EAAAxB,GACAqH,EAAA5L,KAAA0L,aAAA3F,GACA6F,EACA5L,KAAA6L,iBAAAD,EAAAzF,GAEAnG,KAAAwK,YAAA5G,KAAAuC,IASA6D,EAAA7J,UAAA2L,aAAA,SAAA/F,GACA,QAAA/F,KAAA0L,aAAA3F,IAQAiE,EAAA7J,UAAAuL,aAAA,SAAA3F,GAGA,iBAAAA,IACAA,UAGA,QAAAoC,EAAA,EAAgBA,EAAAnI,KAAAwK,YAAAtK,OAA6BiI,IAAA,CAC7C,IAAAhC,EAPAnG,KAOAwK,YAAArC,GACA,GAAAhC,EAAAJ,SACA,OAAAI,IAYA6D,EAAA7J,UAAA0L,iBAAA,SAAAE,EAAAC,EAAAC,GACA,iBAAAF,IACAA,EAAA/L,KAAA0L,aAAAK,IAGA,IAAAG,EAAAlM,KAAAwK,YAAAhG,QAAAuH,IACA,IAAAG,GACAlM,KAAAwK,YAAA2B,OAAAD,EAAA,EAAAf,EAAAa,EAAAC,KAQAjC,EAAA7J,UAAAiM,gBAAA,SAAAjG,GACA,iBAAAA,IACAA,EAAAnG,KAAA0L,aAAAvF,IAGA,IAAA+F,EAAAlM,KAAAwK,YAAAhG,QAAA2B,IACA,IAAA+F,GACAlM,KAAAwK,YAAA2B,OAAAD,EAAA,IAOAlC,EAAA7J,UAAAkM,gBAAA,WACArM,KAAAwK,YAAAtK,OAAA,GAOA8J,EAAA7J,UAAAmM,SAAA,SAAAC,GACAA,EAAAnB,EAAAmB,GAEAvM,KAAA8L,aAAA,SAEES,IAAAvM,KAAAwM,SAAAD,IACFvM,KAAAyK,aAAA,QAAAzK,KAAAkL,UAAAxC,OAAA6D,GAAAE,KAAA,MAFAzM,KAAAyK,aAAA,QAAA8B,IAWAvC,EAAA7J,UAAAqM,SAAA,SAAAD,GACA,WAAAvM,KAAAkL,UAAA1G,QAAA4G,EAAAmB,KAOAvC,EAAA7J,UAAAuM,YAAA,SAAAH,GACAA,EAAAnB,EAAAmB,GACAvM,KAAAwM,SAAAD,IACAvM,KAAAyK,aAAA,QAAAzK,KAAAkL,UAAA3B,OAAA,SAAAxD,GAAoE,OAAAA,IAAAwG,IAAyBE,KAAA,OAQ7FzC,EAAA7J,UAAAwM,YAAA,SAAAjG,GACA1G,KAAA4M,SAAAlG,EAAA1G,KAAAoK,SAAAlK,SAQA8J,EAAA7J,UAAA0M,aAAA,SAAAC,EAAAC,GACA/M,KAAA4M,SAAAE,EAAA9M,KAAAoK,SAAA5F,QAAAuI,KAQA/C,EAAA7J,UAAAyM,SAAA,SAAAlG,EAAAzG,GACA,GAAAA,EAAA,GAAAA,EAAAD,KAAAoK,SAAAlK,OACA,UAAA6H,MAAA,8DAGA,IAAAvH,EAAAR,KAAAoK,SAAAnK,EAAA,GACAqK,EAAAtK,KAAAoK,SAAAnK,GAEAyG,EAAAyC,SACAzC,EAAA2D,OAAArK,KACAA,KAAAoK,SAAA+B,OAAAlM,EAAA,EAAAyG,GAEAlG,IACAkG,EAAA6D,SAAA/J,EACAA,EAAA8J,KAAA5D,GAGA4D,IACA5D,EAAA4D,OACAA,EAAAC,SAAA7D,IAQAsD,EAAA7J,UAAA6M,YAAA,SAAAtG,GACA,IAAAwF,EAAAlM,KAAAoK,SAAA5F,QAAAkC,IACA,IAAAwF,IACAlM,KAAAoK,SAAA+B,OAAAD,EAAA,GACAxF,EAAA6D,WACA7D,EAAA6D,SAAAD,KAAA5D,EAAA4D,MAGA5D,EAAA4D,OACA5D,EAAA4D,KAAAC,SAAA7D,EAAA6D,UAGA7D,EAAA2D,OAAA3D,EAAA4D,KAAA5D,EAAA6D,SAAA,OAOAP,EAAA7J,UAAAgJ,OAAA,WACAnJ,KAAAqK,QACArK,KAAAqK,OAAA2C,YAAAhN,OASAgK,EAAA7J,UAAA2J,MAAA,SAAAmD,GACA,IAAAnD,EAAA,IAAAE,EAAAhK,KAAA+F,MAaA,OAZA+D,EAAAvF,MAAAvE,KAAAuE,MACAuF,EAAAK,YAAAnK,KAAAmK,YACAnK,KAAAkK,SACAJ,EAAAI,OAAA1E,OAAAC,UAAiCzF,KAAAkK,SAGjClK,KAAAwK,YAAA5C,QAAA,SAAAzB,GAA2C,OAAA2D,EAAAW,aAAAtE,EAAA2D,WAE3CmD,GACAjN,KAAAoK,SAAAxC,QAAA,SAAAsF,GAA0C,OAAApD,EAAA6C,YAAAO,EAAApD,OAAA,MAG1CA,GASAE,EAAA7J,UAAAgN,KAAA,SAAAC,EAAAC,GACAA,KAAA,EAGA,IAFA,IAAAC,EAAAtN,KAAA6K,WAEAyC,GAAA,CAEA,IAAAhD,EAAAgD,EAAAhD,KAEA,QAAA8C,EAAAE,EAAAD,KAAA,IAAAC,EAAAH,KAAAC,EAAAC,EAAA,GACA,SAGAC,EAAAhD,IAQAN,EAAA7J,UAAAoN,IAAA,SAAAH,GAIA,IAHA,IAAAI,EAAAC,UAEAC,GAAA1N,MACAmI,EAAA,EAAgBA,EAAAsF,UAAAvN,OAAsBiI,IACtCuF,EAAA9J,KAAA4J,EAAArF,IAIA,OADAiF,EAAAO,MAAA,KAAAD,GACA1N,MAGAgK,EAAA7J,UAAAyN,SAAA,WACA,IAAAjG,EAAA3H,KAEA6N,EAAA7N,KAAAiK,WAAAlH,IAAA,SAAAoD,GAEA,IAAA2H,GADA3H,EAAAwB,EAAA+D,aAAAvF,EAAAJ,OACAR,QACAkG,GAAAqC,KAAAC,QAAA,SAAA5H,EAAAJ,MAAA,IAMA,OALA+H,KAAAzH,QACAoF,GAAA,IACG,MAAAtF,EAAA5B,QACHkH,GAAA,KAAAtF,EAAA,WAEAsF,IAGAA,EAAA,IAAAzL,KAAA+F,MAAA,IAoBA,OAnBA8H,EAAA3N,SACAuL,GAAA,IAAAoC,EAAApB,KAAA,UAGA,MAAAzM,KAAAuE,QACAkH,GAAA,IAAWzL,KAAA,WAGXA,KAAAmK,cACAsB,GAAA,KAGAzL,KAAAkK,SACAuB,GAAA,KAAAzL,KAAAkK,OAAA8D,MAAAhO,KAAAkK,OAAA8D,MAAA,IACA,MAAAhO,KAAAkK,OAAA3F,QACAkH,GAAA,IAAAzL,KAAAkK,OAAA,QAIAuB,GAGAjG,OAAAmD,iBAAAqB,EAAA7J,UAAAuK,GAqCA,IAAAuD,EAAA,SAAAlO,EAAAc,EAAAqN,GACA,MAAAA,GAAA,iBAAAnO,IACAmO,EAAAnO,EAAAG,QAGAF,KAAAD,SACAC,KAAAC,IAAAD,KAAAa,SAAA,EACAb,KAAAkO,OAOAD,EAAA9N,UAAAgO,IAAA,WACA,OAAAnO,KAAAC,KAAAD,KAAAkO,KAWAD,EAAA9N,UAAAiO,MAAA,SAAAvN,EAAAqN,GACA,WAAAlO,KAAAqO,YAAArO,KAAAD,OAAAc,EAAAqN,IAQAD,EAAA9N,UAAAE,KAAA,WACA,OAAAL,KAAAD,OAAAQ,WAAAP,KAAAC,MAQAgO,EAAA9N,UAAAmK,KAAA,WACA,GAAAtK,KAAAC,IAAAD,KAAAD,OAAAG,OACA,OAAAF,KAAAD,OAAAQ,WAAAP,KAAAC,QAYAgO,EAAA9N,UAAAM,IAAA,SAAAC,GACA,IAAA2B,EAAArC,KAAAK,OACAM,EAAA,mBAAAD,IAAA2B,OAAA3B,EAMA,OAJAC,GACAX,KAAAsK,OAGA3J,GASAsN,EAAA9N,UAAAS,SAAA,SAAAF,GAEA,IADA,IAAAG,EAAAb,KAAAC,KACAD,KAAAmO,OAAAnO,KAAAS,IAAAC,KACA,OAAAV,KAAAC,MAAAY,GAQAoN,EAAA9N,UAAAmO,OAAA,SAAAC,GACAvO,KAAAC,KAAAsO,GAAA,GAQAN,EAAA9N,UAAAqO,QAAA,WACA,OAAAxO,KAAAyO,UAAAzO,KAAAa,MAAAb,KAAAC,MASAgO,EAAA9N,UAAAsO,UAAA,SAAA5N,EAAAqN,GACA,OAAAlO,KAAAD,OAAAoE,MAAAtD,EAAAqN,IAQAD,EAAA9N,UAAAuO,MAAA,SAAAC,GACA,IAAAC,EAAA,IAAA7G,MAAA4G,EAAA,aAAA3O,KAAAC,IAAA,IAIA,OAHA2O,EAAAC,gBAAAF,EACAC,EAAA3O,IAAAD,KAAAC,IACA2O,EAAA7O,OAAAC,KAAAD,OACA6O,GAOA,IAAAE,EAAA,GACAC,EAAA,GAEAC,GACAC,OAAA,GACAC,QAAA,GAWAC,EAAA,SAAA3N,EAAA+D,GACAA,IAAAC,OAAAC,UAAqCuJ,EAAAzJ,GAAAyJ,EACrC,IAAAnO,EAAAW,EAAAvB,IACA4B,EAAAL,EAAAnB,OAEA,GAAAmB,EAAAf,IAAA2O,GAAA,CACA,MAAA5N,EAAA2M,OACA,OAAA3M,EAAA8I,QACA,KAAAzI,EAEA,OADAL,EAAAX,SACA,EAEA,KAAA0E,EAAA0J,OACAzN,EAAA8I,OASA,GAFA9I,EAAAvB,IAAAY,EAEA0E,EAAA2J,OACA,MAAA1N,EAAAkN,MAAA,mCAIA,UAGA,SAAAU,EAAAhN,GACA,OAAAA,IAAA0M,GAAA1M,IAAA2M,EAQA,SAAAM,EAAAjN,GACA,OAAAA,EAAA,IAAAA,EAAA,GAUA,SAAAkN,EAAAlN,EAAA8F,EAAAqH,GAKA,OAJArH,KAAA,GACAqH,KAAA,IACAnN,IAAA,KAEA8F,GAAA9F,GAAAmN,EAQA,SAAAC,EAAApN,GACA,OAAAiN,EAAAjN,IAAAkN,EAAAlN,GAGA,SAAAqN,EAAArN,GACA,YAAAA,GACA,IAAAA,GACA,MAAAA,EAQA,SAAAsN,EAAAtN,GACA,OAAAqN,EAAArN,IACA,KAAAA,GACA,KAAAA,EAGA,IAAAuN,IACAV,OAAA,GACAC,QAAA,GAYA,SAAAU,GAAApO,EAAAqO,EAAAC,EAAAvK,GACAA,IAAAC,OAAAC,UAAqCkK,GAAApK,GAAAoK,GACrC,IAAA9O,EAAAW,EAAAvB,IAEA,GAAAuB,EAAAf,IAAAoP,GAAA,CAGA,IAFA,IAAAxN,EAAAsB,EAAA,GAEAnC,EAAA2M,OACA,IAAAgB,EAAA3N,EAAA+D,GAKA,IADAlD,EAAAb,EAAA8I,UACAuF,EACAlM,SACI,GAAAtB,IAAAyN,GAEJ,MADAnM,EAGA,OADAnC,EAAAX,SACA,OAEIwB,IAAAkD,EAAA0J,QACJzN,EAAA8I,OAOA,GAFA9I,EAAAvB,IAAAY,EAEA0E,EAAA2J,OACA,MAAA1N,EAAAkN,MAAA,oCAAArD,OAAA0E,aAAAF,IAIA,SAGA,IAQAG,GAAA,SAAAxO,GACA,GAAAA,EAAAf,IATA,IAaA,OAHAe,EAAAX,MAAAW,EAAAvB,KAGU+N,MAAAxM,EAAAZ,SAAAyO,IAAA7N,EAAAgN,UAAA,OAIVV,IAAWoB,QAAA,GASXe,GAAA,SAAAzO,GACA,GAAA2N,EAAA3N,EAAAsM,IACA,OAAAtM,EAAAgN,UAAArK,MAAA,OAOA+L,IAAahB,QAAA,GAObiB,GAAA,SAAA3O,GACA,OAAAoO,GAAApO,EAXA,IACA,IAUA0O,IACA1O,EAAAgN,UAAArK,MAAA,MACA,MAGAiM,GAAA,GACAC,GAAA,GACAC,GAAA,GACAC,GAAA,GACAC,GAAA,GAEAC,GAAA,sBASAC,GAAA,SAAAlP,GACA,IAAAA,EAAAf,IAAA8P,IACA,YAMA,IAHA,IACAhE,EAAApG,EADAwD,MAGAnI,EAAA2M,OAAA,CAGA,GAFA3M,EAAAZ,SAAA6O,GAEAjO,EAAAf,IAAA+P,IACA,OAAA7G,EACG,UAAA4C,EAAA0D,GAAAzO,IAEHmI,EAAA/F,MACAmC,KAAA,KACAxB,MAAAgI,QAEG,KAAAoE,GAAAnP,GA4BH,MAAAA,EAAAkN,MAAA,2BA1BAnC,EAAA/K,EAAAgN,UACAiC,GAAApI,KAAAkE,IAKApG,EAAAyK,GAAArE,GACA5C,EAAA/F,KAAAuC,GAEA3E,EAAAf,IAAA6P,MAGA,OAAA/D,EAAA0D,GAAAzO,IACA2E,EAAA5B,MAAAgI,EACM,OAAAA,EAAA4D,GAAA3O,KACN2E,EAAA5B,MAAAgI,EACApG,EAAAZ,SACAsL,OAAA,IACAC,MAAA,MAEMH,GAAAnP,KACN2E,EAAA5B,MAAA/C,EAAAgN,aAlBA7E,EAAA/F,MAAiBmC,KAAA,KAAAxB,MAAAgI,KA2BjB,MAAA/K,EAAAkN,MAAA,+BAGA,SAAAkC,GAAA7K,GACA,IAAAR,KAIAQ,EAAAxF,WAAA,KAAA6P,KACArK,IAAA5B,MAAA,GACAoB,EAAAwI,SAAA,GAIAhI,EAAAxF,WAAAwF,EAAA7F,OAAA,KAAAmQ,KACAtK,IAAA5B,MAAA,EAAA4B,EAAA7F,OAAA,GACAqF,EAAAc,SAAA,GAGA,IAAAF,GAAaJ,QAKb,OAJAP,OAAAwC,KAAAzC,GAAArF,SACAiG,EAAAZ,WAGAY,EAQA,SAAAwK,GAAAnP,GACA,IAAAX,EAAAW,EAAAvB,IACA,GAAAuB,EAAAZ,SAAAmQ,IAEA,OADAvP,EAAAX,SACA,EAIA,SAAAkQ,GAAA3O,GACA,OAAAsN,EAAAtN,KAAAgN,EAAAhN,IACAA,IAAAmO,IAAAnO,IAAAoO,IAAApO,IAAAkO,GAGA,IASAU,GAAA,SAAAxP,GAMA,IAJA,IAEA8I,EAFAzJ,EAAAW,EAAAvB,IACAyG,EAAA,IAAAsD,EAAAiH,GAAAzP,KAGAA,EAAA2M,OACA,GAAA3M,EAAAf,IAfA,IAgBAiG,EAAA4F,SAAA2E,GAAAzP,SACG,GAAAA,EAAAf,IAlBH,IAmBAiG,EAAA+D,aAAA,KAAAwG,GAAAzP,QACG,IAAAA,EAAAf,IAlBH,IAkBG,CAEH,GAAAiG,EAAAkE,QAEA,MADApJ,EAAA8M,OAAA,GACA9M,EAAAkN,MAAA,qCAEAhI,EAAAyD,aAAA,GACAG,EAAA0F,GAAAxO,MACAkF,EAAAwD,OAAAI,GAEA,MACG,GAAAA,EAAAoG,GAAAlP,GACH,QAAA2G,EAAA,EAAAC,EAAAkC,EAAApK,OAAoCiI,EAAAC,EAAQD,IAC5CzB,EAAA+D,aAAAH,EAAAnC,SAEG,WAAAmC,EAAA6F,GAAA3O,IACHkF,EAAAnC,MAAA+F,MACG,MAAAA,EAAA0F,GAAAxO,IAGH,MAFAkF,EAAAwD,OAAAI,GAMA,GAAAzJ,IAAAW,EAAAvB,IACA,MAAAuB,EAAAkN,MAAA,mDAAAlN,EAAAnB,QAGA,OAAAqG,GAGA,SAAAuK,GAAAzP,GAGA,OAFAA,EAAAX,MAAAW,EAAAvB,IACAuB,EAAAZ,SAAAsQ,IACA1P,EAAAgN,UAGA,SAAA0C,GAAA9O,GACA,OAAAoN,EAAApN,IACA,KAAAA,GACA,KAAAA,GACA,KAAAA,GACA,KAAAA,GACA,KAAAA,GACA,KAAAA,GACA,KAAAA,EAGA,IAAA+O,GAAA,GACAC,GAAA,GACAC,GAAA,GACAC,GAAA,GACAC,GAAA,GA6FA,IAAA1K,GAAA,SAAA2K,GACA,IAAAC,EAvFA,SAAAzL,GAKA,IAJA,IAEA3D,EAyEAiC,EA3EA9C,EAAA,IAAAyM,EAAAjI,EAAAsF,QACAoG,EAAA,IAAA1H,EACAsD,EAAAoE,EAAAC,MAEAnQ,EAAA2M,OAGA,IAFA9L,EAAAb,EAAAnB,UAEA8Q,GASG,GAAA9O,IAAA+O,GAAA,CAyBH,IAAAQ,EAAAZ,GAAAxP,GAGA,GAFA8L,EAAAX,YAAAiF,GAEApQ,EAAA2M,MACA,MAGA,OAAA3M,EAAAnB,QACA,KAAAgR,GACA7P,EAAA8I,OACA,SAEA,KAAAgH,GACA9P,EAAA8I,OACAgD,EAAAsE,EACA,SAEA,KAAAL,GAEA,KAAA/P,EAAAf,IAAA8Q,KACAjE,IAAAjD,QAAAiD,EAEA,cA/CG,CACH,IAAAuE,EAAAF,EAAA7N,MACA,IAAA+N,EACA,MAAArQ,EAAAkN,MAAA,4BAGA,IAAAoD,EAAAD,EAAA,GAKA,GAJAvE,EAAAuE,EAAA,GACArQ,EAAA8I,OAGAwH,EAAA5H,OAAA8F,GAAAxO,GACA8L,EAAAX,YAAAmF,OACI,CAEJ,KAAAA,EAAAjH,YACAyC,EAAAX,YAAAmF,EAAAjH,YAGArJ,EAAAf,IAAA4Q,SA5BA,CAGA,IAAA3K,EAAA,IAAAsD,EACA+H,EAAAJ,EAAAzR,QAgEAoE,EAhEAqN,EAiEArN,IAAApE,OAAA,IAjEA,GAAAoN,EACAqE,EAAA/N,MAAA8C,EAAAqL,EAAAvQ,EAAAvB,MACAqN,EAAA5G,EACAlF,EAAA8I,OAqDA,GAAAqH,EAAAzR,OAEA,MADAsB,EAAAvB,IAAA0R,EAAA7N,MAAA,GACAtC,EAAAkN,MAAA,wBAGA,OAAAgD,EAcAM,CAAAR,GAEA,OADAC,EAAAtE,KAAA8E,IACAR,GAGA,SAAAQ,GAAAvL,GACA,GAAAA,EAAAwD,QAAAxD,EAAAwD,OAAA8D,MAAA,CAIA,QAAA7F,EAAA,EAAgBA,EAAAzB,EAAAwD,OAAA8D,MAAuB7F,IAAA,CACvC,IAAA2B,EAAApD,EAAAoD,OAAA,GACAA,EAAAI,OAAA3F,MAAA4D,EACA2B,EAAAqD,KAAA8E,IACAvL,EAAA2D,OAAAwC,aAAA/C,EAAApD,GAGAA,EAAAwD,OAAA3F,MAAAmC,EAAAwD,OAAA8D,OAkBA,IAAAkE,GAAA,SAAAT,EAAAU,GAEA,OADAV,EAAAtE,KAAA,SAAAzG,GAA+B,OAI/B,SAAAA,EAAAyL,GACA,IAAAxO,EAAA,IAAAd,IACA2G,EAAA,SAAA9C,GACA,IAAA+C,EAAA0I,EAAA3I,QAAA9C,EAAAX,MAKA,GAAA0D,IAAA9F,EAAAK,IAAAyF,GAAA,CAKA,sBAAAA,EAAAlF,MACA,OAAAkF,EAAAlF,MAAAmC,EAAAyL,EAAA3I,GAGA,IAAAiI,EAAA5K,GAAA4C,EAAAlF,OAEAZ,EAAAqF,IAAAS,GACAgI,EAAAtE,KAAA3D,GACA7F,EAAAyO,OAAA3I,GAGA,IAAA4I,EAyGA,SAAA3L,GACA,KAAAA,EAAA0D,SAAAlK,QACAwG,IAAA0D,SAAA1D,EAAA0D,SAAAlK,OAAA,GAGA,OAAAwG,EA9GA4L,CAAAb,GAGA,KAiBA,SAAAvJ,EAAAqH,GACAA,EAAAxJ,KAAAmC,EAAAnC,KAEAmC,EAAAiC,cACAoF,EAAApF,aAAA,GAGA,MAAAjC,EAAA3D,QACAgL,EAAAhL,MAAA2D,EAAA3D,OAGA2D,EAAAgC,SACAqF,EAAArF,OAAA1E,OAAAC,UAAoCyC,EAAAgC,UAapC,SAAAhC,EAAAqH,IA8CA,SAAArH,EAAAqH,GAEA,IADA,IAAAgD,EAAArK,EAAAgD,UACA/C,EAAA,EAAmBA,EAAAoK,EAAArS,OAAuBiI,IAC1CoH,EAAAjD,SAAAiG,EAAApK,IAhDAqK,CAAAtK,EAAAqH,GAQA,IAHA,IAAAkD,EAAA,IAAAxP,IAEA4K,EAAA3F,EAAA+B,WACA9B,EAAA,EAAmBA,EAAA0F,EAAA3N,OAAkBiI,IACrCsK,EAAAvP,IAAA2K,EAAA1F,GAAApC,KAAA8H,EAAA1F,GAAA2B,SAGA+D,EAAA0B,EAAAtF,WAAA9F,QACA,QAAAuO,EAAA,EAAAvM,OAAA,EAAAkD,OAAA,EAAoDqJ,EAAA7E,EAAA3N,OAAoBwS,IACxEvM,EAAA0H,EAAA6E,GACAD,EAAAzO,IAAAmC,EAAAJ,QACAsD,EAAAoJ,EAAA1O,IAAAoC,EAAAJ,OACAxB,MAAA4B,EAAA5B,MAIA8E,EAAA9D,QAAAwI,UACA1E,EAAA9D,QAAAwI,SAAA,IAGA0E,EAAAvP,IAAAiD,EAAAJ,KAAAI,GAGAoJ,EAAAnD,gBAAAjG,GAIA,IADA,IAAAwM,EAAA1K,MAAAC,KAAAuK,EAAAjK,UACAoK,EAAA,EAAqBA,EAAAD,EAAAzS,OAAuB0S,IAC5CrD,EAAA9E,aAAAkI,EAAAC,KA5CAC,CAAA3K,EAAAqH,GAlCAuD,CAAAT,EAAA3L,GAEA+K,EAAA5G,YACAnE,EAAA2D,OAAAwC,aAAA4E,EAAA5G,WAAAnE,GAGA2L,EAAAhI,OAAAwC,aAAAnG,EAAA2L,GACAA,EAAAlJ,WAGAK,EAAA9C,GAvC+BqM,CAAArM,EAAAyL,KAC/BV,GA4IA,IAAApM,GAAA,IAAAxC,IAAA,8LAAAC,MAAA,MACAkQ,IACAC,EAAA,OACAC,GAAA,KACAC,GAAA,KACAC,MAAA,KACAC,GAAA,KACAC,MAAA,KACAC,MAAA,KACAC,MAAA,KACAC,SAAA,MACAC,OAAA,SACAC,SAAA,SACAC,MAAA,SACAC,MAAA,SACAC,OAAA,QACA/Q,IAAA,QAQA,SAAAgR,GAAAC,GAEA,OADAA,MAAA,IAAAlO,cACAkN,GAAAgB,KACA3O,GAAArB,IAAAgQ,GAAA,cAMA,IAAAC,GAAA,SAAAxC,GAOA,OANAA,EAAAtE,KAAA,SAAAzG,GAEA,MAAAA,EAAAX,MAAAW,EAAAuD,WAAA/J,SACAwG,EAAAX,KAAAgO,GAAArN,EAAA2D,OAAAtE,SAGA0L,GASA,SAAAyC,GAAAlO,EAAAuG,GAMA,IALA,IAAA5C,EAAA,IAAA9G,IACAsR,EAAA5H,EAAArM,OAGAD,EAAA,GACA,KAAAA,EAAA+F,EAAAxB,QAAA+H,EAAAtM,KACA0J,EAAAX,IAAA/I,GACAA,GAAAkU,EAGA,GAAAxK,EAAAyK,KAKA,IAHA,IAAAC,EAAA,EACAC,EAAAtO,EAAA9F,OAEAmU,EAAAC,GACA,OAAAtO,EAAAqO,MACA1K,EAAAyI,OAAAiC,KAKA,OAAApM,MAAAC,KAAAyB,GAAA5G,IAAA,SAAAmJ,GAAiD,OAAAA,EAAAiI,KAWjD,SAAAI,GAAAvO,EAAAwO,EAAAjQ,GAEA,QAAA4D,EAAAqM,EAAAtU,OAAA,EAAgCiI,GAAA,EAAQA,IAAA,CACxC,IAAAsM,EAAAD,EAAArM,GAEAnC,IAAAyI,UAAA,EAAAgG,EAAA,KACA,mBAAAlQ,IAAAyB,EAAA0O,OAAAD,EAAA,GAAAA,EAAA,KAAAlQ,GACAyB,EAAAyI,UAAAgG,EAAA,GAAAA,EAAA,IAGA,OAAAzO,EAOA,IAAA2O,GAAA,IAMAC,GAAA,SAAAnD,GAEA,OADAA,EAAAtE,KAAA0H,IACApD,GASA,SAAAoD,GAAAnO,GACA,IAAAoO,EA0BA,SAAApO,GACA,KAAAA,GAAA,CACA,GAAAA,EAAAwD,OACA,OAAAxD,EAAAwD,OAGAxD,IAAA2D,QAhCA0K,CAAArO,GAEA,GAAAoO,GAAA,MAAAA,EAAAvQ,MAAA,CAIA,IAAAA,EAAAuQ,EAAAvQ,MAEAmC,EAAAX,KAAAiP,GAAAtO,EAAAX,KAAAxB,GACAmC,EAAAnC,MAAAyQ,GAAAtO,EAAAnC,SACAmC,EAAAuD,WAAArC,QAAA,SAAAzB,GACA,IAAA8O,EAAAvO,EAAAgF,aAAAvF,EAAAJ,MAAA+D,QACAmL,EAAAlP,KAAAiP,GAAA7O,EAAAJ,KAAAxB,GACA0Q,EAAA1Q,MAAAyQ,GAAA7O,EAAA5B,SACAmC,EAAAmF,iBAAA1F,EAAAJ,KAAAkP,KAIA,OAAAvO,EAwBA,SAAAsO,GAAAhP,EAAAzB,GAGA,uBAAAyB,EAqCA,SAAAA,EAAAwO,EAAAjQ,GAWA,OAQA,SAAAyB,GACA,IAAAmC,EAAA,EAAAwB,EAAA,GACA2K,EAAAtO,EAAA9F,OAEA,KAAAiI,EAAAmM,GAAA,CACA,IAAAjS,EAAA2D,EAAAmC,KACAwB,GAAA,OAAAtH,EAAA2D,EAAAmC,MAAA,GAAA9F,EAGA,OAAAsH,EAjBAuL,CAVAX,GAAAvO,EAAAwO,EAAA,SAAAjI,GAGA,IAFA,IAAA4I,EAAA9J,OAAA9G,GAEA4Q,EAAAjV,OAAAqM,EAAArM,QACAiV,EAAA,IAAAA,EAEA,OAAAA,KA1CAC,CAAApP,EAYA,SAAAA,GACA,OAAAkO,GAAAlO,GAAA,GAAA2O,IACAnJ,OAAA,SAAAC,EAAA4J,GAEA,WAAiBhN,KAAArC,EAAAqP,EAAA,YACjB,IAAAC,EAAA7J,IAAAvL,OAAA,GACAoV,KAAA,GAAAA,EAAA,KAAAD,EAAA,GACAC,EAAA,IAAAD,EAAA,GAEA5J,EAAA7H,KAAAyR,GAIA,OAAA5J,OA1BA8J,CAAAvP,GACAzB,GAGAyB,EAgEA,IAAAc,GAAA,KAGA0O,GAAA,IAEAC,GAAA,8EACAC,GAAA,kDACAC,GAAA,mBAqBA,SAAAC,GAAAnE,EAAAoE,GAiBA,OAhBAA,KAAA,EACApE,EAAAtE,KAAA,SAAAzG,GACA,GAAAA,EAAAwD,QAAA,OAAAxD,EAAAwD,OAAA8D,MAAA,CACA,QAAA7F,EAAA,EAA2BA,EAAA0N,EAAY1N,IAAA,CACvC,IAAA2B,EAAApD,EAAAoD,OAAA,GACAA,EAAAI,OAAA4L,UAAA,EACAhM,EAAAI,OAAA8D,MAAA6H,EACA/L,EAAAI,OAAA3F,MAAA4D,EAAA,EACA2B,EAAAI,OAAArD,MAAAsB,EACAzB,EAAA2D,OAAAwC,aAAA/C,EAAApD,GAGAA,EAAAyC,YAIAsI,EASA,SAAAsE,GAAAtE,EAAAuE,GACA,GAAA/N,MAAAa,QAAAkN,MAAA9V,OAAA,CACA,IAAA+V,GAAA,EACAxE,EAAAtE,KAAA,SAAAzG,GACAA,EAAAwD,QAAAxD,EAAAwD,OAAA4L,WACAG,GAAA,EAsBA,SAAAvP,EAAAsP,GACA,IAAAE,EAAAC,GAAAzP,EAAAsP,GACAtP,EAAAyG,KAAA,SAAAD,GAA6B,OAAAgJ,GAAAC,GAAAjJ,EAAA8I,KAE7BE,GAEAE,GAAAC,GAAA3P,GAAAsP,GA3BAM,CAAA5P,EAAAsP,EAAAtP,EAAAwD,OAAArD,WAIAoP,GAGAG,GAAAC,GAAA5E,GAAAuE,EAAAvJ,KAAA,OAIA,OAAAgF,EA6BA,SAAA0E,GAAAzP,EAAAsP,GACA,IAAAO,GAAcC,UAAA,GASd,OAPA9P,EAAAnC,MAAAkS,GAAA/P,EAAAnC,MAAAyR,EAAAO,GACA7P,EAAAuD,WAAArC,QAAA,SAAAzB,GACAA,EAAA5B,OACAmC,EAAA+D,aAAAtE,EAAAJ,KAAA0Q,GAAAtQ,EAAA5B,MAAAyR,EAAAO,MAIAA,EAAAC,SAWA,SAAAC,GAAAzQ,EAAAzB,EAAAmS,GACA,oBAAA1Q,EAAA,CACA,IAAAwO,EAAAN,GAAAlO,EAAAc,IACA0N,EAAAtU,SACAwW,IACAA,EAAAF,UAAA,GAGAxQ,EAAAuO,GAAAvO,EAAAwO,EAAAjQ,IAIA,OAAAyB,EAQA,SAAAqQ,GAAA3P,GACA,KAAAA,EAAA0D,SAAAlK,QACAwG,IAAA0D,SAAA1D,EAAA0D,SAAAlK,OAAA,GAGA,OAAAwG,EAQA,SAAA0P,GAAA1P,EAAAsP,GAEA,GAAAtP,EAAAnC,MAAA,CACA,IAAAiQ,EAAAN,GAAAxN,EAAAnC,MAAAiR,IACA,GAAAhB,EAAAtU,OAEA,YADAwG,EAAAnC,MAAAgQ,GAAA7N,EAAAnC,MAAAiQ,EAAAwB,KAKAtP,EAAAX,KAAAD,YAAA,MAAAY,EAAAoF,aAAA,WAEA2J,GAAApN,KAAA2N,GACAtP,EAAA+D,aAAA,QAAAkL,GAAAtN,KAAA2N,GAAA,cAAAA,GACGN,GAAArN,KAAA2N,IACHtP,EAAA+D,aAAA,iBAAAuL,IAIAtP,EAAAnC,MAAAyR,EAGA,IAAAW,IACAC,QAAA,KACAC,SAAA,KAGAC,GAAA,oBACAC,GAAA,oBACAC,GAAA,SAAAC,GAA6C,kBAAA5O,KAAA4O,IAC7CC,GAAA,SAAAD,GAA6C,gBAAA5O,KAAA4O,IAoH7C,SAAAE,GAAAzQ,EAAA0Q,EAAAC,GAEA,IADA,IAAAC,EAAAD,EAAAnX,OAAA,EAAAmX,EAAAnX,OAAA,EACAwG,EAAA2D,QAAAiN,KACA5Q,IAAA2D,OAGA,OAAA+M,EAAArT,IAAA2C,GAGA,SAAA6Q,GAAAjT,EAAAiF,GACA,OAAAjF,EAAAiF,UAAA,GAeA,SAAAnF,GAAAsC,EAAA8Q,EAAAxL,GACA,IAAA7F,EAAAO,EAAAgF,aAAA8L,GACArR,IACAA,EAAAJ,KAAAiG,GAIA,IAAAyL,GAAA,gCAeAC,IAAuBC,IA3JvB,SAAAlG,EAAAlM,GACAA,EAAAC,OAAAC,UAA2BkR,GAAApR,GAE3BkM,EAAAtE,KAAA,SAAAzG,GAA4B,OAgB5B,SAAAA,EAAAnB,GACA,IAAAgN,EAAA7L,EAAAwE,UAAAM,OAAA,SAAAC,EAAAmM,GAEA,IAAA1L,EAAA0L,EAAApT,QAAAe,EAAAsR,UAKA,OAJA,IAAA3K,GACAT,EAAAzC,IAAA4O,EAAAzT,MAAA,EAAA+H,IAGAT,EAAAzC,IAAA4O,IACE,IAAA/U,KAEF0P,EAAA6B,MACA1N,EAAA+D,aAAA,QAAAxC,MAAAC,KAAAqK,GAAA9F,KAAA,MA5B4BoL,CAAAnR,EAAAnB,KAE5B,IAAA6R,EA6EA,SAAA3F,GACA,IAAA2F,EAAA,IAAAnU,IAcA,OAZAwO,EAAAtE,KAAA,SAAAzG,GACA,IAAA6L,EAAA7L,EAAAwE,UACAqH,EAAArS,QAEAkX,EAAAlU,IAAAwD,EACA6Q,GAAAhF,EAAAyE,KACAO,GAAAhF,EAAA2E,KACAE,EAAArT,IAAA2C,EAAA2D,WAKA+M,EA5FAU,CAAArG,GAGA,OAFAA,EAAAtE,KAAA,SAAAzG,GAA+B,OAmC/B,SAAAA,EAAA0Q,EAAA7R,GACA,IAAAgN,EAAA7L,EAAAwE,UAAAM,OAAA,SAAAC,EAAAmM,GACA,IAAAP,EAAAU,EACAC,EAAAJ,EAUA,KAPAG,EAAAH,EAAAlX,MAAAoW,OACAO,EAAAF,GAAAzQ,EAAA0Q,EAAAW,EAAA,IAAAxS,EAAAqR,QAAAmB,EAAA,GACAtM,EAAAzC,IAAAqO,GACAO,IAAAzT,MAAA4T,EAAA,GAAA7X,SAIA6X,EAAAH,EAAAlX,MAAAqW,KACAM,IACAA,EAAAF,GAAAzQ,EAAA0Q,EAAAW,EAAA,IACAtM,EAAAzC,IAAAqO,IAGA5L,EAAAzC,IAAA,GAAAqO,EAAA9R,EAAA,SAAAwS,EAAA,IACAH,IAAAzT,MAAA4T,EAAA,GAAA7X,QASA,OANA0X,IAAAI,GAGAvM,EAAAzC,IAAAgP,GAGAvM,GACE,IAAA5I,KAEF6D,EAAA+D,aAAA,QAAAxC,MAAAC,KAAAqK,GAAA9F,KAAA,MAnE+BwL,CAAAvR,EAAA0Q,EAAA7R,KAE/BkM,GAmJuByG,IA9BvB,SAAAzG,GAKA,OAJAA,EAAAtE,KAAA,SAAAzG,GACAtC,GAAAsC,EAAA,qBACAtC,GAAAsC,EAAA,mBAEA+K,GAyBuB0G,IATvB,SAAA1G,GAMA,OALAA,EAAAtE,KAAA,SAAAzG,GACA+Q,GAAApP,KAAA3B,EAAAX,MAAA,MAAAW,EAAA0D,SAAAlK,QAAAwG,EAAAnC,QACAmC,EAAA0F,gBAAA,YAGAqF,IAaA2G,GAAA,SAAA3G,EAAA2G,GAQA,OAPA5S,OAAAwC,KAAAoQ,OAA4BxQ,QAAA,SAAAZ,GAC5B,GAAAA,KAAA0Q,GAAA,CACA,IAAAW,EAAA,iBAAAD,EAAApR,GAAAoR,EAAApR,GAAA,KACAyK,IAAAlE,IAAAmK,GAAA1Q,GAAAqR,MAIA5G,GASA6G,GAAA,SAAA7G,EAAAuE,EAAAuC,GAQA,MAPA,iBAAAvC,EACAA,MACKA,GAAA,iBAAAA,IAAA/N,MAAAa,QAAAkN,KACLuC,EAAAvC,EACAA,EAAA,MAGAvE,EACAlE,IAAA0G,IACA1G,IAAAqI,GAAA3N,MAAAa,QAAAkN,KAAA9V,OAAA,MACAqN,IAAAqH,IACArH,IAAAwI,GAAAC,GACAzI,IAAA6K,GAAAG,IAWA,SAAAC,GAAA/G,EAAAgH,GAGA,OAFAA,QACAhH,EAAAtE,KAAA,SAAAzG,GAA+B,OAI/B,SAAAA,EAAA+R,GAIA,IAFA,IAAA5K,EAAAnH,EAAAuD,WAEA9B,EAAA,EAAAC,EAAAyF,EAAA3N,OAAsCiI,EAAAC,EAAQD,IAAA,CAC9C,IAAAhC,EAAA0H,EAAA1F,GACA,iBAAAhC,EAAA5B,OACAmC,EAAA+D,aAAAtE,EAAAJ,KAAA2S,GAAAvS,EAAA5B,MAAAkU,IAIA,MAAA/R,EAAAnC,QACAmC,EAAAnC,MAAAmU,GAAAhS,EAAAnC,MAAAkU,IAGA,OAAA/R,EAnB+BiS,CAAAjS,EAAA+R,KAC/BhH,EA4BA,SAAAiH,GAAA3Y,EAAA0Y,GAKA,IAJA,IAAAG,EAyBA,SAAA7Y,GACA,IASAgY,EATAc,EAAA,yBAEAJ,KAMAK,EAAA,IAAA7V,IAEA,KAAA8U,EAAAc,EAAAE,KAAAhZ,IACA+Y,EAAA5V,IAAA6U,EAAAlR,MAAAkR,GAGA,GAAAe,EAAA1E,KAAA,CAGA,IAFA,IAAAvT,EAAA,EAAAZ,EAAA,EAAAqU,EAAAvU,EAAAG,OACAsG,EAAA,GACAvG,EAAAqU,GACA,GAjBA,KAiBAvU,EAAAQ,WAAAN,IAAA6Y,EAAA9U,IAAA/D,EAAA,IAGA,IAAAsM,EAAAuM,EAAA/U,IAAA9D,EAAA,GACAuG,GAAAzG,EAAAoE,MAAAtD,EAAAZ,GAAAsM,EAAA,GACA1L,EAAAZ,EAAAsM,EAAA1F,MAAA0F,EAAA,GAAArM,OACA4Y,EAAA1G,OAAAnS,EAAA,QAIAA,IAGAF,EAAAyG,EAAAzG,EAAAoE,MAAAtD,GAIA,IADA,IAAAmY,EAAA/Q,MAAAC,KAAA4Q,EAAAtQ,UACAL,EAAA,EAAAC,EAAA4Q,EAAA9Y,OAAiDiI,EAAAC,EAAQD,IAAA,CACzD,IAAA8Q,EAAAD,EAAA7Q,GACAsQ,EAAA7U,MACAmC,KAAAkT,EAAA,GACA5U,SAAA4U,EAAApS,MACA3G,OAAA+Y,EAAA,GAAA/Y,UAKA,OAAYH,SAAA0Y,aAvEZS,CAAAnZ,GACAO,EAAA,EACAkG,EAAA,GAEA2B,EAAA,EAAAC,EAAAwQ,EAAAH,UAAAvY,OAAgDiI,EAAAC,EAAQD,IAAA,CACxD,IAAAgR,EAAAP,EAAAH,UAAAtQ,GACA5D,EAAA4U,EAAApT,QAAA0S,IAAAU,EAAApT,MAAAoT,EAAApT,KACA,mBAAAxB,IACAA,IAAAqU,EAAA7Y,OAAAoZ,EAAA7Y,EAAA6Y,EAAA9U,WAGAmC,GAAAoS,EAAA7Y,OAAAoE,MAAA7D,EAAA6Y,EAAA9U,UAAAE,EACAjE,EAAA6Y,EAAA9U,SAAA8U,EAAAjZ,OAGA,OAAAsG,EAAAoS,EAAA7Y,OAAAoE,MAAA7D,GA2DA,IAAA8Y,GAAA,GACAC,GAAA,GACAC,GAAA,GACAC,GAAA,IACAC,GAAA,IAQA,SAAAC,GAAA1Z,GAMA,IALA,IAGAqC,EAAAwE,EAHApF,EAAA,IAAAyM,EAAAlO,GACA2Z,KACAC,EAAA,GAAArZ,EAAA,EAAAL,EAAA,GAGAuB,EAAA2M,OACA/L,EAAAZ,EAAAnB,OACAJ,EAAAuB,EAAAvB,IAEAmC,IAAAkX,IACA9X,EAAA8I,OACA9I,EAAA8I,SACG1D,EAAAgT,GAAApY,EAAAmY,EAAAzZ,OAAAD,EAAAK,KACHoZ,EAAA9V,KAAAgD,GACA+S,GAAAnY,EAAAzB,OAAAoE,MAAA7D,EAAAL,GAAA2G,EAAAE,YACAxG,EAAAkB,EAAAvB,KAEAuB,EAAA8I,OAIA,WAAAuP,GAAAF,EAAAnY,EAAAzB,OAAAoE,MAAA7D,GAAAoZ,GA2CA,SAAAI,GAAAjT,EAAAC,GACA,OAAAA,EAAA,KAA0BD,EAAA,IAAAC,EAAA,IAAkC,KAASD,EAAA,IAWrE,SAAA+S,GAAApY,EAAA6C,GACA,IAAAxD,EAAAW,EAAAvB,IAEA,GAAAuB,EAAAf,IAAA2Y,IAAA,CAEA,IAAAvS,EAAAkT,GAAAvY,GACAsF,EAAA,GAGA,SAAAD,EACA,WAAAmT,GAAAnT,EAAAC,EAAAzC,GAGA,GAAA7C,EAAAf,IAAA8Y,KAEA,OADA1S,EAAAkT,GAAAvY,MAEAA,EAAAf,IAAA4Y,MACAvS,EAoBA,SAAAtF,GACA,IAAAY,EACAuB,KACAnC,EAAAX,MAAAW,EAAAvB,IAEA,MAAAuB,EAAA2M,OAAA,CAGA,IAFA/L,EAAAZ,EAAAnB,UAEAkZ,GACA5V,EAAAC,KAAApC,EAAAvB,UACG,GAAAmC,IAAAoX,GAAA,CACH,IAAA7V,EAAAzD,OACA,MAEAyD,EAAAG,MAEAtC,EAAA8I,OAGA,GAAA3G,EAAAzD,OACA,MAAAsB,EAAAkN,MAAA,kDAAgD/K,EAAAG,OAGhD,OAAAtC,EAAAgN,UA3CAyL,CAAAzY,IAGAA,EAAAf,IAAA+Y,KACA,WAAAQ,GAAAnT,EAAAC,EAAAzC,GAQA7C,EAAAvB,IAAAY,EAuCA,SAAAkZ,GAAAvY,GAEA,GADAA,EAAAX,MAAAW,EAAAvB,IACAuB,EAAAZ,SAAAyO,GACA,OAAA6K,OAAA1Y,EAAAgN,WAIA,IAAAwL,GAAA,SAAAnT,EAAAC,EAAAzC,GACArE,KAAA6G,QACA7G,KAAA8G,cACA9G,KAAAqE,WACArE,KAAAE,OAAAF,KAAA8G,YAAA5G,QAGA2Z,GAAA,SAAA9Z,EAAA2Z,GACA1Z,KAAAD,SACAC,KAAA0Z,UAGAG,GAAA1Z,UAAAga,KAAA,SAAA5N,GACA,OA/HA,SAAAxM,EAAA2Z,EAAAnN,GACAA,KAAAuN,GAIA,IAKAxZ,EAAA,EAQA,OAbAoZ,EACA3W,IAAA,SAAA6D,EAAAwT,GAA+B,OAAUA,QAAAxT,QAAAsH,IAAAtH,EAAAvC,SAAAuC,EAAA1G,UACzCkJ,KAAA,SAAAC,EAAAC,GAAwB,OAAAD,EAAA6E,IAAA5E,EAAA4E,KAAA7E,EAAA+Q,MAAA9Q,EAAA8Q,QAIxBrX,IAAA,SAAAkG,GACA,IAAAnC,EAAA/G,EAAA2U,OAAAzL,EAAArC,MAAAvC,SAAA4E,EAAArC,MAAA1G,QACAmX,EAAAtX,EAAAoE,MAAA7D,EAAA2I,EAAArC,MAAAvC,UAEA,OADA/D,EAAA2I,EAAAiF,IACAmJ,EAAA9K,EAAAtD,EAAArC,MAAAC,MAAAC,KAGA2F,KAAA,IAAA1M,EAAAoE,MAAA7D,GA6GA6Z,CAAAna,KAAAD,OAAAC,KAAA0Z,OAAAnN,IAGAsN,GAAA1Z,UAAAyN,SAAA,WACA,OAAA7N,QAGA,IAAAsa,GAAA,SAAAC,GAA6C,OAAAA,GAY7CC,GAAA,SAAA7T,EAAA8T,EAAAjV,GACA,iBAAAiV,IACAjV,EAAAiV,EACAA,EAAA,MAGAxa,KAAA0G,OACA1G,KAAAya,gBAAAD,GAAAH,GAEAra,KAAA6P,KAAA,KACA7P,KAAA0a,WAAA,GACA1a,KAAA2a,UAAA,GAEA3a,KAAA8P,MAAA,KACA9P,KAAA4a,YAAA,GACA5a,KAAA6a,WAAA,GAEA7a,KAAAsa,KAAA,KACAta,KAAA8a,WAAA,GACA9a,KAAA+a,UAAA,GAEA/a,KAAA0E,OAAA,GACA1E,KAAAgb,QAAA,GAEAzV,GACAC,OAAAC,OAAAzF,KAAAuF,IAIAgV,GAAApa,UAAA2J,MAAA,WACA,WAAA9J,KAAAqO,YAAArO,KAAA0G,KAAA1G,OAOAua,GAAApa,UAAA8a,WAAA,SAAAX,GACA,IAAA3S,EAAA3H,KAEAkb,EAgDA,SAAAZ,GACA,OAAAA,GAAA,IAAAxX,MAAA,eAjDAqY,CAAAb,GACA,OAAAY,EAAAhb,OAEA,OAAAoa,EAKA,IAAAc,EAAApb,KAAAgb,SAAAhb,KAAA0E,OAAA1E,KAAAgb,QAAA,IACA,OAAAE,EAAAnY,IAAA,SAAAK,EAAA+E,GAA6C,OAAAA,EAAAR,EAAAjD,OAAAtB,MAA0CqJ,KAAA2O,IAQvFb,GAAApa,UAAAkb,aAAA,SAAAf,GACA,OAAAta,KAAAya,gBAAAH,IAGAC,GAAApa,UAAAyN,SAAA,SAAAxD,GACA,IAAAyF,EAAA7P,KAAAsb,MAAAtb,KAAA6P,KAAA7P,KAAA0a,WAAA1a,KAAA2a,WACA7K,EAAA9P,KAAAsb,MAAAtb,KAAA8P,MAAA9P,KAAA4a,YAAA5a,KAAA6a,YAGA,OAAAhL,EAFA7P,KAAAsb,MAAAtb,KAAAsa,KAAAta,KAAA8a,WAAA9a,KAAA+a,YAEA,MAAA3Q,IAAA,IAAA0F,GAGAyK,GAAApa,UAAAmb,MAAA,SAAAtV,EAAA6K,EAAAC,GAKA,OAJAD,EAAA,MAAAA,IAAA,GACAC,EAAA,MAAAA,IAAA,GAGA,MAAA9K,GACAA,EAAA6K,EAAA7K,EAAA5B,QAAA,WAAA4B,EACAA,EAAA8K,EAAA9K,EAAA5B,QAAA,WAAA4B,EACA6K,EAAA7Q,KAAAib,WAAAjV,GAAA8K,GAGA,IAkBA,IAAAyK,GAAA,SAAA1U,EAAAC,GAAkD,OAAAA,GAAA,IAiBlD,SAAA0U,GAAA/J,EAAA7K,EAAA6U,QACA,IAAAA,IACAA,EAAA7U,EACAA,EAAA,MAGAA,KAAA2U,GAOA,IAAAG,GAAmB7U,MAAA,GAMnB,OAGA,SAAA8U,EAAAC,EAAAH,EAAAjB,GACA,OAAAoB,EAAArS,OAAAsS,IAAA9Y,IAAA,SAAA2D,GACA,IAAAoV,EAAAL,EAAA,IAAAlB,GAAA7T,EAAA8T,IACA,OAAAsB,IAAAlO,SAAA+N,EAAAjV,EAAA0D,SAAAqR,EAAAjB,IAAA,KACE/N,KAAA,IAPFkP,CAAAlK,EAAArH,SAAAqR,EAJA,SAAAnB,GAA0C,aAAAA,EAC1C1T,EAAA8U,EAAA7U,SAwBA,SAAAyT,EAAAoB,GACA,IAAA9C,EAAA,iBAAA0B,IAAAb,GAAAa,GACAyB,GAAA,EAaA,OAXAnD,EAAAc,OAAA9R,QAAA,SAAAhB,GACAA,EAAAC,OAAA6U,EAAA7U,MACAD,EAAAC,MAAAkV,IACAA,EAAAnV,EAAAC,UAIA,IAAAkV,IACAL,EAAA7U,MAAAkV,EAAA,GAGAnD,EAtCAoD,CAAA1B,EAAAoB,GAAAvB,KAAAvT,KAYA,SAAAiV,GAAAnV,GACA,OAAAA,EAAAkE,QA4BA,IAAAqR,GAAA,wBACAC,GAAA,GACAC,GAAA,GAgBA,SAAAC,GAAApW,EAAAkB,GACA,SAAAlB,EACA,OAAAA,EAYA,IAPA,IAKA5D,EAAAia,EALA1Y,KACA2Y,EAAA,SAAAtW,EAAAuW,EAAAhQ,EAAAiQ,GAAoD,aAAAtV,EAAAqF,GAAAgQ,EAAArV,EAAAqF,GAAAiQ,EAAA,IAEpDhW,EAAA,GACAlG,EAAA,EAAA6H,EAAA,EAGAA,EAAAnC,EAAA9F,SACAkC,EAAA4D,EAAAzF,WAAA4H,MACA+T,GACAvY,EAAAC,KAAAuE,GACG/F,IAAA+Z,KACHE,EAAA1Y,EAAAG,MACAH,EAAAzD,SACAsG,GAAAR,EAAA7B,MAAA7D,EAAA+b,GACArW,EAAA7B,MAAAkY,EAAA,EAAAlU,GAAA/D,QAAA6X,GAAAK,GACAhc,EAAA6H,EAAA,IAIAA,IAGA,OAAA3B,EAAAR,EAAA7B,MAAA7D,GAYA,SAAAmc,GAAAnC,GACA,OAAAA,GAAA,IAAAxX,MAAA,eAQA,SAAA4Z,GAAAhW,GACA,OAAAA,EAAA2D,OAAAQ,aAAAnE,EAeA,SAAAiW,GAAAjW,GACA,OAAAA,MAAA2D,OASA,SAAAuS,GAAAlW,GACA,OAAAA,EAAAC,cAAAD,EAAA0D,SAAAlK,OAeA,SAAA2c,GAAAf,GACA,IAAApV,EAAAoV,EAAApV,KAEA,GAAAkW,GAAAlW,GAAA,CACA,IAAAoW,EAAArD,GAAA/S,EAAAnC,OACAqC,EAAAkW,EAqBApD,OAAAlO,OAAA,SAAA7B,EAAA/C,GAAsD,OAAA+C,GAAA/C,EAAAC,MAAA8C,EAAA9C,MAAAD,EAAA+C,GACtD,MArBA,GAAA/C,EAAA,CACA,IAAAmW,EA6BA,SAAAnE,EAAAhS,GACA,IAAAsF,EAAA0M,EAAAc,OAAAlV,QAAAoC,GAEA2V,EAAA,IAAA3D,EAAAvK,YACAuK,EAAA7Y,OAAAoE,MAAA,EAAAyC,EAAAvC,UACAuU,EAAAc,OAAAvV,MAAA,EAAA+H,IAGAsQ,EAAA,IAAA5D,EAAAvK,YACAuK,EAAA7Y,OAAAoE,MAAAyC,EAAAvC,SAAAuC,EAAA1G,QACA0Y,EAAAc,OAAAvV,MAAA+H,EAAA,IAGA,OAAAqQ,EAAAC,GA1CAQ,CAAAF,EAAAlW,GACAkV,EAAAjM,KAAAiM,EAAAT,aAAA0B,EAAA,IACAjB,EAAAhM,MAAAgM,EAAAT,aAAA0B,EAAA,SAEAjB,EAAAxB,KAAAwB,EAAAT,aAAAyB,GAGA,SAGA,SAmCA,IAAAG,IAEAC,SAAA,EAIAC,SAAA,cAGAtM,OAAA,GAGAC,MAAA,mCAmFA,SAAAsM,GAAA1W,EAAA2W,GACA,QAAAA,EAAAtZ,IAAA,cAIA2C,EAAA2D,OAAA1D,YACA,IAAAD,EAAA2D,OAAAD,SAAAlK,SACAuZ,GAAA/S,EAAA2D,OAAA9F,OAAAmV,OAAAxZ,WAMAuG,GAAAC,EAAA2W,IAUA,SAAA3W,EAAA2W,GACA,IAAA5W,GAAAC,EAAA2W,GACA,SAGA,GAAAT,GAAAlW,GACA,SAIA,OAAAA,EAAAqE,YAGA,IADA,IAAAT,EAAA5D,EACA4D,IAAAU,aACA,IAAAvE,GAAA6D,EAAA+S,GACA,cAGK,IAAA5W,GAAAC,EAAAuE,gBAAAoS,GAEL,SAGA,GAAAA,EAAAtZ,IAAA,gBAKA,IAHA,IAAAuZ,EAAA,EACAzM,EAAAnK,EAAAoK,EAAApK,EAEA6W,GAAA1M,IAAA5F,gBAAAoS,IACAC,IAGA,KAAAC,GAAAzM,IAAA9F,YAAAqS,IACAC,IAGA,GAAAA,GAAAD,EAAAtZ,IAAA,eACA,SAKA,QAAAoE,EAAA,EAAAC,EAAA1B,EAAA0D,SAAAlK,OAA2CiI,EAAAC,EAAQD,IACnD,GAAAiV,GAAA1W,EAAA0D,SAAAjC,GAAAkV,GACA,SAIA,SA1DAG,CAAA9W,EAAA2W,KA8HA,SAAA5W,GAAAC,EAAA2W,GACA,OAAA3W,KAAAC,YAAA4W,GAAA7W,EAAA2W,GAUA,SAAAE,GAAA7W,EAAA2W,GACA,OAAA3W,GAAA2W,EAAA5W,SAAAC,GA8DA,IAAA+W,GAAA,QACAC,GAAA,WACAC,IACAC,QAAA,SAAA/P,GAA4B,OAAAA,EAAApB,KAAA,KAC5BoR,UAAA,SAAAhQ,GAA8B,OAAAA,EAAA9K,IAAA,SAAAoD,GAAmC,OAAAA,EAAA2X,UAAA3X,EAAAJ,KAAAI,EAAA,SAAAA,EAAA,QAA0EsG,KAAA,QAG3IsR,IACAlO,KAAA,KACAC,MAAA,KACAkO,SAAA,SACA/T,WAAA0T,IAGA,SAAAM,GAAAnC,EAAAuB,EAAA9X,GACAA,EAAAC,OAAAC,UAA2BsY,GAAAxY,GAC3B,IAAAmB,EAAAoV,EAAApV,KAUA,GARAoV,EAAApX,OAAA2Y,EAAA3Y,OA4EA,SAAAgC,EAAA2W,GACA,IAAA9W,EAAAG,EAAA2D,OAAA1D,YAAA,KACA2G,EAAA5G,EACA,KAAA4G,IAAAjD,QACA9D,IAGA,OAAAA,EAAA,IAAAA,EAnFA2X,CAAAxX,IACAoV,EAAAd,QAAA,KAGA2B,GAAAjW,EAAA2D,SAAAqS,GAAAhW,KACAoV,EAAApB,WAAAoB,EAAAd,QAAAc,EAAApX,QAGAgC,EAAAX,KAAA,CACA,IAAAmB,EAAA1B,OAAAC,QACA0Y,KAAAd,EAAAtX,KAAAW,EAAAX,MACAqY,WAAA1X,EAAAyD,YAAA5E,EAAAe,UAAA,MA2BA,SAAAwV,EAAAuB,EAAA9X,GACAA,EAAAC,OAAAC,UAA2BkY,GAAApY,GAC3B,IAAAqY,KAAAC,KAuBA,OAtBA/B,EAAApV,KAEAuD,WAAArC,QAAA,SAAAzB,GACA,GAAAA,EAAAZ,QAAAwI,SAAA,MAAA5H,EAAA5B,MACA,YAGA,IAAAwB,EAAAsX,EAAAnX,UAAAC,EAAAJ,MACAxB,EAAAuX,EAAAT,aAAAlV,EAAA5B,OAEA,GAAAkZ,GAAApV,KAAAtC,GACAxB,GAAAqZ,EAAAha,KAAA,IAAAW,QACG,GAAAmZ,GAAArV,KAAAtC,GACHxB,GAAAqZ,EAAAha,KAAA,IAAAW,EAAAH,QAAA,iBACG,CACH,IAAA0Z,EAAA,MAAA3X,EAAA5B,QACA4B,EAAAZ,QAAAc,UAAA,IAAAgX,EAAAtZ,IAAA,qBAAAS,QAAAuB,EAAAD,gBAEA+X,EAAAja,MAAmBmC,OAAAxB,QAAAuZ,kBAKnBO,cAAA9Y,EAAAqY,YAAA,KACAU,gBAAA/Y,EAAAsY,cAAA,MArDGU,CAAAzC,EAAAuB,EAAA9X,EAAA0E,aAGH1E,EAAAyY,UAAAzY,EAAAyY,SAAA3V,KAAAnB,EAAAiX,OAAAjX,EAAAmX,gBACAnX,EAAAiX,KAAA,MAGA,MAAA5Y,EAAAsK,OACAiM,EAAAjM,KAAAuM,GAAA7W,EAAAsK,KAAA3I,IAGA,MAAA3B,EAAAuK,QACAgM,EAAAhM,MAAAsM,GAAA7W,EAAAuK,MAAA5I,IAIA,OAAA4U,EA0DA,IAAA0C,GAAA,QA0FA,IAAAC,GAAA,QACAC,IACAC,KAAA,qBACAC,MAAA,sBACAC,MAAA,sBACAC,OAAA,sBA2GA,IAAAC,GAAA,QA2EA,IAAAC,IAAyBC,KA1pBzB,SAAAxN,EAAA4L,EAAA9X,GAIA,OAHAA,EAAAC,OAAAC,UAA2BF,IAC3B2Z,QAAA1Z,OAAAC,UAAmCwX,GAAA1X,EAAA2Z,SAEnC1D,GAAA/J,EAAAlM,EAAAqB,MAAA,SAAAkV,GAGA,IAAAe,GAFAf,EAkCA,SAAAA,EAAAuB,GACA,IAAA3W,EAAAoV,EAAApV,KAEA,GAAA0W,GAAA1W,EAAA2W,GAAA,CACAvB,EAAApX,OAAA2Y,EAAA3Y,OA8LA,SAAAgC,EAAA2W,GAOA,IAHA,IAAA8B,EAAA9B,EAAAtZ,IAAA,kBACAwC,EAAAG,EAAA2D,OAAA1D,YAAA,KACA2G,EAAA5G,EACA4G,IAAAjD,SACA,IAAA8U,EAAA3a,SAAA8I,EAAAvH,MAAA,IAAAD,gBACAS,IAIA,OAAAA,EAAA,IAAAA,EA3MA6Y,CAAA1Y,EAAA2W,IACAvB,EAAAd,QAAA,KACA,IAAA3D,EAAAyE,EAAAd,QAAAc,EAAApX,OAGAiY,GAAAjW,EAAA2D,SAAAqS,GAAAhW,KACAoV,EAAApB,WAAArD,EACA3Q,EAAAC,aACAmV,EAAAhB,WAAAzD,IAsGA,SAAA3Q,EAAA2W,GAEA,IAAAgC,GAAA3Y,EAAAX,MAAA,IAAAD,cACA,QAAAuX,EAAAtZ,IAAA,eAAAS,QAAA6a,GACA,SAKA,QAAAlX,EAAA,EAAmBA,EAAAzB,EAAA0D,SAAAlK,OAA0BiI,IAC7C,GAAAiV,GAAA1W,EAAA0D,SAAAjC,GAAAkV,GACA,SAIA,SAjHAiC,CAAA5Y,EAAA2W,KACA3W,EAAAC,aACAmV,EAAAhB,WAAAzD,EAAAgG,EAAA3Y,OAAA,IAEAoX,EAAAlB,YAAAvD,GAIA,OAAAyE,EA1DAyD,CAAAzD,EAAAuB,IAEA,CACA,IAAA3W,EAAAoV,EAAApV,KAEA,GAAAA,EAAAX,KAAA,CACA,IAAAA,EAAAsX,EAAAtX,KAAAW,EAAAX,MACA8H,EAqKA,SAAAiO,EAAAuB,GAGA,OAFAvB,EAAApV,KAEAuD,WAAAlH,IAAA,SAAAoD,GACA,GAAAA,EAAAZ,QAAAwI,SAAA,MAAA5H,EAAA5B,MACA,YAGA,IAAAib,EAAAnC,EAAAnX,UAAAC,EAAAJ,MACA0Z,EAAA,KAGA,GAAAtZ,EAAAZ,QAAAc,UAAA,IAAAgX,EAAAtZ,IAAA,qBAAAS,QAAAgb,EAAA1Z,eAAA,CACA,GAAAuX,EAAAtZ,IAAA,mCAAAoC,EAAA5B,MACA,UAAAib,EACO,MAAArZ,EAAA5B,QACPkb,EAAAD,GAQA,OAJA,MAAAC,IACAA,EAAA3D,EAAAT,aAAAlV,EAAA5B,QAGA,IAAAib,EAAA,IAAAnC,EAAAxb,MAAA4d,KACKhT,KAAA,IA9LLiT,CAAA5D,EAAAuB,GAEAvB,EAAAjM,KAAA,IAAA9J,EAAA8H,GAAAnH,EAAAyD,YAAAkT,EAAA/W,YAAA,QACAI,EAAAyD,cACA2R,EAAAhM,MAAA,KAAA/J,EAAA,KA8OA,SAAA+V,EAAAvW,GACA,IAAAmB,EAAAoV,EAAApV,KAEA,GAAAnB,EAAA2X,SAAA3X,EAAA4X,SAAAzW,EAAAX,KAaA,IATA,IAAA8H,EAAAiO,EAAApV,KAAAuD,WAAAuB,OAAA,SAAAC,EAAAtF,GAKA,OAJAA,EAAAJ,MAAA,MAAAI,EAAA5B,QACAkH,EAAAtF,EAAAJ,KAAAF,cAAAzB,QAAA,WAAA+B,EAAA5B,OAGAkH,OAIAtD,EAAA,EAAAC,EAAA7C,EAAA4X,QAAAjd,OAA6CiI,EAAAC,EAAQD,IACrD,GAAA5C,EAAA4X,QAAAhV,GAAAtC,gBAAAgI,EAAA,CACAiO,EAAAjM,KAAAuM,GAAA7W,EAAAsL,OAAAhD,GAAAiO,EAAAjM,KACAiM,EAAAhM,QACAgM,EAAAhM,OAAAsM,GAAA7W,EAAAuL,MAAAjD,IAEA,OAjQA8R,CAAA7D,EAAAvW,EAAA2Z,UAKAxY,EAAAnC,QAAAmC,EAAA0D,SAAAlK,SAAAwG,EAAAyD,eACA2R,EAAAxB,KAAAwB,EAAAT,aAAA3U,EAAAnC,QAIA,OAAAuX,KA6nByB8D,KA3QzB,SAAAnO,EAAA4L,EAAA9X,GAEA,IAAAsa,GACAhQ,KAAA,wDACAvJ,UAAA,IACA2D,YACA4T,UAAA,SAAAhQ,GACA,OAAAA,EAAA9K,IAAA,SAAAoD,GAAsC,OAAAA,EAAA2X,UACtC3X,EAAA,MAAAkX,EAAAtZ,IAAA,wCACAoC,EAAA,SAAAkX,EAAAxb,MAAAsE,EAAA5B,SACAkI,KAAA,QAKA,OAAA+O,GAAA/J,GAdAlM,SAcAqB,MAAA,SAAAkV,GAIA,IAAAe,GAFAf,EAwBA,SAAAA,EAAAuB,GACA,IAAA3W,EAAAoV,EAAApV,KASA,OAPAA,EAAAC,YAAAD,EAAAnC,QAEAuX,EAAAhB,WAAA0D,GAAAnW,KAAA3B,EAAAnC,OACAuX,EAAAd,QAAAc,EAAApX,OAAA2Y,EAAA3Y,OAAA,GACA,KAGAoX,EAlCAgE,CADAhE,EAAAmC,GAAAnC,EAAAuB,EAAAwC,GACAxC,IAEA,CACA,IAAA3W,EAAAoV,EAAApV,MAIAA,EAAAnC,QAAAmC,EAAA0D,SAAAlK,SAAAwG,EAAAyD,eACA2R,EAAAxB,KAAAwB,EAAAT,aAmCA,SAAA3U,EAAA2W,GACA,SAAA3W,EAAAnC,OAAAia,GAAAnW,KAAA3B,EAAAnC,OAAA,CACA,IAAA2W,EAAAuB,GAAA/V,EAAAnC,OACAG,EAAA2Y,EAAA3Y,OAAA,GACAqb,EAAA7E,EAAA1P,OAAA,SAAAhL,EAAA4C,GAAsD,OAAAE,KAAAE,IAAAhD,EAAA4C,EAAAlD,SAAsC,GAE5F,OAAAgb,EAAAnY,IAAA,SAAAK,EAAA+E,GAAuC,UAAAA,EAAAzD,EAAA,IAMvC,SAAA4V,EAAAhG,GACA,KAAAgG,EAAApa,OAAAoU,GACAgG,GAAA,IAGA,OAAAA,EAXuC,CAAAlX,EAAA2c,GAAA,OAAmEtT,KAAA,MAG1G,OAAA/F,EAAAnC,MA5CAyb,CAAAtZ,EAAA2W,KAIA,OAAAvB,KA8OyBmE,KA3KzB,SAAAxO,EAAA4L,EAAA9X,GAEA,IAAA+Y,GADA/Y,SACA2a,eACAxB,GAAAnZ,EAAA2a,gBACAxB,GAAAC,KAEAwB,EAAA7B,IAAAI,GAAAC,KACA,SAAAxY,GAAqB,OAAAA,EAAA,cACrB,SAAAA,GAAqB,OAAAA,EAAAJ,MAErB8Z,GACAhQ,KAAA,wBAAAyO,EAAA,eACAhY,UAAA,IACA2D,YACA4T,UAAA,SAAAhQ,GACA,OAAAA,EAAA9K,IAAA,SAAAoD,GAAsC,OAAAA,EAAA2X,UACtCqC,EAAAha,GACAA,EAAA,SAAAkX,EAAAxb,MAAAsE,EAAA5B,SACAkI,KAAA,QAKA,OAAA+O,GAAA/J,EAAAlM,EAAAqB,MAAA,SAAAkV,EAAAT,GAIA,IAAAwB,GAFAf,EAwBA,SAAAA,EAAAuB,GACA,IAAA3W,EAAAoV,EAAApV,KACA2D,EAAA3D,EAAA2D,OAgBA,OAZA,IAAAgT,EAAAtZ,IAAA,gBAqCA,SAAA2C,EAAA2W,GACA,OAAA3W,MAAAC,YAAA0W,EAAA5W,SAAAC,IAtCA0Z,CAAA1Z,EAAA2W,KACAV,GAAAtS,IAAA,MAAAA,EAAA9F,OAAA,IAAA8F,EAAAD,SAAAlK,SACA4b,EAAApB,WAAA,OAGAhU,EAAAC,YAAAD,EAAAnC,QAEAuX,EAAAhB,WAAA2D,GAAApW,KAAA3B,EAAAnC,OACAuX,EAAAd,QAAAc,EAAApX,OAAA2Y,EAAA3Y,OAAA,GACA,KAGAoX,EA1CAuE,CADAvE,EAAAmC,GAAAnC,EAAAuB,EAAAwC,GACAxC,IAEA,CACA,IAAA3W,EAAAoV,EAAApV,MAIAA,EAAAnC,QAAAmC,EAAA0D,SAAAlK,SAAAwG,EAAAyD,eACA2R,EAAAxB,KAAAwB,EAAAT,aA4CA,SAAA3U,EAAA2W,GACA,SAAA3W,EAAAnC,OAAAka,GAAApW,KAAA3B,EAAAnC,OAAA,CACA,IAAAG,EAAA2Y,EAAA3Y,OAAA,GACA,OAAA+X,GAAA/V,EAAAnC,OAAAxB,IAAA,SAAAK,EAAA+E,GAA4D,OAAAzD,GAAAyD,EAAA,aAAA/E,IAAuDqJ,KAAA,MAGnH,OAAA/F,EAAAnC,MAlDA+b,CAAA5Z,EAAA2W,KAIA,OAAAvB,KAsIyByE,IAjEzB,SAAA9O,EAAA4L,EAAA9X,GAEA,IAAAsa,GACAhQ,KAAA,2CACA5F,YACA4T,UAAA,SAAAhQ,GACA,OAAAA,EAAA9K,IAAA,SAAAoD,GAAsC,OAAAA,EAAA2X,UAAA3X,EAAAJ,KAAAI,EAAA,SAAAkX,EAAAxb,MAAAsE,EAAA5B,SAAyFkI,KAAA,SAK/H,OAAA+O,GAAA/J,GAVAlM,SAUAqB,MAAA,SAAAkV,GAIA,IAAAe,GAFAf,EAuBA,SAAAA,EAAAuB,GACA,IAAA3W,EAAAoV,EAAApV,KASA,OAPAA,EAAAC,YAAAD,EAAAnC,QAEAuX,EAAAhB,WAAAiE,GAAA1W,KAAA3B,EAAAnC,OACAuX,EAAAd,QAAAc,EAAApX,OAAA2Y,EAAA3Y,OAAA,GACA,KAGAoX,EAjCA0E,CADA1E,EAAAmC,GAAAnC,EAAAuB,EAAAwC,GACAxC,IAEA,CACA,IAAA3W,EAAAoV,EAAApV,MAGAA,EAAAnC,QAAAmC,EAAA0D,SAAAlK,SAAAwG,EAAAyD,eACA2R,EAAAxB,KAAAwB,EAAAT,aAoCA,SAAA3U,EAAA2W,GACA,SAAA3W,EAAAnC,OAAAwa,GAAA1W,KAAA3B,EAAAnC,OAAA,CACA,IAAAG,EAAA2Y,EAAA3Y,OAAA,GACA,OAAA+X,GAAA/V,EAAAnC,OAAAxB,IAAA,SAAAK,GAAyD,OAAAsB,EAAA,KAAAtB,IAAiCqJ,KAAA,MAG1F,OAAA/F,EAAAnC,MA1CAkc,CAAA/Z,EAAA2W,KAIA,OAAAvB,MA6DA4E,GAAA,SAAAjP,EAAA4L,EAAAsD,EAAApb,GAWA,MAVA,iBAAAob,IACApb,EAAAob,EACAA,EAAA,MAgBA,SAAAA,GACA,QAAAA,QAAA3B,GAdA4B,CAAAD,KAEAA,EAAA,QAGA3B,GAAA2B,GAAAlP,EAAA4L,EAAA9X,IAeA,IAAAsb,GAAA,WACA7gB,KAAA4F,KAAA,YACA5F,KAAAuE,UAGAuc,IAA4B1M,SAE5B0M,GAAA1M,KAAArQ,IAAA,WACA,OAAA/D,KAAAuE,MAAArE,QAGA2gB,GAAA1gB,UAAA6I,IAAA,SAAAzE,GACAvE,KAAAuE,MAAAX,KAAAW,IAGAsc,GAAA1gB,UAAA6D,IAAA,SAAAO,GACA,WAAAvE,KAAAuE,MAAAC,QAAAD,IAGAsc,GAAA1gB,UAAAyN,SAAA,WACA,OAAA5N,KAAAuE,MAAAkI,KAAA,MAGAjH,OAAAmD,iBAAAkY,GAAA1gB,UAAA2gB,IAEA,IAQAC,GAAA,SAAAvf,GAMA,GAdA,KAcAA,EAAAnB,OAAA,CACAmB,EAAAX,MAAAW,EAAAvB,IACAuB,EAAA8I,OAEA9I,EAAAf,IAAA,MAAAe,EAAAZ,SAAAogB,IACA,IAAAC,EAAAzf,EAAAgN,UAIA,GADAhN,EAAAX,MAAAW,EAAAvB,IACAuB,EAAAf,IAtBA,MAsBAe,EAAAZ,SAAAyO,GACA,MAAA7N,EAAAkN,MAAA,iDAGA,WAAAwS,GAAAD,EAAAzf,EAAAgN,aAIA0S,GAAA,SAAA3c,EAAA4c,GACAnhB,KAAA4F,KAAA,QACA5F,KAAAohB,IAAA7c,EACAvE,KAAAmhB,MAAAjH,OAAA,MAAAiH,GAAA,KAAAA,IAAA,GAGA,IAAA1M,EAAA,EAAA4M,EAAA,EAAA/X,EAAA,EAEA,UAJA/E,IAAAJ,MAAA,IAKAnE,KAAAmhB,MAAA,OAEA,OAAA5c,EAAArE,QACA,OACA,MAEA,OACAuU,EAAA4M,EAAA/X,EAAA/E,IACA,MAEA,OACAkQ,EAAA4M,EAAA/X,EAAA/E,EACA,MAEA,OACAkQ,EAAAlQ,EAAA,GAAAA,EAAA,GACA8c,EAAA9c,EAAA,GAAAA,EAAA,GACA+E,EAAA/E,EAAA,GAAAA,EAAA,GACA,MAEA,QAEAkQ,GADAlQ,MACAJ,MAAA,KACAkd,EAAA9c,EAAAJ,MAAA,KACAmF,EAAA/E,EAAAJ,MAAA,KAIAnE,KAAAyU,EAAA6M,SAAA7M,EAAA,IACAzU,KAAAqhB,EAAAC,SAAAD,EAAA,IACArhB,KAAAsJ,EAAAgY,SAAAhY,EAAA,KAwCA,SAAA0X,GAAA5e,GACA,OAAAiN,EAAAjN,IAAAkN,EAAAlN,EAAA,OAGA,SAAAmf,GAAAC,GACA,QAAAA,EAAA,IAGA,SAAAC,GAAAC,GACA,OAAAA,GAAA,GAAA9T,SAAA,IAGA,SAAA+T,GAAAD,GACA,OAGA,SAAAnd,EAAA+P,GACA,KAAA/P,EAAArE,OAAAoU,GACA/P,EAAA,IAAAA,EAEA,OAAAA,EAPAqd,CAAAF,EAAA9T,SAAA,OAcA,SAAAiU,GAAAzf,GACA,OAAAiN,EAAAjN,IAAA0f,GAAA1f,GAOA,SAAA0f,GAAA1f,GACA,YAAAA,GAAAkN,EAAAlN,GApEA8e,GAAA/gB,UAAAwhB,MAAA,SAAAI,GACA,IAAA3U,EAAA2U,GAAAR,GAAAvhB,KAAAyU,IAAA8M,GAAAvhB,KAAAqhB,IAAAE,GAAAvhB,KAAAsJ,GACAmY,GAAAE,GAEA,UAAAvU,EAAApN,KAAAyU,GAAArH,EAAApN,KAAAqhB,GAAAjU,EAAApN,KAAAsJ,IAOA4X,GAAA/gB,UAAA6hB,MAAA,WACA,IAAAxZ,GAAAxI,KAAAyU,EAAAzU,KAAAqhB,EAAArhB,KAAAsJ,GAKA,OAJA,IAAAtJ,KAAAmhB,OACA3Y,EAAA5E,KAAA5D,KAAAmhB,MAAAc,QAAA,GAAA7d,QAAA,eAGA,IAAAoE,EAAAtI,OAAA,kBAAAsI,EAAAiE,KAAA,WAGAyU,GAAA/gB,UAAAyN,SAAA,SAAAmU,GACA,OAAA/hB,KAAAyU,GAAAzU,KAAAqhB,GAAArhB,KAAAsJ,GAAAtJ,KAAAmhB,MAGA,IAAAnhB,KAAAmhB,MAAAnhB,KAAA2hB,MAAAI,GAAA/hB,KAAAgiB,QAFA,eAiDA,IACAE,GAAA,GACAC,GAAA,GAQAC,GAAA,SAAA5gB,GAEA,GADAA,EAAAX,MAAAW,EAAAvB,IA6BA,SAAAuB,GACA,IAEAY,EAFAvB,EAAAW,EAAAvB,IACAoiB,EAAA7gB,EAAAf,IAAA0hB,IACAG,GAAA,EAAAC,GAAA,EAEA,MAAA/gB,EAAA2M,SACA/L,EAAAZ,EAAAnB,UAGA6hB,IAAAI,EAAAjT,EAAAjN,KAIAmgB,GAAA,EAEAngB,IAAA8f,KACAI,GAAA,GAGA9gB,EAAA8I,OAGA+X,IAAAE,IAEA/gB,EAAAvB,IAAAY,GAGA,OAAAA,IAAAW,EAAAvB,IAvDAuiB,CAAAhhB,GAAA,CACA,IAAAkgB,EAAAlgB,EAAAgN,UAKA,OAJAhN,EAAAX,MAAAW,EAAAvB,IAGAuB,EAAAf,IAjBA,KAiBAe,EAAAZ,SAAAkhB,IACA,IAAAW,GAAAf,EAAAlgB,EAAAgN,aAOAiU,GAAA,SAAAle,EAAAme,GACA1iB,KAAA4F,KAAA,UACA5F,KAAAuE,MAAA2V,OAAA3V,GACAvE,KAAA0iB,QAAA,IAGAD,GAAAtiB,UAAAyN,SAAA,WACA,SAAA5N,KAAA,MAAAA,KAAA,MAsCA,IACA2iB,GAAA,GAaAC,GAAA,SAAAphB,EAAAugB,GAYA,OAXAvgB,EAAAX,MAAAW,EAAAvB,IAEAuB,EAAAf,IAjBA,KAiBAe,EAAAf,IAfA,IAiBAe,EAAAZ,SAAAiiB,IACEd,EACFvgB,EAAAZ,SAAAkhB,IAEAtgB,EAAAZ,SAAAkiB,IAGAthB,EAAAX,QAAAW,EAAAvB,IAAA,IAAA8iB,GAAAvhB,EAAAgN,WAAA,MAGAuU,GAAA,SAAAxe,GACAvE,KAAA4F,KAAA,UACA5F,KAAAuE,SAOA,SAAAue,GAAA1gB,GACA,OAAAyf,GAAAzf,QAAAugB,GAGA,SAAAE,GAAAzgB,GACA,YAAAA,GAAAyf,GAAAzf,GATA2gB,GAAA5iB,UAAAyN,SAAA,WACA,OAAA5N,KAAAuE,OAWA,IAAAye,IAAe9T,QAAA,GAOf+T,GAAA,SAAAzhB,GACA,GAAA2N,EAAA3N,EAAAwhB,IACA,WAAAE,GAAA1hB,EAAAgN,YAIA0U,GAAA,SAAA3e,GACAvE,KAAA4F,KAAA,SACA5F,KAAAuE,SAGA2e,GAAA/iB,UAAAyN,SAAA,WACA,OAAA5N,KAAAuE,OAGA,IAAA4e,GAAA,GACAC,GAAA,GACAC,GAAA,GASA,SAAAC,GAAA9hB,GACA,IAAAA,EAAAf,IAAA0iB,IAEA,YAMA,IAHA,IAAAI,EACAC,MAEAhiB,EAAA2M,OACA,GAAAoV,EAAAE,GAAAjiB,GACAgiB,EAAA5f,KAAA2f,OACG,CAIH,GAFA/hB,EAAAZ,SAAA6O,GAEAjO,EAAAf,IAAA2iB,IAEA,MAGA,IAAA5hB,EAAAf,IAAA4iB,IACA,MAAA7hB,EAAAkN,MAAA,mBAKA,OAAA8U,EASA,SAAAC,GAAAjiB,GAIA,IAHA,IACA+C,EADAoF,EAAA,IAAAkX,IAGArf,EAAA2M,QACA3M,EAAAZ,SAAA6O,GACAlL,EAAA6d,GAAA5gB,IAAAuf,GAAAvf,IACAyhB,GAAAzhB,IAAAkiB,GAAAliB,KAMAmI,EAAAX,IAAAzE,GAGA,OAAAoF,EAAAyK,KAAAzK,EAAA,KAQA,SAAA+Z,GAAAliB,GACA,IAAAmiB,EAAAf,GAAAphB,GACA,GAAAmiB,EAAA,CACA,IAAAjW,EAAA4V,GAAA9hB,GACA,OAAAkM,EAAA,IAAAkW,GAAAD,EAAA/V,WAAAF,GAAAiW,GAIA,IAAAC,GAAA,SAAA7d,EAAA2H,GACA1N,KAAA4F,KAAA,WACA5F,KAAA+F,OACA/F,KAAA0N,YAGAkW,GAAAzjB,UAAAyN,SAAA,WACA,OAAA5N,KAAA,SAAAA,KAAA0N,KAAAjB,KAAA,WAGA,IAAAoX,GAAA,GACAC,GAAA,GAEAC,GAAA,GACAC,GAAA,GACAC,GAAA,GAOAC,GAAA,SAAA1S,GAKA,IAJA,IAAAE,EAAA,IAAA1H,EACAxI,EAAA,IAAAyM,EAAAuD,IAGAhQ,EAAA2M,OAAA,CACA,IAAA2D,EAAA,IAAA9H,EAAAma,GAAA3iB,IACAsQ,EAAAvN,MAAA6f,GAAA5iB,GAEA,IAAAkM,EAAA4V,GAAA9hB,GACA,GAAAkM,EAIA,QAAAvF,EAAA,EAAkBA,EAAAuF,EAAAxN,OAAiBiI,IACnC2J,EAAArH,aAAAY,OAAAlD,GAAAuF,EAAAvF,IAYA,GAPA3G,EAAAf,IAAAojB,KACA/R,EAAAvN,MAAAyE,IAAA,KAGA0I,EAAA/E,YAAAmF,IAGAtQ,EAAAf,IArCA,IAsCA,MAIA,IAAAe,EAAA2M,MACA,MAAA3M,EAAAkN,MAAA,wBAGA,OAAAgD,GAQA,SAAAyS,GAAA3iB,GAIA,OAHAA,EAAAX,MAAAW,EAAAvB,IACAuB,EAAAZ,SAAAyjB,IACA7iB,EAAAZ,SAAA0jB,IACA9iB,EAAAX,QAAAW,EAAAvB,IAAAuB,EAAAgN,UAAA,KAQA,SAAA4V,GAAA5iB,GAIA,IAHA,IACA+C,EADAiE,EAAA,IAAAqY,IAGArf,EAAA2M,QAEA3M,EAAAf,IAAAujB,KACAzf,EAAA6d,GAAA5gB,IAAAuf,GAAAvf,IAGA+C,EAAAme,MACAlhB,EAAAf,IAAAsjB,KAGAviB,EAAAf,IAAAsjB,IACAxf,EAAAqe,GAAAphB,GAAA,IAGA+C,IAIAiE,EAAAQ,IAAAzE,GAGA,OAAAiE,EAOA,SAAA8b,GAAAliB,GACA,OAAA0f,GAAA1f,GAOA,SAAAiiB,GAAAjiB,GACA,OAAAA,IAAA6hB,IAAA7hB,IAAA0hB,IAAA1hB,IAAAyhB,GAGA,IASAU,GAAA,SAAA/S,EAAAzR,GACA,GAAAyR,IAAAzR,EACA,SAIA,IAAAA,GAAAyR,EAAAjR,WAAA,KAAAR,EAAAQ,WAAA,GACA,SAQA,IALA,IAGAikB,EAAAC,EAAAC,EAAAC,EAoCApW,EAvCAqW,EAAApT,EAAAtR,OACA2kB,EAAA9kB,EAAAG,OACAiI,EAAA,EAAA2c,EAAA,EAAAC,EAAAF,EAGA1c,EAAAyc,GAAA,CAKA,IAJAJ,EAAAhT,EAAAjR,WAAA4H,GACAuc,GAAA,EACAC,GAAA,EAEAG,EAAAD,GAAA,CAGA,GAAAL,KAFAC,EAAA1kB,EAAAQ,WAAAukB,IAEA,CACAJ,GAAA,EACAK,IAAAF,EAAAC,IAAAH,EAAA,KACA,MAIAA,EAvCA,KAuCAF,EACAK,IAGA,IAAAJ,EACA,MAGAvc,IAGA,OAAA4c,MAAA5c,EAAAyc,KAQArW,EARAsW,IASAtW,EAAA,OAGA,IAAAyW,GAAA,qCACAC,GAAA,GAaAC,GAAA,SAAAnc,GACA,OA2EA,SAAAA,GACAA,IAAAK,KAAA+b,IAMA,IALA,IAAAxhB,KAKAwE,EAAA,EAAAid,OAAA,EAAA5kB,OAAA,EAAoD2H,EAAAY,EAAA7I,OAAqBiI,IAGzE,IAFAid,EAAArc,EAAAZ,IAEAkd,SAAA,CAQA,KAAA1hB,EAAAzD,QAAA,CAGA,GAFAM,EAAAmD,IAAAzD,OAAA,GAEA,IAAAklB,EAAAC,SAAA7gB,QAAAhE,EAAA6kB,WACAD,EAAAC,SAAA9kB,WAAAC,EAAA6kB,SAAAnlB,UAAA+kB,GAAA,CACAzkB,EAAA8kB,cAAAF,GACAzhB,EAAAC,KAAAwhB,GACA,MAGAzhB,EAAAG,MAGAH,EAAAzD,QACAyD,EAAAC,KAAAwhB,GAIA,OAAArc,EA/GAwc,CAAAxc,EAAAhG,IAAA,SAAA0G,GAAkD,WAAA+b,GAAA/b,EAAAzC,IAAAyC,EAAAlF,WAGlDihB,GAAA,SAAAxe,EAAAzC,GACAvE,KAAAgH,MACAhH,KAAAuE,QACAvE,KAAAqlB,SAAA,KAGA,IAAAtN,EAAAxT,KAAA7D,MAAAskB,IACAjN,IACA/X,KAAAqlB,SAAAtN,EAAA,GACA/X,KAAAuE,MAAAwT,EAAA,IAGA/X,KAAAylB,iBAGAC,IAA4BC,gBAsG5B,SAAAR,GAAA9b,EAAAC,GACA,OAAAD,EAAArC,MAAAsC,EAAAtC,IACA,EAGAqC,EAAArC,IAAAsC,EAAAtC,KAAA,IAQA,SAAA4e,GAAA5f,GACA,oBAAAqC,KAAArC,GAGA,SAAA6f,GAAAthB,GACA,OAAA8G,OAAA9G,GAAAzB,MAAA,KAtHA0iB,GAAArlB,UAAAmlB,cAAA,SAAAQ,GACA9lB,KAAAylB,aAAA7hB,KAAAkiB,IAGAJ,GAAAC,YAAA5hB,IAAA,WACA,aAAA/D,KAAAuE,MAAAshB,GAAA7lB,KAAAuE,OAAA,SAOAihB,GAAArlB,UAAA4lB,SAAA,WACA,IAEA9c,EAAA+c,EAFAriB,KACAoiB,EAAA,IAAAljB,IACAsF,EAAA,EAOA,IALAnI,KAAAqlB,UAEA1hB,EAAAC,KAAA5D,MAGAmI,EAAAxE,EAAAzD,QAKA,IAFA+I,EAAAtF,EAAAwE,MAEA5D,MAAA,CACAyhB,EAAAH,GAAA5c,EAAA1E,OAAAgF,OAAAqc,IAGA,QAAAd,EAAA,EAA2BA,EAAAkB,EAAA9lB,OAAuB4kB,IAClDiB,EAAA/c,IAAAgd,EAAAlB,GAAAxZ,QAIA,QAAA2a,EAAA,EAAAC,EAAAjd,EAAAwc,aAAuDQ,EAAAC,EAAAhmB,OAAmB+lB,KAC1E,IAAAtiB,EAAAa,QAAA0hB,EAAAD,KACAtiB,EAAAC,KAAAsiB,EAAAD,IAMA,OAAAhe,MAAAC,KAAA6d,IAGAvgB,OAAAmD,iBAAA6c,GAAArlB,UAAAulB,IA0EA,IAAAS,IAAA,0BACAC,IACA,uDACA,kCAEAC,IACAC,EAAA,KACArT,EAAA,IACAsT,EAAA,KACA9R,EAAA,OAWA+R,GAAA,SAAA/U,EAAAU,GACA,IAAApJ,EAAA0d,GAAAtU,GAEA,OADAV,EAAAtE,KAAA,SAAAzG,GAA4B,OAe5B,SAAAA,EAAAqC,GACA,IAAAU,EAAAid,GAAAhgB,EAAAX,KAAAgD,EAAA,OAEA,IAAAU,EAEA,YAAA/C,EAAAX,KAAA4gB,GAAAjgB,EAAA,cAAAA,EAGA,OAAA+C,EAAA4b,SAWA,SAAA3e,EAAA+C,GACA,IAAA+H,EAAA9K,EAAAX,KAGA,GAFAW,EAAAX,KAAA0D,EAAA4b,SAEA3e,EAAAnC,OAAA,iBAAAmC,EAAAnC,MAAA,CAEA,IAAAwhB,EAAAtc,EAAAsc,WAEA,GAAArf,EAAAnC,MAAA6P,KAmBA,QAAAjM,EAAA,EAAAoE,OAAA,EAAoCpE,EAAAzB,EAAAnC,YAAArE,OAA6BiI,IAGjE,OAFAoE,EAAA7F,EAAAnC,YAAA4D,IAGAoE,GAAApE,EAAwB,GAAxB,SAAwB,aACnBye,GAAAra,GACLA,EAAAma,GAAAna,EAAAhI,MAAAwhB,IACAW,GAAAna,EAAAhI,MAAA4hB,KACA5Z,EACKsa,GAAAta,KACLA,EAAAua,GAAApgB,EAAAX,KAAAwG,IAGA7F,EAAAnC,YAAA4D,GAAAoE,MAhCA,CAEA,IAAAoX,EAAA+C,GA4GA,SAAAlV,EAAAzR,GACA,QAAAoI,EAAA,EAAAkU,EAAA,EAA6BlU,EAAAqJ,EAAAtR,OAAiBiI,IAAA,CAE9C,SADAkU,EAAAtc,EAAAyE,QAAAgN,EAAArJ,GAAAkU,IAEA,OAAA7K,EAAArN,MAAAgE,GAEAkU,IAGA,SArHA0K,CAAAvV,EAAA/H,EAAAzC,KAAA+e,GAEApC,IAEAA,EAAAla,EAAAkc,eACwC,IAAxChC,EAAAnf,QAAA,QAGAmf,EAAA,OAA4BA,EAAA,KAI5BA,GACAjd,EAAAnC,MAAAyE,IAAA2a,IAsBA,OAAAjd,EAvDAsgB,CAAAtgB,EAAA+C,GAgEA,SAAA/C,EAAA+C,GACA,OAAAkd,GAAAjgB,EAAA+C,EAAAlF,OAhEA0iB,CAAAvgB,EAAA+C,GAzB4Byd,CAAAxgB,EAAAqC,KAC5B0I,GAGA,SAAAgV,GAAAtU,GACA,OAAA+S,GAAA/S,EAAAzI,KAAqC9D,KAAA,YA6FrC,SAAA+gB,GAAAjgB,EAAA4T,GAGA,OAFA5T,EAAAX,KAAA,KACAW,EAAAnC,MAAA+V,EACA5T,EAWA,SAAAggB,GAAAlV,EAAA2V,EAAAngB,GACA,IAAAwK,EACA,YAMA,IAHA,IAAA4V,EAAA,KACAC,EAAA,EAEAlf,EAAA,EAAAc,OAAA,EAAiCd,EAAAgf,EAAAjnB,OAAkBiI,IAAA,CACnDc,EAAAke,EAAAhf,GACA,IAAA4c,EAAAR,GAAA/S,EAAA8V,GAAAre,EAAAjC,IAEA,OAAA+d,EAEA,OAAA9b,EAGA8b,MAAAsC,IACAA,EAAAtC,EACAqC,EAAAne,GAIA,OAAAme,EAGA,SAAAE,GAAAre,EAAAjC,GACA,IAAAzC,EAAA0E,GAAA,iBAAAA,IAAAjC,GAAAiC,EACA8O,GAAAxT,GAAA,IAAA7D,MAAA,YACA,OAAAqX,IAAA,GAAAxT,EA4BA,SAAAqiB,GAAAra,GACA,OAAAgb,GAAAhb,EAAA,WAQA,SAAAsa,GAAAta,GACA,OAAAgb,GAAAhb,EAAA,WAGA,SAAAgb,GAAAhb,EAAA3G,GACA,OAAA2G,GAAA,iBAAAA,KAAA3G,SASA,SAAAkhB,GAAAzB,EAAA9Y,GASA,OARAA,EAAAmW,KACAnW,EAAAmW,KAAA2D,GAAA9Z,EAAAmW,OAAAnW,EAAAmW,KACK,IAAAnW,EAAAhI,QAAA,IAAA6hB,GAAA5hB,QAAA6gB,KAGL9Y,EAAAmW,KAAAnW,EAAAhI,SAAA,EAAAgI,EAAAhI,OAAA,WAGAgI,EAGA,IAAAib,IACAC,UAAA,EACA3iB,QACA4iB,QAAA,KACA5W,MAAA,MAYA,SAAA6W,GAAAlW,EAAA4L,EAAA9X,GAGA,OAFAA,EAAAC,OAAAC,UAA2B+hB,GAAAjiB,GAE3BiW,GAAA/J,EAAAlM,EAAAqB,MAAA,SAAAkV,GACA,IAAApV,EAAAoV,EAAApV,KACAnC,EAAA8G,OAAA3E,EAAAnC,OAAA,IAEAmC,EAAAuD,WAAA/J,SAEAqE,EA4BA,SAAAxE,EAAAyI,GACA,IAAAsU,EAAArD,GAAA1Z,GACA6nB,EAAA9K,EAAApD,OAAAxZ,OAEA,GAAA0nB,EASA,KARApf,IAAArE,SACAjE,OAAA0nB,IAGApf,IAAArE,MAAA,EAAAyjB,EAAA,GACAlf,OAAAF,EAAArE,MAAAyjB,EAAA,GAAAnb,KAAA,QAGAjE,EAAAtI,QAAA,CACA,IAAAqE,EAAAiE,EAAAqf,QACAjhB,EAAAkW,EAAApD,OAAAmO,QACAC,EAAAvjB,EAAArE,OAAA0G,EAAA1G,OAEA4c,EAAA/c,OAAA+c,EAAA/c,OAAAoE,MAAA,EAAAyC,EAAAvC,UACAE,EACAuY,EAAA/c,OAAAoE,MAAAyC,EAAAvC,SAAAuC,EAAA1G,QAGA,QAAAiI,EAAA,EAAAC,EAAA0U,EAAApD,OAAAxZ,OAAkDiI,EAAAC,EAAQD,IAC1D2U,EAAApD,OAAAvR,GAAA9D,UAAAyjB,EAKA,OAAAhL,EAzDAiL,CAAAxjB,EADAmC,EAAAuD,WAAAlH,IAAA,SAAAoD,GAA0D,OA6D1D,SAAAA,EAAAZ,GACA,GAAAY,EAAA5B,OAAA,iBAAA4B,EAAA5B,OAAA,cAAA4B,EAAA5B,MAAAqB,KACA,OAAAO,EAAA5B,YACAxB,IAAA,SAAAwJ,GACA,OAAAA,GAAA,iBAAAA,EACA,UAAAA,EAAA3G,KACA2G,EAAAqB,SAAArI,EAAAkiB,UACAlb,EAAAqB,WAGAvC,OAAAkB,KAEAE,KAAA,KAGA,aAAAtG,EAAA5B,MAAA8G,OAAAlF,EAAA5B,OAAA,GA5E0DyjB,CAAA7hB,EAAAZ,OAmB1D,OAfAuW,EAAAjM,KAAAnJ,EAAAX,MAAAsX,EAAAtX,KAAAW,EAAAX,MACA+V,EAAAnB,UAAApV,EAAAT,OAAA4iB,QACA5L,EAAAxB,KAAAwB,EAAAT,aAAA9W,GAAA,MAEAuX,EAAAjM,OACAiM,EAAAf,UAAAxV,EAAAT,OAAAgM,OAGAuM,EAAAtZ,IAAA,YACA+X,EAAAd,QAAA,KACAvJ,EAAA3G,YAAApE,IACAoV,EAAAf,WAAAe,EAAAd,UAIAc,IA4DA,IAAAmM,IACAN,KACAD,QAAA,KACA5W,MAAA,KAEAoX,KAAA,MACAC,KAAA,MACAC,MACAV,QAAA,KACA5W,MAAA,IAEAuX,QACAX,QAAA,IACA5W,MAAA,KAsBAwX,GAAA,SAAA7W,EAAA4L,EAAAsD,EAAApb,GAiBA,MAhBA,iBAAAob,IACApb,EAAAob,EACAA,EAAA,MAsBA,SAAAA,GACA,QAAAA,QAAAsH,GApBAM,CAAA5H,KAEAA,EAAA,OASAgH,GAAAlW,EAAA4L,EANA9X,EAAAC,OAAAC,UAA2BF,GAC3BT,OAuBA,SAAA6b,EAAApb,GACA,IAAAT,EAAAmjB,GAAAtH,GACA,iBAAA7b,IACAA,EAAAmjB,GAAAnjB,IAGA,OAAAU,OAAAC,UAAwBX,EAAAS,KAAAT,QA7BxB0jB,CAAA7H,EAAApb,OAgCA,IA+VAkjB,IAAexJ,MA9Vf5V,EAAA,UACAqf,SAAA,wBACAC,SAAA,wBACAnX,KAAA,cACAoX,cAAA,iBACA3H,KAAA,cACA4H,SAAA,YACAC,GAAA,MACAC,MAAA,SACAC,GAAA,MACAC,IAAA,WACAC,QAAA,eACAC,QAAA,eACAC,IAAA,OACAC,KAAA,6BACAC,WAAA,8BACAC,aAAA,0CACAC,eAAA,sEACAC,aAAA,qDACAC,WAAA,6EACAC,YAAA,gFACAC,sBAAA,8CACAC,KAAA,QACAC,WAAA,kEACAC,UAAA,gFACAC,cAAA,uDACAC,YAAA,sCACAC,gBAAA,oEACAC,MAAA,QACAC,OAAA,eACAC,aAAA,cACAC,IAAA,gBACAC,mBAAA,sBACAC,kBAAA,4BACAC,QAAA,UACAC,aAAA,UACAC,oBAAA,mBACAC,sBAAA,iBACAC,oBAAA,oCACAC,qBAAA,uBACAC,qBAAA,4CACAC,2BAAA,mCACAC,4BAAA,6BACAC,2BAAA,0CACAC,OAAA,4BACAC,MAAA,mBACAtX,OAAA,oBACAuX,MAAA,qBACAtoB,IAAA,YACAuoB,KAAA,+BACAC,SAAA,sBACAC,SAAA,qBACAC,SAAA,mBACAC,SAAA,mBACAC,KAAA,eACAC,WAAA,mBACAC,YAAA,oBACAC,MAAA,aACAC,MAAA,yBACAC,IAAA,2BACAC,uBAAA,0BACAC,qBAAA,MACAC,eAAA,mBACAC,cAAA,kBACAC,YAAA,gBACAC,yBAAA,qBACAC,iBAAA,qBACAC,aAAA,iBACAC,uBAAA,2BACAC,cAAA,kBACAC,aAAA,iBACAC,aAAA,iBACAC,YAAA,gBACAC,eAAA,mBACAC,cAAA,kBACAC,yBAAA,qBACAC,sBAAA,kBACAC,cAAA,kBACAC,qBAAA,iBACAC,uBAAA,2BACAC,sBAAA,4BACAC,uBAAA,2BACAC,cAAA,2BACAC,QAAA,WACA9Z,OAAA,4BACA+Z,2BAAA,oBACAC,aAAA,gBACAC,SAAA,wDACAC,QAAA,8BACAC,sBAAA,qBACAC,sBAAA,qBACAja,MAAA,aACAD,MAAA,aACAma,WAAA,2CACAC,OAAA,UACAC,QAAA,WACAC,+BAAA,sBACAC,8BAAA,qBACAC,iCAAA,oBACAC,4CAAA,sBAEAC,GAAA,aACAC,IAAA,SACAC,KAAA,aACAC,IAAA,UACAC,IAAA,SACAC,IAAA,QACAC,IAAA,SACAC,IAAA,UACAC,KAAA,WACAC,IAAA,WACAC,IAAA,SACAC,KAAA,WACAC,MAAA,WACAC,IAAA,SACAC,KAAA,UACAC,IAAA,UACAC,IAAA,SACAC,IAAA,SACAC,IAAA,UACAC,IAAA,SACAzpB,IAAA,SACA0pB,KAAA,WACAC,GAAA,OACAC,IAAA,WACAC,KAAA,WACAC,MAAA,WACAC,MAAA,WACAC,GAAA,SACAvkB,IAAA,SACAwkB,IAAA,UACAC,IAAA,UAEAC,cAAA,QACAC,mBAAA,QACAC,cAAA,gBACAC,eAAA,gBAEAC,MAAA,oBACAC,IAAA,iGACAC,WAAA,UAEAvvB,EAAA,wBACAwvB,QAAA,uCACAC,UAAA,2DA8MehJ,KA1MfiJ,KAAA,2DACAC,MAAA,kXACAC,aAAA,qBACAC,MAAA,0CACAC,YAAA,kCACAC,GAAA,8EACAC,GAAA,0DACAC,KAAA,uHACAC,QAAA,4BACAC,QAAA,iEACAC,QAAA,6BACAC,OAAA,8CACAC,OAAA,uCACAC,MAAA,iBACAC,OAAA,sCACAC,OAAA,0HACAC,GAAA,kBACAC,GAAA,8DACAvoB,EAAA,SACAwoB,GAAA,uCACAC,IAAA,8CACAC,KAAA,gCACAC,KAAA,gCACAC,KAAA,qBACAC,MAAA,8CACAC,OAAA,4BACAC,MAAA,+CACAC,OAAA,6BACAC,KAAA,sBACAC,KAAA,sBACAC,IAAA,yBACAC,KAAA,yCACAC,KAAA,oCACAC,IAAA,gEACAC,IAAA,yBACAC,IAAA,4CACAC,KAAA,8BACAC,MAAA,gBACAC,KAAA,8BACAC,KAAA,oBACAC,KAAA,oBACAC,IAAA,6CACAC,KAAA,+BACAC,KAAA,+BACAC,KAAA,gBACAC,MAAA,qBACAC,KAAA,qBACAC,IAAA,sGACAC,KAAA,iBACAC,IAAA,2CACAC,KAAA,6BACAC,KAAA,6BACAC,MAAA,2CACAC,OAAA,yBACAC,MAAA,4CACAC,OAAA,0BACAC,KAAA,mBACAC,KAAA,mBACAC,IAAA,eACAC,IAAA,qCACAC,GAAA,uBACAC,IAAA,qCACAC,KAAA,oDACAC,IAAA,6BACAC,KAAA,6DACAC,IAAA,6BACAC,IAAA,uDACAC,IAAA,oCACAC,KAAA,wBACAC,KAAA,wBACAC,IAAA,4DACAC,KAAA,gCACAC,KAAA,sEACAC,KAAA,+CACAl0B,EAAA,kBACA0W,GAAA,6BACAyd,GAAA,aACAC,IAAA,oHACAC,IAAA,oBACAC,KAAA,UACAC,MAAA,eACAC,MAAA,cACAC,MAAA,aACAC,MAAA,cACAC,OAAA,oBACAC,OAAA,oBACAC,OAAA,oBACAC,MAAA,cACAC,MAAA,eACAC,IAAA,gBACAC,GAAA,4DACAC,IAAA,0BACAhR,IAAA,oEACAiR,EAAA,wRACAC,GAAA,wBACAC,EAAA,gCACAC,IAAA,0CACAC,IAAA,iBACAC,KAAA,uCACAC,KAAA,mDACAC,GAAA,yDACAC,GAAA,wBACAC,GAAA,mCACAC,IAAA,uDACAhI,IAAA,oIACAiI,GAAA,iCACAC,GAAA,yCACAC,GAAA,OACAC,IAAA,8DACAC,IAAA,uDACAC,IAAA,YACAC,IAAA,YACAC,KAAA,cACAC,IAAA,qCACAC,GAAA,YACAC,IAAA,mBACAC,EAAA,SACAC,GAAA,wEACAC,EAAA,OACAC,GAAA,yCACAC,GAAA,cACAC,IAAA,aACAC,KAAA,mBACAC,KAAA,qCACAC,KAAA,0FACAC,IAAA,wBACArgB,EAAA,SACAsgB,IAAA,aACAC,IAAA,iBACAC,IAAA,YACAC,GAAA,gBACAC,IAAA,aACAC,IAAA,iBACAC,IAAA,YACAC,GAAA,cACAC,GAAA,eACAC,GAAA,aACA3lB,GAAA,UACA4lB,IAAA,iCACAC,IAAA,iBACAC,IAAA,0EACAC,IAAA,kCACAC,GAAA,UACAC,IAAA,QACAC,IAAA,iCACAC,IAAA,UACAC,GAAA,6CACAC,IAAA,8DACAC,IAAA,+CACAC,IAAA,+CACAzmB,EAAA,UACA0mB,GAAA,iBACAC,KAAA,0CACAC,KAAA,2CACAC,KAAA,+BACAC,GAAA,eACA95B,IAAA,mDACA+5B,GAAA,gBACAC,GAAA,cACAC,EAAA,SACAC,IAAA,6CACAC,IAAA,6CACA3lB,EAAA,QACA4lB,IAAA,uCACAC,EAAA,MACAC,GAAA,uCACAC,IAAA,oCACAC,IAAA,qBACAC,GAAA,uDACAC,GAAA,yDACAC,GAAA,gDACAC,GAAA,cACAC,GAAA,wFACAvrB,GAAA,uCACAwrB,IAAA,8BACA1nB,GAAA,eACA2nB,IAAA,iWACAC,KAAA,mBACAC,KAAA,8BACAC,IAAA,iCACAC,MAAA,6BACAC,MAAA,gCACAC,KAAA,gCACAC,MAAA,qCACAC,IAAA,sDACAC,GAAA,qDACAC,GAAA,8CACAC,GAAA,mBACAxiB,EAAA,qCACAyiB,GAAA,2EACAC,EAAA,QACAC,IAAA,kDACAC,KAAA,oEACAC,IAAA,SACAC,GAAA,qEACAC,IAAA,uCACAC,IAAA,eACAC,IAAA,yDACAC,EAAA,UACAC,IAAA,WAqGAC,IAAaC,OA/FbC,QAAA,yEACAC,OAAA,kEACA,+DACA,+DACA,wDACA,4DACA,0DACA,8DACA,iEACA,2DACA,2DACA,4DACA,4DACA,wDACA,+DACA,2DACA,2DACA,8DACA,iEACA,gEACA,uDACA,4DACA,yDACA,4DACA,gEACA,4DACA,0DACA,6DACA,6DACA,sBAkEaC,IA9DbF,QAAA,yGACAC,OAAA,oEACA,4DACA,8DACA,oEACA,2DACA,8DACA,+DACA,iEACA,kEACA,+DACA,yDACA,+DACA,sDACA,4DACA,kEACA,oEACA,+DACA,gEACA,+DACA,+DACA,uEACA,0DACA,8DACA,6DACA,4DACA,0DAoCaE,IAhCbH,QAAA,uDACAC,OAAA,yDACA,kFACA,gEACA,qDACA,wEACA,4DACA,+DACA,uEACA,+DACA,8DACA,4DACA,+DACA,gEACA,qEACA,6DACA,6DACA,oEACA,+DACA,yEACA,gEACA,+DACA,8EACA,8DACA,8DACA,sDACA,6DACA,kEACA,kEACA,uBAKAG,IACAC,UAAA,GACAC,YAAA,EACAC,KAAA,SASA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","file":"static/js/2.1c7027b8ca41de4fb979.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.codemirrorEmmet = factory());\n}(this, (function () { 'use strict';\n\n/**\n * Minimalistic backwards stream reader\n */\nvar StreamReader = function StreamReader(string) {\n\tthis.string = string;\n\tthis.pos = this.string.length;\n};\n\nStreamReader.prototype.sol = function sol () {\n\treturn this.pos === 0;\n};\n\nStreamReader.prototype.peek = function peek (offset) {\n\treturn this.string.charCodeAt(this.pos - 1 + (offset || 0));\n};\n\nStreamReader.prototype.prev = function prev () {\n\tif (!this.sol()) {\n\t\treturn this.string.charCodeAt(--this.pos);\n\t}\n};\n\nStreamReader.prototype.eat = function eat (match) {\n\tvar ok = typeof match === 'function'\n\t\t? match(this.peek())\n\t\t: match === this.peek();\n\n\tif (ok) {\n\t\tthis.pos--;\n\t}\n\n\treturn ok;\n};\n\nStreamReader.prototype.eatWhile = function eatWhile (match) {\n\tvar start = this.pos;\n\twhile (this.eat(match)) {}\n\treturn this.pos < start;\n};\n\n/**\n * Quotes-related utilities\n */\n\nvar SINGLE_QUOTE = 39; // '\nvar DOUBLE_QUOTE = 34; // \"\nvar ESCAPE       = 92; // \\\n\n/**\n * Check if given character code is a quote\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isQuote(c) {\n\treturn c === SINGLE_QUOTE || c === DOUBLE_QUOTE;\n}\n\n/**\n * Consumes quoted value, if possible\n * @param  {StreamReader} stream\n * @return {Boolean}      Returns `true` is value was consumed\n */\nfunction eatQuoted(stream) {\n\tvar start = stream.pos;\n\tvar quote = stream.prev();\n\n\tif (isQuote(quote)) {\n\t\twhile (!stream.sol()) {\n\t\t\tif (stream.prev() === quote && stream.peek() !== ESCAPE) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\nvar TAB         = 9;\nvar SPACE       = 32;\nvar SLASH       = 47; // /\nvar COLON       = 58; // :\nvar EQUALS      = 61; // =\nvar ANGLE_LEFT  = 60; // <\nvar ANGLE_RIGHT = 62; // >\n\n/**\n * Check if given readers current position points at the end of HTML tag\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nvar isAtHTMLTag = function(stream) {\n\tvar start = stream.pos;\n\n\tif (!stream.eat(ANGLE_RIGHT)) {\n\t\treturn false;\n\t}\n\n\tvar ok = false;\n\tstream.eat(SLASH); // possibly self-closed element\n\n\twhile (!stream.sol()) {\n\t\tstream.eatWhile(isWhiteSpace);\n\n\t\tif (eatIdent(stream)) {\n\t\t\t// ate identifier: could be a tag name, boolean attribute or unquoted\n\t\t\t// attribute value\n\t\t\tif (stream.eat(SLASH)) {\n\t\t\t\t// either closing tag or invalid tag\n\t\t\t\tok = stream.eat(ANGLE_LEFT);\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(ANGLE_LEFT)) {\n\t\t\t\t// opening tag\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t} else if (stream.eat(isWhiteSpace)) {\n\t\t\t\t// boolean attribute\n\t\t\t\tcontinue;\n\t\t\t} else if (stream.eat(EQUALS)) {\n\t\t\t\t// simple unquoted value or invalid attribute\n\t\t\t\tok = eatIdent(stream);\n\t\t\t\tbreak;\n\t\t\t} else if (eatAttributeWithUnquotedValue(stream)) {\n\t\t\t\t// identifier was a part of unquoted value\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// invalid tag\n\t\t\tbreak;\n\t\t}\n\n\t\tif (eatAttribute(stream)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tstream.pos = start;\n\treturn ok;\n};\n\n/**\n * Eats HTML attribute from given string.\n * @param  {StreamReader} state\n * @return {Boolean}       `true` if attribute was consumed.\n */\nfunction eatAttribute(stream) {\n\treturn eatAttributeWithQuotedValue(stream) || eatAttributeWithUnquotedValue(stream);\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithQuotedValue(stream) {\n\tvar start = stream.pos;\n\tif (eatQuoted(stream) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatAttributeWithUnquotedValue(stream) {\n\tvar start = stream.pos;\n\tif (stream.eatWhile(isUnquotedValue) && stream.eat(EQUALS) && eatIdent(stream)) {\n\t\treturn true;\n\t}\n\n\tstream.pos = start;\n\treturn false;\n}\n\n/**\n * Eats HTML identifier from stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatIdent(stream) {\n\treturn stream.eatWhile(isIdent);\n}\n\n/**\n * Check if given character code belongs to HTML identifier\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isIdent(c) {\n\treturn c === COLON || isAlpha(c) || isNumber(c);\n}\n\n/**\n * Check if given character code is alpha code (letter though A to Z)\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isAlpha(c) {\n\tc &= ~32; // quick hack to convert any char code to uppercase char code\n\treturn c >= 65 && c <= 90; // A-Z\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isNumber(c) {\n\treturn c > 47 && c < 58;\n}\n\n/**\n * Check if given code is a whitespace\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isWhiteSpace(c) {\n\treturn c === SPACE || c === TAB;\n}\n\n/**\n * Check if given code may belong to unquoted attribute value\n * @param  {Number}  c\n * @return {Boolean}\n */\nfunction isUnquotedValue(c) {\n\treturn c && c !== EQUALS && !isWhiteSpace(c) && !isQuote(c);\n}\n\nvar code = function (ch) { return ch.charCodeAt(0); };\nvar SQUARE_BRACE_L = code('[');\nvar SQUARE_BRACE_R = code(']');\nvar ROUND_BRACE_L  = code('(');\nvar ROUND_BRACE_R  = code(')');\nvar CURLY_BRACE_L  = code('{');\nvar CURLY_BRACE_R  = code('}');\n\nvar specialChars = new Set('#.*:$-_!@%^+>/'.split('').map(code));\nvar bracePairs = new Map()\n.set(SQUARE_BRACE_L, SQUARE_BRACE_R)\n.set(ROUND_BRACE_L,  ROUND_BRACE_R)\n.set(CURLY_BRACE_L,  CURLY_BRACE_R);\n\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editors line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param {String}  line A text line where abbreviation should be expanded\n * @param {Number}  [pos] Caret position in line. If not given, uses end-of-line\n * @param {Boolean} [lookAhead] Allow parser to look ahead of `pos` index for\n * searching of missing abbreviation parts. Most editors automatically inserts\n * closing braces for `[`, `{` and `(`, which will most likely be right after\n * current caret position. So in order to properly expand abbreviation, user\n * must explicitly move caret right after auto-inserted braces. Whith this option\n * enabled, parser will search for closing braces right after `pos`. Default is `true`\n * @return {Object} Object with `abbreviation` and its `location` in given line\n * if abbreviation can be extracted, `null` otherwise\n */\nfunction extractAbbreviation$1(line, pos, lookAhead) {\n\t// make sure `pos` is within line range\n\tpos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n\n\tif (lookAhead == null || lookAhead === true) {\n\t\tpos = offsetPastAutoClosed(line, pos);\n\t}\n\n\tvar c;\n\tvar stream = new StreamReader(line);\n\tstream.pos = pos;\n\tvar stack = [];\n\n\twhile (!stream.sol()) {\n\t\tc = stream.peek();\n\n\t\tif (isCloseBrace(c)) {\n\t\t\tstack.push(c);\n\t\t} else if (isOpenBrace(c)) {\n\t\t\tif (stack.pop() !== bracePairs.get(c)) {\n\t\t\t\t// unexpected brace\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (has(stack, SQUARE_BRACE_R) || has(stack, CURLY_BRACE_R)) {\n\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\tstream.pos--;\n\t\t\tcontinue;\n\t\t} else if (isAtHTMLTag(stream) || !isAbbreviation(c)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tstream.pos--;\n\t}\n\n\tif (!stack.length && stream.pos !== pos) {\n\t\t// found something, remove some invalid symbols from the\n\t\t// beginning and return abbreviation\n\t\tvar abbreviation = line.slice(stream.pos, pos).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\treturn {\n\t\t\tabbreviation: abbreviation,\n\t\t\tlocation: pos - abbreviation.length\n\t\t};\n\t}\n}\n\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * edditor will likely automatically close, e.g. }, ], and quotes\n * @param {String} line\n * @param {Number} pos\n * @return {Number}\n */\nfunction offsetPastAutoClosed(line, pos) {\n\t// closing quote is allowed only as a next character\n\tif (isQuote(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\t// offset pointer until non-autoclosed character is found\n\twhile (isCloseBrace(line.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n}\n\nfunction has(arr, value) {\n\treturn arr.indexOf(value) !== -1;\n}\n\nfunction isAbbreviation(c) {\n\treturn (c > 64 && c < 91)   // uppercase letter\n\t\t|| (c > 96 && c < 123)  // lowercase letter\n\t\t|| (c > 47 && c < 58)   // number\n\t\t|| specialChars.has(c); // special character\n}\n\nfunction isOpenBrace(c) {\n\treturn c === SQUARE_BRACE_L || c === ROUND_BRACE_L || c === CURLY_BRACE_L;\n}\n\nfunction isCloseBrace(c) {\n\treturn c === SQUARE_BRACE_R || c === ROUND_BRACE_R || c === CURLY_BRACE_R;\n}\n\nvar defaultOptions$1 = {\n\t/**\n\t * String for one-level indentation\n\t * @type {String}\n\t */\n\tindent: '\\t',\n\n\t/**\n\t * Tag case: 'lower', 'upper' or '' (keep as-is)\n\t * @type {String}\n\t */\n\ttagCase: '',\n\n\t/**\n\t * Attribute name case: 'lower', 'upper' or '' (keep as-is)\n\t * @type {String}\n\t */\n\tattributeCase: '',\n\n\t/**\n\t * Attribute value quotes: 'single' or 'double'\n\t * @type {String}\n\t */\n\tattributeQuotes: 'double',\n\n\t/**\n\t * Enable output formatting (indentation and line breaks)\n\t * @type {Boolean}\n\t */\n\tformat: true,\n\n\t/**\n\t * A list of tag names that should not get inner indentation\n\t * @type {Set}\n\t */\n\tformatSkip: ['html'],\n\n\t/**\n\t * A list of tag names that should *always* get inner indentation.\n\t * @type {Set}\n\t */\n\tformatForce: ['body'],\n\n\t/**\n\t * How many inline sibling elements should force line break for each tag.\n\t * Set to 0 to output all inline elements without formatting.\n\t * Set to 1 to output all inline elements with formatting (same as block-level).\n\t * @type {Number}\n\t */\n\tinlineBreak: 3,\n\n\t/**\n\t * Produce compact notation of boolean attribues: attributes where name equals value.\n\t * With this option enabled, output `<div contenteditable>` instead of\n\t * `<div contenteditable=\"contenteditable\">`\n\t * @type {Boolean}\n\t */\n\tcompactBooleanAttributes: false,\n\n\t/**\n\t * A set of boolean attributes\n\t * @type {Set}\n\t */\n\tbooleanAttributes: ['contenteditable', 'seamless', 'async', 'autofocus',\n\t\t'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n\t\t'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n\t\t'required', 'reversed', 'selected', 'typemustmatch'],\n\n\t/**\n\t * Style of self-closing tags:\n\t * 'html'   <br>\n\t * 'xml'    <br/>\n\t * 'xhtml'  <br />\n\t * @type {String}\n\t */\n\tselfClosingStyle: 'html',\n\n\t/**\n\t * A set of inline-level elements\n\t * @type {Set}\n\t */\n\tinlineElements: ['a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n\t\t'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n\t\t'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n\t\t's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n\t\t'textarea', 'tt', 'u', 'var']\n};\n\n/**\n * Creates output profile for given options (@see defaults)\n * @param {defaults} options\n */\nvar Profile = function Profile(options) {\n        this.options = Object.assign({}, defaultOptions$1, options);\n        this.quoteChar = this.options.attributeQuotes === 'single' ? '\\'' : '\"';\n    };\n\n/**\n\t * Returns value of given option name\n\t * @param {String} name\n\t * @return {*}\n\t */\nProfile.prototype.get = function get (name) {\n\treturn this.options[name];\n};\n\n    /**\n     * Quote given string according to profile\n     * @param {String} str String to quote\n     * @return {String}\n     */\n    Profile.prototype.quote = function quote (str) {\n        return (\"\" + (this.quoteChar) + (str != null ? str : '') + (this.quoteChar));\n    };\n\n    /**\n     * Output given tag name accoding to options\n     * @param {String} name\n     * @return {String}\n     */\n    Profile.prototype.name = function name (name$1) {\n        return strcase(name$1, this.options.tagCase);\n    };\n\n/**\n\t * Outputs attribute name accoding to current settings\n\t * @param {String} Attribute name\n\t * @return {String}\n\t */\n    Profile.prototype.attribute = function attribute (attr) {\n        return strcase(attr, this.options.attributeCase);\n    };\n\n    /**\n     * Check if given attribute is boolean\n     * @param {Attribute} attr\n     * @return {Boolean}\n     */\n    Profile.prototype.isBooleanAttribute = function isBooleanAttribute (attr) {\n        return attr.options.boolean\n\t\t|| this.get('booleanAttributes').indexOf((attr.name || '').toLowerCase()) !== -1;\n    };\n\n/**\n\t * Returns a token for self-closing tag, depending on current options\n\t * @return {String}\n\t */\nProfile.prototype.selfClose = function selfClose () {\n\tswitch (this.options.selfClosingStyle) {\n\t\tcase 'xhtml': return ' /';\n\t\tcase 'xml':   return '/';\n\t\tdefault:      return '';\n\t}\n};\n\n/**\n\t * Returns indent for given level\n\t * @param {Number} level Indentation level\n\t * @return {String}\n\t */\nProfile.prototype.indent = function indent (level) {\n\t\tvar this$1 = this;\n\n\tlevel = level || 0;\n\tvar output = '';\n\twhile (level--) {\n\t\toutput += this$1.options.indent;\n\t}\n\n\treturn output;\n};\n\n/**\n\t * Check if given tag name belongs to inline-level element\n\t * @param {Node|String} node Parsed node or tag name\n\t * @return {Boolean}\n\t */\nProfile.prototype.isInline = function isInline (node) {\n        if (typeof node === 'string') {\n            return this.get('inlineElements').indexOf(node.toLowerCase()) !== -1;\n        }\n\n        // inline node is a node either with inline-level name or text-only node\n        return node.name != null ? this.isInline(node.name) : node.isTextOnly;\n};\n\n/**\n\t * Outputs formatted field for given params\n\t * @param {Number} index Field index\n\t * @param {String} [placeholder] Field placeholder, can be empty\n\t * @return {String}\n\t */\nProfile.prototype.field = function field (index, placeholder) {\n\treturn this.options.field(index, placeholder);\n};\n\nfunction strcase(string, type) {\n    if (type) {\n        string = type === 'upper' ? string.toUpperCase() : string.toLowerCase();\n    }\n    return string;\n}\n\nvar Snippet = function Snippet(key, value) {\n    this.key = key;\n    this.value = value;\n};\n\nvar SnippetsStorage = function SnippetsStorage(data) {\n    this._string = new Map();\n    this._regexp = new Map();\n    this._disabled = false;\n\n    this.load(data);\n};\n\nvar prototypeAccessors = { disabled: {} };\n\nprototypeAccessors.disabled.get = function () {\n    return this._disabled;\n};\n\n/**\n * Disables current store. A disabled store always returns `undefined`\n * on `get()` method\n */\nSnippetsStorage.prototype.disable = function disable () {\n    this._disabled = true;\n};\n\n/**\n * Enables current store.\n */\nSnippetsStorage.prototype.enable = function enable () {\n    this._disabled = false;\n};\n\n/**\n * Registers a new snippet item\n * @param {String|Regexp} key\n * @param {String|Function} value\n */\nSnippetsStorage.prototype.set = function set (key, value) {\n        var this$1 = this;\n\n    if (typeof key === 'string') {\n        key.split('|').forEach(function (k) { return this$1._string.set(k, new Snippet(k, value)); });\n    } else if (key instanceof RegExp) {\n        this._regexp.set(key, new Snippet(key, value));\n    } else {\n        throw new Error('Unknow snippet key: ' + key);\n    }\n\n    return this;\n};\n\n/**\n * Returns a snippet matching given key. It first tries to find snippet\n * exact match in a string key map, then tries to match one with regexp key\n * @param {String} key\n * @return {Snippet}\n */\nSnippetsStorage.prototype.get = function get (key) {\n        var this$1 = this;\n\n    if (this.disabled) {\n        return undefined;\n    }\n\n    if (this._string.has(key)) {\n        return this._string.get(key);\n    }\n\n    var keys = Array.from(this._regexp.keys());\n    for (var i = 0, il = keys.length; i < il; i++) {\n        if (keys[i].test(key)) {\n            return this$1._regexp.get(keys[i]);\n        }\n    }\n};\n\n/**\n * Batch load of snippets data\n * @param {Object|Map} data\n */\nSnippetsStorage.prototype.load = function load (data) {\n        var this$1 = this;\n\n    this.reset();\n    if (data instanceof Map) {\n        data.forEach(function (value, key) { return this$1.set(key, value); });\n    } else if (data && typeof data === 'object') {\n        Object.keys(data).forEach(function (key) { return this$1.set(key, data[key]); });\n    }\n};\n\n/**\n * Clears all stored snippets\n */\nSnippetsStorage.prototype.reset = function reset () {\n    this._string.clear();\n    this._regexp.clear();\n};\n\n/**\n * Returns all available snippets from given store\n */\nSnippetsStorage.prototype.values = function values () {\n    if (this.disabled) {\n        return [];\n    }\n        \n    var string = Array.from(this._string.values());\n    var regexp = Array.from(this._regexp.values());\n    return string.concat(regexp);\n};\n\nObject.defineProperties( SnippetsStorage.prototype, prototypeAccessors );\n\n/**\n * A snippets registry. Contains snippets, separated by store and sorted by\n * priority: a store with higher priority takes precedence when resolving snippet\n * for given key\n */\nvar SnippetsRegistry = function SnippetsRegistry(data) {\n    var this$1 = this;\n\n    this._registry = [];\n\n    if (Array.isArray(data)) {\n        data.forEach(function (snippets, level) { return this$1.add(level, snippets); });\n    } else if (typeof data === 'object') {\n        this.add(data);\n    }\n};\n\n/**\n * Return store for given level\n * @param {Number} level\n * @return {SnippetsStorage}\n */\nSnippetsRegistry.prototype.get = function get (level) {\n        var this$1 = this;\n\n    for (var i = 0; i < this._registry.length; i++) {\n        var item = this$1._registry[i];\n        if (item.level === level) {\n            return item.store;\n        }\n    }\n};\n\n/**\n * Adds new store for given level\n * @param {Number} [level] Store level (priority). Store with higher level\n * takes precedence when resolving snippets\n * @param {Object} [snippets] A snippets data for new store\n * @return {SnipetsStorage}\n */\nSnippetsRegistry.prototype.add = function add (level, snippets) {\n    if (level != null && typeof level === 'object') {\n        snippets = level;\n        level = 0;\n    }\n\n    var store = new SnippetsStorage(snippets);\n\n    // remove previous store from same level\n    this.remove(level);\n\n    this._registry.push({level: level, store: store});\n    this._registry.sort(function (a, b) { return b.level - a.level; });\n\n    return store;\n};\n\n/**\n * Remove registry with given level or store\n * @param {Number|SnippetsStorage} data Either level or snippets store\n */\nSnippetsRegistry.prototype.remove = function remove (data) {\n    this._registry = this._registry\n    .filter(function (item) { return item.level !== data && item.store !== data; });\n};\n\n/**\n * Returns snippet from registry that matches given name\n * @param {String} name\n * @return {Snippet}\n */\nSnippetsRegistry.prototype.resolve = function resolve (name) {\n        var this$1 = this;\n\n    for (var i = 0; i < this._registry.length; i++) {\n        var snippet = this$1._registry[i].store.get(name);\n        if (snippet) {\n            return snippet;\n        }\n    }\n};\n\n/**\n * Returns all available snippets from current registry. Snippets with the\n * same key are resolved by their storage priority.\n * @param {Object} options\n * @param {Object} options.type Return snippets only of given type: 'string'\n * or 'regexp'. Returns all snippets if not defined\n * @return {Array}\n */\nSnippetsRegistry.prototype.all = function all (options) {\n    options = options || {};\n    var result = new Map();\n\n    var fillResult = function (snippet) {\n        var type = snippet.key instanceof RegExp ? 'regexp' : 'string';\n        if ((!options.type || options.type === type) && !result.has(snippet.key)) {\n            result.set(snippet.key, snippet);\n        }\n    };\n\n    this._registry.forEach(function (item) {\n        item.store.values().forEach(fillResult);\n    });\n\n    return Array.from(result.values());\n};\n\n/**\n * Removes all stores from registry\n */\nSnippetsRegistry.prototype.clear = function clear () {\n    this._registry.length = 0;\n};\n\n/**\n * Attribute descriptor of parsed abbreviation node\n * @param {String} name Attribute name\n * @param {String} value Attribute value\n * @param {Object} options Additional custom attribute options\n * @param {Boolean} options.boolean Attribute is boolean (e.g. name equals value)\n * @param {Boolean} options.implied Attribute is implied (e.g. must be outputted\n * only if contains non-null value)\n */\nvar Attribute = function Attribute(name, value, options) {\n\tthis.name = name;\n\tthis.value = value != null ? value : null;\n\tthis.options = options || {};\n};\n\n/**\n\t * Create a copy of current attribute\n\t * @return {Attribute}\n\t */\nAttribute.prototype.clone = function clone () {\n\treturn new Attribute(this.name, this.value, Object.assign({}, this.options));\n};\n\n/**\n\t * A string representation of current node\n\t */\nAttribute.prototype.valueOf = function valueOf () {\n\treturn ((this.name) + \"=\\\"\" + (this.value) + \"\\\"\");\n};\n\n/**\n * A parsed abbreviation AST node. Nodes build up an abbreviation AST tree\n */\nvar Node = function Node(name, attributes) {\n\tvar this$1 = this;\n\n\t// own properties\n\tthis.name = name || null;\n\tthis.value = null;\n\tthis.repeat = null;\n\tthis.selfClosing = false;\n\n\tthis.children = [];\n\n\t/** @type {Node} Pointer to parent node */\n\tthis.parent = null;\n\n\t/** @type {Node} Pointer to next sibling */\n\tthis.next = null;\n\n\t/** @type {Node} Pointer to previous sibling */\n\tthis.previous = null;\n\n\tthis._attributes = [];\n\n\tif (Array.isArray(attributes)) {\n\t\tattributes.forEach(function (attr) { return this$1.setAttribute(attr); });\n\t}\n};\n\nvar prototypeAccessors$1 = { attributes: {},attributesMap: {},isGroup: {},isTextOnly: {},firstChild: {},lastChild: {},childIndex: {},nextSibling: {},previousSibling: {},classList: {} };\n\n/**\n\t * Array of current node attributes\n\t * @return {Attribute[]} Array of attributes\n\t */\nprototypeAccessors$1.attributes.get = function () {\n\treturn this._attributes;\n};\n\n/**\n\t * A shorthand to retreive node attributes as map\n\t * @return {Object}\n\t */\nprototypeAccessors$1.attributesMap.get = function () {\n\treturn this.attributes.reduce(function (out, attr) {\n\t\tout[attr.name] = attr.options.boolean ? attr.name : attr.value;\n\t\treturn out;\n\t}, {});\n};\n\n/**\n\t * Check if current node is a grouping one, e.g. has no actual representation\n\t * and is used for grouping subsequent nodes only\n\t * @return {Boolean}\n\t */\nprototypeAccessors$1.isGroup.get = function () {\n\treturn !this.name && !this.value && !this._attributes.length;\n};\n\n/**\n\t * Check if given node is a text-only node, e.g. contains only value\n\t * @return {Boolean}\n\t */\nprototypeAccessors$1.isTextOnly.get = function () {\n\treturn !this.name && !!this.value && !this._attributes.length;\n};\n\n/**\n\t * Returns first child node\n\t * @return {Node}\n\t */\nprototypeAccessors$1.firstChild.get = function () {\n\treturn this.children[0];\n};\n\n/**\n\t * Returns last child of current node\n\t * @return {Node}\n\t */\nprototypeAccessors$1.lastChild.get = function () {\n\treturn this.children[this.children.length - 1];\n};\n\n/**\n\t * Return index of current node in its parent child list\n\t * @return {Number} Returns -1 if current node is a root one\n\t */\nprototypeAccessors$1.childIndex.get = function () {\n\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n};\n\n/**\n\t * Returns next sibling of current node\n\t * @return {Node}\n\t */\nprototypeAccessors$1.nextSibling.get = function () {\n\treturn this.next;\n};\n\n/**\n\t * Returns previous sibling of current node\n\t * @return {Node}\n\t */\nprototypeAccessors$1.previousSibling.get = function () {\n\treturn this.previous;\n};\n\n/**\n\t * Returns array of unique class names in current node\n\t * @return {String[]}\n\t */\nprototypeAccessors$1.classList.get = function () {\n\tvar attr = this.getAttribute('class');\n\treturn attr && attr.value\n\t\t? attr.value.split(/\\s+/g).filter(uniqueClass)\n\t\t: [];\n};\n\n/**\n\t * Convenient alias to create a new node instance\n\t * @param {String} [name] Node name\n\t * @param {Object} [attributes] Attributes hash\n\t * @return {Node}\n\t */\nNode.prototype.create = function create (name, attributes) {\n\treturn new Node(name, attributes);\n};\n\n/**\n\t * Sets given attribute for current node\n\t * @param {String|Object|Attribute} name Attribute name or attribute object\n\t * @param {String} [value] Attribute value\n\t */\nNode.prototype.setAttribute = function setAttribute (name, value) {\n\tvar attr = createAttribute(name, value);\n\tvar curAttr = this.getAttribute(name);\n\tif (curAttr) {\n\t\tthis.replaceAttribute(curAttr, attr);\n\t} else {\n\t\tthis._attributes.push(attr);\n\t}\n};\n\n/**\n\t * Check if attribute with given name exists in node\n\t * @param  {String} name\n\t * @return {Boolean}\n\t */\nNode.prototype.hasAttribute = function hasAttribute (name) {\n\treturn !!this.getAttribute(name);\n};\n\n/**\n\t * Returns attribute object by given name\n\t * @param  {String} name\n\t * @return {Attribute}\n\t */\nNode.prototype.getAttribute = function getAttribute (name) {\n\t\tvar this$1 = this;\n\n\tif (typeof name === 'object') {\n\t\tname = name.name;\n\t}\n\n\tfor (var i = 0; i < this._attributes.length; i++) {\n\t\tvar attr = this$1._attributes[i];\n\t\tif (attr.name === name) {\n\t\t\treturn attr;\n\t\t}\n\t}\n};\n\n/**\n\t * Replaces attribute with new instance\n\t * @param {String|Attribute} curAttribute Current attribute name or instance\n\t * to replace\n\t * @param {String|Object|Attribute} newName New attribute name or attribute object\n\t * @param {String} [newValue] New attribute value\n\t */\nNode.prototype.replaceAttribute = function replaceAttribute (curAttribute, newName, newValue) {\n\tif (typeof curAttribute === 'string') {\n\t\tcurAttribute = this.getAttribute(curAttribute);\n\t}\n\n\tvar ix = this._attributes.indexOf(curAttribute);\n\tif (ix !== -1) {\n\t\tthis._attributes.splice(ix, 1, createAttribute(newName, newValue));\n\t}\n};\n\n/**\n\t * Removes attribute with given name\n\t * @param  {String|Attribute} attr Atrtibute name or instance\n\t */\nNode.prototype.removeAttribute = function removeAttribute (attr) {\n\tif (typeof attr === 'string') {\n\t\tattr = this.getAttribute(attr);\n\t}\n\n\tvar ix = this._attributes.indexOf(attr);\n\tif (ix !== -1) {\n\t\tthis._attributes.splice(ix, 1);\n\t}\n};\n\n/**\n\t * Removes all attributes from current node\n\t */\nNode.prototype.clearAttributes = function clearAttributes () {\n\tthis._attributes.length = 0;\n};\n\n/**\n\t * Adds given class name to class attribute\n\t * @param {String} token Class name token\n\t */\nNode.prototype.addClass = function addClass (token) {\n\ttoken = normalize(token);\n\n\tif (!this.hasAttribute('class')) {\n\t\tthis.setAttribute('class', token);\n\t} else if (token && !this.hasClass(token)) {\n\t\tthis.setAttribute('class', this.classList.concat(token).join(' '));\n\t}\n};\n\n/**\n\t * Check if current node contains given class name\n\t * @param {String} token Class name token\n\t * @return {Boolean}\n\t */\nNode.prototype.hasClass = function hasClass (token) {\n\treturn this.classList.indexOf(normalize(token)) !== -1;\n};\n\n/**\n\t * Removes given class name from class attribute\n\t * @param {String} token Class name token\n\t */\nNode.prototype.removeClass = function removeClass (token) {\n\ttoken = normalize(token);\n\tif (this.hasClass(token)) {\n\t\tthis.setAttribute('class', this.classList.filter(function (name) { return name !== token; }).join(' '));\n\t}\n};\n\n/**\n\t * Appends child to current node\n\t * @param {Node} node\n\t */\nNode.prototype.appendChild = function appendChild (node) {\n\tthis.insertAt(node, this.children.length);\n};\n\n/**\n\t * Inserts given `newNode` before `refNode` child node\n\t * @param {Node} newNode\n\t * @param {Node} refNode\n\t */\nNode.prototype.insertBefore = function insertBefore (newNode, refNode) {\n\tthis.insertAt(newNode, this.children.indexOf(refNode));\n};\n\n/**\n\t * Insert given `node` at `pos` position of child list\n\t * @param {Node} node\n\t * @param {Number} pos\n\t */\nNode.prototype.insertAt = function insertAt (node, pos) {\n\tif (pos < 0 || pos > this.children.length) {\n\t\tthrow new Error('Unable to insert node: position is out of child list range');\n\t}\n\n\tvar prev = this.children[pos - 1];\n\tvar next = this.children[pos];\n\n\tnode.remove();\n\tnode.parent = this;\n\tthis.children.splice(pos, 0, node);\n\n\tif (prev) {\n\t\tnode.previous = prev;\n\t\tprev.next = node;\n\t}\n\n\tif (next) {\n\t\tnode.next = next;\n\t\tnext.previous = node;\n\t}\n};\n\n/**\n\t * Removes given child from current node\n\t * @param {Node} node\n\t */\nNode.prototype.removeChild = function removeChild (node) {\n\tvar ix = this.children.indexOf(node);\n\tif (ix !== -1) {\n\t\tthis.children.splice(ix, 1);\n\t\tif (node.previous) {\n\t\t\tnode.previous.next = node.next;\n\t\t}\n\n\t\tif (node.next) {\n\t\t\tnode.next.previous = node.previous;\n\t\t}\n\n\t\tnode.parent = node.next = node.previous = null;\n\t}\n};\n\n/**\n\t * Removes current node from its parent\n\t */\nNode.prototype.remove = function remove () {\n\tif (this.parent) {\n\t\tthis.parent.removeChild(this);\n\t}\n};\n\n/**\n\t * Creates a detached copy of current node\n\t * @param {Boolean} deep Clone node contents as well\n\t * @return {Node}\n\t */\nNode.prototype.clone = function clone (deep) {\n\tvar clone = new Node(this.name);\n\tclone.value = this.value;\n\tclone.selfClosing = this.selfClosing;\n\tif (this.repeat) {\n\t\tclone.repeat = Object.assign({}, this.repeat);\n\t}\n\n\tthis._attributes.forEach(function (attr) { return clone.setAttribute(attr.clone()); });\n\n\tif (deep) {\n\t\tthis.children.forEach(function (child) { return clone.appendChild(child.clone(true)); });\n\t}\n\n\treturn clone;\n};\n\n/**\n\t * Walks on each descendant node and invokes given `fn` function on it.\n\t * The function receives two arguments: the node itself and its depth level\n\t * from current node. If function returns `false`, it stops walking\n\t * @param {Function} fn\n\t */\nNode.prototype.walk = function walk (fn, _level) {\n\t_level = _level || 0;\n\tvar ctx = this.firstChild;\n\n\twhile (ctx) {\n\t\t// in case if context node will be detached during `fn` call\n\t\tvar next = ctx.next;\n\n\t\tif (fn(ctx, _level) === false || ctx.walk(fn, _level + 1) === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\tctx = next;\n\t}\n};\n\n/**\n\t * A helper method for transformation chaining: runs given `fn` function on\n\t * current node and returns the same node\n\t */\nNode.prototype.use = function use (fn) {\n\t\tvar arguments$1 = arguments;\n\n\tvar args = [this];\n\tfor (var i = 1; i < arguments.length; i++) {\n\t\targs.push(arguments$1[i]);\n\t}\n\n\tfn.apply(null, args);\n\treturn this;\n};\n\nNode.prototype.toString = function toString () {\n\t\tvar this$1 = this;\n\n\tvar attrs = this.attributes.map(function (attr) {\n\t\tattr = this$1.getAttribute(attr.name);\n\t\tvar opt = attr.options;\n\t\tvar out = \"\" + (opt && opt.implied ? '!' : '') + (attr.name || '');\n\t\tif (opt && opt.boolean) {\n\t\t\tout += '.';\n\t\t} else if (attr.value != null) {\n\t\t\tout += \"=\\\"\" + (attr.value) + \"\\\"\";\n\t\t}\n\t\treturn out;\n\t});\n\n\tvar out = \"\" + (this.name || '');\n\tif (attrs.length) {\n\t\tout += \"[\" + (attrs.join(' ')) + \"]\";\n\t}\n\n\tif (this.value != null) {\n\t\tout += \"{\" + (this.value) + \"}\";\n\t}\n\n\tif (this.selfClosing) {\n\t\tout += '/';\n\t}\n\n\tif (this.repeat) {\n\t\tout += \"*\" + (this.repeat.count ? this.repeat.count : '');\n\t\tif (this.repeat.value != null) {\n\t\t\tout += \"@\" + (this.repeat.value);\n\t\t}\n\t}\n\n\treturn out;\n};\n\nObject.defineProperties( Node.prototype, prototypeAccessors$1 );\n\n/**\n * Attribute factory\n * @param  {String|Attribute|Object} name  Attribute name or attribute descriptor\n * @param  {*} value Attribute value\n * @return {Attribute}\n */\nfunction createAttribute(name, value) {\n\tif (name instanceof Attribute) {\n\t\treturn name;\n\t}\n\n\tif (typeof name === 'string') {\n\t\treturn new Attribute(name, value);\n\t}\n\n\tif (name && typeof name === 'object') {\n\t\treturn new Attribute(name.name, name.value, name.options);\n\t}\n}\n\n/**\n * @param  {String} str\n * @return {String}\n */\nfunction normalize(str) {\n\treturn String(str).trim();\n}\n\nfunction uniqueClass(item, i, arr) {\n\treturn item && arr.indexOf(item) === i;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nvar StreamReader$1 = function StreamReader(string, start, end) {\n\tif (end == null && typeof string === 'string') {\n\t\tend = string.length;\n\t}\n\n\tthis.string = string;\n\tthis.pos = this.start = start || 0;\n\tthis.end = end;\n};\n\n/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\nStreamReader$1.prototype.eof = function eof () {\n\treturn this.pos >= this.end;\n};\n\n/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * range. E.g. its `eof()` method will look at `end` property, not actual\n\t * stream end\n\t * @param  {Point} start\n\t * @param  {Point} end\n\t * @return {StreamReader}\n\t */\nStreamReader$1.prototype.limit = function limit (start, end) {\n\treturn new this.constructor(this.string, start, end);\n};\n\n/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\nStreamReader$1.prototype.peek = function peek () {\n\treturn this.string.charCodeAt(this.pos);\n};\n\n/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns <code>undefined</code> when no more characters are available.\n\t * @returns {Number}\n\t */\nStreamReader$1.prototype.next = function next () {\n\tif (this.pos < this.string.length) {\n\t\treturn this.string.charCodeAt(this.pos++);\n\t}\n};\n\n/**\n\t * `match` can be a character code or a function that takes a character code\n\t * and returns a boolean. If the next character in the stream 'matches'\n\t * the given argument, it is consumed and returned.\n\t * Otherwise, `false` is returned.\n\t * @param {Number|Function} match\n\t * @returns {Boolean}\n\t */\nStreamReader$1.prototype.eat = function eat (match) {\n\tvar ch = this.peek();\n\tvar ok = typeof match === 'function' ? match(ch) : ch === match;\n\n\tif (ok) {\n\t\tthis.next();\n\t}\n\n\treturn ok;\n};\n\n/**\n\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t * fails. Returns <code>true</code> if any characters were eaten.\n\t * @param {Object} match\n\t * @returns {Boolean}\n\t */\nStreamReader$1.prototype.eatWhile = function eatWhile (match) {\n\tvar start = this.pos;\n\twhile (!this.eof() && this.eat(match)) {}\n\treturn this.pos !== start;\n};\n\n/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\nStreamReader$1.prototype.backUp = function backUp (n) {\n\tthis.pos -= (n || 1);\n};\n\n/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\nStreamReader$1.prototype.current = function current () {\n\treturn this.substring(this.start, this.pos);\n};\n\n/**\n\t * Returns substring for given range\n\t * @param  {Number} start\n\t * @param  {Number} [end]\n\t * @return {String}\n\t */\nStreamReader$1.prototype.substring = function substring (start, end) {\n\treturn this.string.slice(start, end);\n};\n\n/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\nStreamReader$1.prototype.error = function error (message) {\n\tvar err = new Error((message + \" at char \" + (this.pos + 1)));\n\terr.originalMessage = message;\n\terr.pos = this.pos;\n\terr.string = this.string;\n\treturn err;\n};\n\n/**\n * Methods for consuming quoted values\n */\n\nvar SINGLE_QUOTE$1 = 39; // '\nvar DOUBLE_QUOTE$1 = 34; // \"\n\nvar defaultOptions$2 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @param  {Number}  options.escape A character code of quote-escape symbol\n * @param  {Boolean} options.throws Throw error if quotes string cant be properly consumed\n * @return {Boolean} `true` if quoted string was consumed. The contents\n *                   of quoted string will be availabe as `stream.current()`\n */\nvar eatQuoted$1 = function(stream, options) {\n\toptions = options ? Object.assign({}, defaultOptions$2, options) : defaultOptions$2;\n\tvar start = stream.pos;\n\tvar quote = stream.peek();\n\n\tif (stream.eat(isQuote$1)) {\n\t\twhile (!stream.eof()) {\n\t\t\tswitch (stream.next()) {\n\t\t\t\tcase quote:\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\n\t\t\t\tcase options.escape:\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If were here then stream wasnt properly consumed.\n\t\t// Revert stream and decide what to do\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error('Unable to consume quoted string');\n\t\t}\n\t}\n\n\treturn false;\n};\n\nfunction isQuote$1(code) {\n\treturn code === SINGLE_QUOTE$1 || code === DOUBLE_QUOTE$1;\n}\n\n/**\n * Check if given code is a number\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isNumber$1(code) {\n\treturn code > 47 && code < 58;\n}\n\n/**\n * Check if given character code is alpha code (letter through A to Z)\n * @param  {Number}  code\n * @param  {Number}  [from]\n * @param  {Number}  [to]\n * @return {Boolean}\n */\nfunction isAlpha$1(code, from, to) {\n\tfrom = from || 65; // A\n\tto   = to   || 90; // Z\n\tcode &= ~32; // quick hack to convert any char code to uppercase char code\n\n\treturn code >= from && code <= to;\n}\n\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumeric(code) {\n\treturn isNumber$1(code) || isAlpha$1(code);\n}\n\nfunction isWhiteSpace$1(code) {\n\treturn code === 32   /* space */\n\t\t|| code === 9    /* tab */\n\t\t|| code === 160; /* non-breaking space */\n}\n\n/**\n * Check if given character code is a space\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isSpace(code) {\n\treturn isWhiteSpace$1(code)\n\t\t|| code === 10  /* LF */\n\t\t|| code === 13; /* CR */\n}\n\nvar defaultOptions$1$1 = {\n\tescape: 92,   // \\ character\n\tthrows: false\n};\n\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param  {StreamReader} stream\n * @param  {Number} open      Character code of pair openinig\n * @param  {Number} close     Character code of pair closing\n * @param  {Object} [options]\n * @return {Boolean}       Returns `true` if chacarter pair was successfully\n *                         consumed, its content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n\toptions = options ? Object.assign({}, defaultOptions$1$1, options) : defaultOptions$1$1;\n\tvar start = stream.pos;\n\n\tif (stream.eat(open)) {\n\t\tvar stack = 1, ch;\n\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatQuoted$1(stream, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tch = stream.next();\n\t\t\tif (ch === open) {\n\t\t\t\tstack++;\n\t\t\t} else if (ch === close) {\n\t\t\t\tstack--;\n\t\t\t\tif (!stack) {\n\t\t\t\t\tstream.start = start;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (ch === options.escape) {\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\t// If were here then paired character cant be consumed\n\t\tstream.pos = start;\n\n\t\tif (options.throws) {\n\t\t\tthrow stream.error((\"Unable to find matching pair for \" + (String.fromCharCode(open))));\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvar ASTERISK = 42; // *\n\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n * @param  {StringReader} stream\n * @return {Object}\n */\nvar consumeRepeat = function(stream) {\n\tif (stream.eat(ASTERISK)) {\n\t\tstream.start = stream.pos;\n\n\t\t// XXX think about extending repeat syntax with through numbering\n\t\treturn { count: stream.eatWhile(isNumber$1) ? +stream.current() : null };\n\t}\n};\n\nvar opt = { throws: true };\n\n/**\n * Consumes quoted literal from current stream position and returns its inner,\n * unquoted, value\n * @param  {StringReader} stream\n * @return {String} Returns `null` if unable to consume quoted value from current\n * position\n */\nvar consumeQuoted = function(stream) {\n\tif (eatQuoted$1(stream, opt)) {\n\t\treturn stream.current().slice(1, -1);\n\t}\n};\n\nvar LCURLY = 123; // {\nvar RCURLY = 125; // }\n\nvar opt$1 = { throws: true };\n\n/**\n * Consumes text node, e.g. contents of `{...}` and returns its inner value\n * @param  {StringReader} stream\n * @return {String} Consumed text content or `null` otherwise\n */\nvar consumeTextNode = function(stream) {\n\treturn eatPair(stream, LCURLY, RCURLY, opt$1)\n\t\t? stream.current().slice(1, -1)\n\t\t: null;\n};\n\nvar EXCL       = 33; // .\nvar DOT$1        = 46; // .\nvar EQUALS$1     = 61; // =\nvar ATTR_OPEN  = 91; // [\nvar ATTR_CLOSE = 93; // ]\n\nvar reAttributeName = /^\\!?[\\w\\-:\\$@]+\\.?$/;\n\n/**\n * Consumes attributes defined in square braces from given stream.\n * Example:\n * [attr col=3 title=\"Quoted string\" selected. support={react}]\n * @param {StringReader} stream\n * @returns {Array} Array of consumed attributes\n */\nvar consumeAttributes = function(stream) {\n\tif (!stream.eat(ATTR_OPEN)) {\n\t\treturn null;\n\t}\n\n\tvar result = [];\n\tvar token, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace$1);\n\n\t\tif (stream.eat(ATTR_CLOSE)) {\n\t\t\treturn result; // End of attribute set\n\t\t} else if ((token = consumeQuoted(stream)) != null) {\n\t\t\t// Consumed quoted value: anonymous attribute\n\t\t\tresult.push({\n\t\t\t\tname: null,\n\t\t\t\tvalue: token\n\t\t\t});\n\t\t} else if (eatUnquoted(stream)) {\n\t\t\t// Consumed next word: could be either attribute name or unquoted default value\n\t\t\ttoken = stream.current();\n\t\t\tif (!reAttributeName.test(token)) {\n\t\t\t\t// anonymous attribute\n\t\t\t\tresult.push({ name: null, value: token });\n\t\t\t} else {\n\t\t\t\t// Looks like a regular attribute\n\t\t\t\tattr = parseAttributeName(token);\n\t\t\t\tresult.push(attr);\n\n\t\t\t\tif (stream.eat(EQUALS$1)) {\n\t\t\t\t\t// Explicitly defined value. Could be a word, a quoted string\n\t\t\t\t\t// or React-like expression\n\t\t\t\t\tif ((token = consumeQuoted(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t} else if ((token = consumeTextNode(stream)) != null) {\n\t\t\t\t\t\tattr.value = token;\n\t\t\t\t\t\tattr.options = {\n\t\t\t\t\t\t\tbefore: '{',\n\t\t\t\t\t\t\tafter: '}'\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (eatUnquoted(stream)) {\n\t\t\t\t\t\tattr.value = stream.current();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow stream.error('Expected attribute name');\n\t\t}\n\t}\n\n\tthrow stream.error('Expected closing \"]\" brace');\n};\n\nfunction parseAttributeName(name) {\n\tvar options = {};\n\n\t// If a first character in attribute name is `!`  its an implied\n\t// default attribute\n\tif (name.charCodeAt(0) === EXCL) {\n\t\tname = name.slice(1);\n\t\toptions.implied = true;\n\t}\n\n\t// Check for last character: if its a `.`, user wants boolean attribute\n\tif (name.charCodeAt(name.length - 1) === DOT$1) {\n\t\tname = name.slice(0, name.length - 1);\n\t\toptions.boolean = true;\n\t}\n\n\tvar attr = { name: name };\n\tif (Object.keys(options).length) {\n\t\tattr.options = options;\n\t}\n\n\treturn attr;\n}\n\n/**\n * Eats token that can be an unquoted value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean}\n */\nfunction eatUnquoted(stream) {\n\tvar start = stream.pos;\n\tif (stream.eatWhile(isUnquoted)) {\n\t\tstream.start = start;\n\t\treturn true;\n\t}\n}\n\nfunction isUnquoted(code) {\n\treturn !isSpace(code) && !isQuote$1(code)\n\t\t&& code !== ATTR_OPEN && code !== ATTR_CLOSE && code !== EQUALS$1;\n}\n\nvar HASH    = 35; // #\nvar DOT     = 46; // .\nvar SLASH$1   = 47; // /\n\n/**\n * Consumes a single element node from current abbreviation stream\n * @param  {StringReader} stream\n * @return {Node}\n */\nvar consumeElement = function(stream) {\n\t// consume element name, if provided\n\tvar start = stream.pos;\n\tvar node = new Node(eatName(stream));\n\tvar next;\n\n\twhile (!stream.eof()) {\n\t\tif (stream.eat(DOT)) {\n\t\t\tnode.addClass(eatName(stream));\n\t\t} else if (stream.eat(HASH)) {\n\t\t\tnode.setAttribute('id', eatName(stream));\n\t\t} else if (stream.eat(SLASH$1)) {\n\t\t\t// A self-closing indicator must be at the end of non-grouping node\n\t\t\tif (node.isGroup) {\n\t\t\t\tstream.backUp(1);\n\t\t\t\tthrow stream.error('Unexpected self-closing indicator');\n\t\t\t}\n\t\t\tnode.selfClosing = true;\n\t\t\tif (next = consumeRepeat(stream)) {\n\t\t\t\tnode.repeat = next;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (next = consumeAttributes(stream)) {\n\t\t\tfor (var i = 0, il = next.length; i < il; i++) {\n\t\t\t\tnode.setAttribute(next[i]);\n\t\t\t}\n\t\t} else if ((next = consumeTextNode(stream)) !== null) {\n\t\t\tnode.value = next;\n\t\t} else if (next = consumeRepeat(stream)) {\n\t\t\tnode.repeat = next;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === stream.pos) {\n\t\tthrow stream.error((\"Unable to consume abbreviation node, unexpected \" + (stream.peek())));\n\t}\n\n\treturn node;\n};\n\nfunction eatName(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isName);\n\treturn stream.current();\n}\n\nfunction isName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === 45 /* - */\n\t\t|| code === 58 /* : */\n\t\t|| code === 36 /* $ */\n\t\t|| code === 64 /* @ */\n\t\t|| code === 33 /* ! */\n\t\t|| code === 95 /* _ */\n\t\t|| code === 37 /* % */;\n}\n\nvar GROUP_START = 40; // (\nvar GROUP_END   = 41; // )\nvar OP_SIBLING  = 43; // +\nvar OP_CHILD    = 62; // >\nvar OP_CLIMB    = 94; // ^\n\n/**\n * Parses given string into a node tree\n * @param  {String} str Abbreviation to parse\n * @return {Node}\n */\nfunction parse(str) {\n\tvar stream = new StreamReader$1(str.trim());\n\tvar root = new Node();\n\tvar ctx = root, groupStack = [], ch;\n\n\twhile (!stream.eof()) {\n\t\tch = stream.peek();\n\n\t\tif (ch === GROUP_START) { // start of group\n\t\t\t// The grouping node should be detached to properly handle\n\t\t\t// out-of-bounds `^` operator. Node will be attached right on group end\n\t\t\tvar node = new Node();\n\t\t\tvar groupCtx = groupStack.length ? last(groupStack)[0] : ctx;\n\t\t\tgroupStack.push([node, groupCtx, stream.pos]);\n\t\t\tctx = node;\n\t\t\tstream.next();\n\t\t\tcontinue;\n\t\t} else if (ch === GROUP_END) { // end of group\n\t\t\tvar lastGroup = groupStack.pop();\n\t\t\tif (!lastGroup) {\n\t\t\t\tthrow stream.error('Unexpected \")\" group end');\n\t\t\t}\n\n\t\t\tvar node$1 = lastGroup[0];\n\t\t\tctx = lastGroup[1];\n\t\t\tstream.next();\n\n\t\t\t// a group can have a repeater\n\t\t\tif (node$1.repeat = consumeRepeat(stream)) {\n\t\t\t\tctx.appendChild(node$1);\n\t\t\t} else {\n\t\t\t\t// move all children of group into parent node\n\t\t\t\twhile (node$1.firstChild) {\n\t\t\t\t\tctx.appendChild(node$1.firstChild);\n\t\t\t\t}\n\t\t\t\t// for convenience, groups can be joined with optional `+` operator\n\t\t\t\tstream.eat(OP_SIBLING);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar node$2 = consumeElement(stream);\n\t\tctx.appendChild(node$2);\n\n\t\tif (stream.eof()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (stream.peek()) {\n\t\t\tcase OP_SIBLING:\n\t\t\t\tstream.next();\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CHILD:\n\t\t\t\tstream.next();\n\t\t\t\tctx = node$2;\n\t\t\t\tcontinue;\n\n\t\t\tcase OP_CLIMB:\n\t\t\t\t// its perfectly valid to have multiple `^` operators\n\t\t\t\twhile (stream.eat(OP_CLIMB)) {\n\t\t\t\t\tctx = ctx.parent || ctx;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (groupStack.length) {\n\t\tstream.pos = groupStack.pop()[2];\n\t\tthrow stream.error('Expected group close');\n\t}\n\n\treturn root;\n}\n\nfunction last(arr) {\n\treturn arr[arr.length - 1];\n}\n\n/**\n * Parses given abbreviation and un-rolls it into a full tree: recursively\n * replaces repeated elements with actual nodes\n * @param  {String} abbr\n * @return {Node}\n */\nvar index = function(abbr) {\n\tvar tree = parse(abbr);\n\ttree.walk(unroll);\n\treturn tree;\n};\n\nfunction unroll(node) {\n\tif (!node.repeat || !node.repeat.count) {\n\t\treturn;\n\t}\n\n\tfor (var i = 1; i < node.repeat.count; i++) {\n\t\tvar clone = node.clone(true);\n\t\tclone.repeat.value = i;\n\t\tclone.walk(unroll);\n\t\tnode.parent.insertBefore(clone, node);\n\t}\n\n\tnode.repeat.value = node.repeat.count;\n}\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * resolves it into a parsed abbreviation. Resolved node is then updated or\n * replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attribues and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n *\n * @param  {Node} tree                 Parsed Emmet abbreviation\n * @param  {SnippetsRegistry} registry Registry with all available snippets\n * @return {Node} Updated tree\n */\n\nvar index$1 = function(tree, registry) {\n    tree.walk(function (node) { return resolveNode(node, registry); });\n    return tree;\n};\n\nfunction resolveNode(node, registry) {\n    var stack = new Set();\n    var resolve = function (node) {\n        var snippet = registry.resolve(node.name);\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.has(snippet)) {\n            return;\n        }\n\n        // In case if matched snippet is a function, pass control into it\n        if (typeof snippet.value === 'function') {\n            return snippet.value(node, registry, resolve);\n        }\n\n        var tree = index(snippet.value);\n\n        stack.add(snippet);\n        tree.walk(resolve);\n        stack.delete(snippet);\n\n        // move current node contents into new tree\n        var childTarget = findDeepestNode(tree);\n        merge(childTarget, node);\n\n        while (tree.firstChild) {\n            node.parent.insertBefore(tree.firstChild, node);\n        }\n\n        childTarget.parent.insertBefore(node, childTarget);\n        childTarget.remove();\n    };\n\n    resolve(node);\n}\n\n/**\n * Adds data from first node into second node and returns it\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction merge(from, to) {\n    to.name = from.name;\n\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n\n    if (from.value != null) {\n        to.value = from.value;\n    }\n\n    if (from.repeat) {\n        to.repeat = Object.assign({}, from.repeat);\n    }\n\n    return mergeAttributes(from, to);\n}\n\n/**\n * Transfer attributes from first element to second one and preserve first\n * elements attributes order\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeAttributes(from, to) {\n    mergeClassNames(from, to);\n\n    // Its important to preserve attributes order: ones in `from` have higher\n    // pripority than in `to`. Collect attributes in map in order they should\n    // appear in `to`\n    var attrMap = new Map();\n\n    var attrs = from.attributes;\n    for (var i = 0; i < attrs.length; i++) {\n        attrMap.set(attrs[i].name, attrs[i].clone());\n    }\n\n    attrs = to.attributes.slice();\n    for (var i$1 = 0, attr = (void 0), a = (void 0); i$1 < attrs.length; i$1++) {\n        attr = attrs[i$1];\n        if (attrMap.has(attr.name)) {\n            a = attrMap.get(attr.name);\n            a.value = attr.value;\n\n            // If user explicitly wrote attribute in abbreviation, its no longer\n            // implied and should be outputted even if value is empty\n            if (a.options.implied) {\n                a.options.implied = false;\n            }\n        } else {\n            attrMap.set(attr.name, attr);\n        }\n\n        to.removeAttribute(attr);\n    }\n\n    var newAttrs = Array.from(attrMap.values());\n    for (var i$2 = 0; i$2 < newAttrs.length; i$2++) {\n        to.setAttribute(newAttrs[i$2]);\n    }\n\n    return to;\n}\n\n/**\n * Adds class names from first node to second one\n * @param  {Node} from\n * @param  {Node} to\n * @return {Node}\n */\nfunction mergeClassNames(from, to) {\n    var classNames = from.classList;\n    for (var i = 0; i < classNames.length; i++) {\n        to.addClass(classNames[i]);\n    }\n\n    return to;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\nvar inlineElements = new Set('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(','));\nvar elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\n\n/**\n * Returns best child node name for given parent node name\n * @param  {String} parentName Name of parent node\n * @return {String}\n */\nfunction resolveImplicitName(parentName) {\n    parentName = (parentName || '').toLowerCase();\n    return elementMap[parentName]\n        || (inlineElements.has(parentName) ? 'span' : 'div');\n}\n\n/**\n * Adds missing tag names for given tree depending on nodes parent name\n */\nvar implicitTags = function(tree) {\n    tree.walk(function (node) {\n        // resolve only nameless nodes without content\n        if (node.name == null && node.attributes.length) {\n            node.name = resolveImplicitName(node.parent.name);\n        }\n    });\n    return tree;\n};\n\n/**\n * Locates all occurances of given `token` which are not escaped (e.g. are not\n * preceded with `\\`) given in `str`\n * @param  {String} str\n * @return {Array}  Array of token ranges\n */\nfunction findUnescapedTokens(str, token) {\n    var result = new Set();\n    var tlen = token.length;\n\n    // 1. Find all occurances of tokens\n    var pos = 0;\n    while ((pos = str.indexOf(token, pos)) !== -1) {\n        result.add(pos);\n        pos += tlen;\n    }\n\n    if (result.size) {\n        // 2. Remove ones that escaped\n        var pos$1 = 0;\n        var len = str.length;\n\n        while (pos$1 < len) {\n            if (str[pos$1++] === '\\\\') {\n                result.delete(pos$1++);\n            }\n        }\n    }\n\n    return Array.from(result).map(function (ix) { return range$1(ix, tlen); });\n}\n\n/**\n * Replaces `ranges`, generated by `range()` function, with given `value` in `str`\n * @param  {String} str    Where to replace ranges\n * @param  {Array} ranges Ranes, created by `range()` function\n * @param  {String|Function} value  Replacement value. If its a function, it\n * will take a range value as argument and should return a new string\n * @return {String}\n */\nfunction replaceRanges(str, ranges, value) {\n\t// should walk from the end of array to keep ranges valid after replacement\n\tfor (var i = ranges.length - 1; i >= 0; i--) {\n\t\tvar r = ranges[i];\n\n\t\tstr = str.substring(0, r[0])\n\t\t\t+ (typeof value === 'function' ? value(str.substr(r[0], r[1])) : value)\n\t\t\t+ str.substring(r[0] + r[1]);\n\t}\n\n\treturn str;\n}\n\nfunction range$1(start, length) {\n    return [start, length];\n}\n\nvar numberingToken = '$';\n\n/**\n * Numbering of expanded abbreviation: finds all nodes with `$` in value\n * or attributes and replaces its occurances with repeater value\n */\nvar applyNumbering = function(tree) {\n    tree.walk(applyNumbering$1);\n    return tree;\n};\n\n/**\n * Applies numbering for given node: replaces occurances of numbering token\n * in nodes name, content and attributes\n * @param  {Node} node\n * @return {Node}\n */\nfunction applyNumbering$1(node) {\n    var repeater = findRepeater(node);\n\n    if (repeater && repeater.value != null) {\n        // NB replace numbering in nodes with explicit repeater only:\n        // it solves issues with abbreviations like `xsl:if[test=$foo]` where\n        // `$foo` is preferred output\n        var value = repeater.value;\n\n        node.name = replaceNumbering(node.name, value);\n        node.value = replaceNumbering(node.value, value);\n        node.attributes.forEach(function (attr) {\n            var copy = node.getAttribute(attr.name).clone();\n            copy.name = replaceNumbering(attr.name, value);\n            copy.value = replaceNumbering(attr.value, value);\n            node.replaceAttribute(attr.name, copy);\n        });\n    }\n\n    return node;\n}\n\n/**\n * Returns repeater object for given node\n * @param  {Node} node\n * @return {Object}\n */\nfunction findRepeater(node) {\n    while (node) {\n        if (node.repeat) {\n            return node.repeat;\n        }\n\n        node = node.parent;\n    }\n}\n\n/**\n * Replaces numbering in given string\n * @param  {String} str\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumbering(str, value) {\n    // replace numbering in strings only: skip explicit wrappers that could\n    // contain unescaped numbering tokens\n    if (typeof str === 'string') {\n        var ranges = getNumberingRanges(str);\n        return replaceNumberingRanges(str, ranges, value);\n    }\n\n    return str;\n}\n\n/**\n * Returns numbering ranges, e.g. ranges of `$` occurances, in given string.\n * Multiple adjacent ranges are combined\n * @param  {String} str\n * @return {Array}\n */\nfunction getNumberingRanges(str) {\n    return findUnescapedTokens(str || '', numberingToken)\n    .reduce(function (out, range$$1) {\n        // skip ranges that actually belongs to output placeholder or tabstops\n        if (!/[#{]/.test(str[range$$1[0] + 1] || '')) {\n            var lastRange = out[out.length - 1];\n            if (lastRange && lastRange[0] + lastRange[1] === range$$1[0]) {\n                lastRange[1] += range$$1[1];\n            } else {\n                out.push(range$$1);\n            }\n        }\n\n        return out;\n    }, []);\n}\n\n/**\n * @param  {String} str\n * @param  {Array} ranges\n * @param  {Number} value\n * @return {String}\n */\nfunction replaceNumberingRanges(str, ranges, value) {\n    var replaced = replaceRanges(str, ranges, function (token) {\n        var _value = String(value);\n        // pad values for multiple numbering tokens, e.g. 3 for $$$ becomes 003\n        while (_value.length < token.length) {\n            _value = '0' + _value;\n        }\n        return _value;\n    });\n\n    // unescape screened numbering tokens\n    return unescapeString(replaced);\n}\n\n/**\n * Unescapes characters, screened with `\\`, in given string\n * @param  {String} str\n * @return {String}\n */\nfunction unescapeString(str) {\n    var i = 0, result = '';\n    var len = str.length;\n\n    while (i < len) {\n        var ch = str[i++];\n        result += (ch === '\\\\') ? (str[i++] || '') : ch;\n    }\n\n    return result;\n}\n\n/** Placeholder for inserted content */\nvar placeholder = '$#';\n\n/** Placeholder for caret */\nvar caret = '|';\n\nvar reUrl = /^((?:https?|ftp|file):\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\nvar reEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/;\nvar reProto = /^([a-z]+:)?\\/\\//i;\n\n/**\n * Inserts content into node with implicit repeat count: this node is then\n * duplicated for each content item and content itself is inserted either into\n * deepest child or instead of a special token.\n *\n * This method uses two distinct steps: `prepare()` and `insert()` since most\n * likely these steps will be used separately to properly insert content\n * with unescaped `$` numbering markers.\n *\n * @param {Node} tree Parsed abbreviation\n * @param {String[]} content Array of content items to insert\n * @return {Node}\n */\n/**\n * Finds nodes with implicit repeat and creates `amount` copies of it in tree\n * @param  {Node} tree\n * @param  {Number} amount\n * @return {Node}\n */\nfunction prepare(tree, amount) {\n    amount = amount || 1;\n    tree.walk(function (node) {\n        if (node.repeat && node.repeat.count === null) {\n            for (var i = 0; i < amount; i++) {\n                var clone = node.clone(true);\n                clone.repeat.implicit = true;\n                clone.repeat.count = amount;\n                clone.repeat.value = i + 1;\n                clone.repeat.index = i;\n                node.parent.insertBefore(clone, node);\n            }\n\n            node.remove();\n        }\n    });\n\n    return tree;\n}\n\n/**\n * Inserts content into implicitly repeated nodes, created by `prepare()` method\n * @param  {Node} tree\n * @param  {String[]} content\n * @return {Node}\n */\nfunction insert(tree, content) {\n    if (Array.isArray(content) && content.length) {\n        var updated = false;\n        tree.walk(function (node) {\n            if (node.repeat && node.repeat.implicit) {\n                updated = true;\n                insertContent(node, content[node.repeat.index]);\n            }\n        });\n\n        if (!updated) {\n            // no node with implicit repeat was found, insert content as\n            // deepest child\n            setNodeContent(findDeepestNode$1(tree), content.join('\\n'));\n        }\n    }\n\n    return tree;\n}\n\n/**\n * Inserts `content` into given `node`: either replaces output placeholders\n * or inserts it into deepest child node\n * @param  {Node} node\n * @param  {String} content\n * @return {Node}\n */\nfunction insertContent(node, content) {\n\tvar inserted = insertContentIntoPlaceholder(node, content);\n\tnode.walk(function (child) { return inserted |= insertContentIntoPlaceholder(child, content); });\n\n\tif (!inserted) {\n\t\t// no placeholders were found in node, insert content into deepest child\n\t\tsetNodeContent(findDeepestNode$1(node), content);\n\t}\n\n\treturn node;\n}\n\n/**\n * Inserts given `content` into placeholders for given `node`. Placeholders\n * might be available in attribute values and node content\n * @param  {Node} node\n * @param  {String} content\n * @return {Boolean} Returns `true` if placeholders were found and replaced in node\n */\nfunction insertContentIntoPlaceholder(node, content) {\n\tvar state = {replaced: false};\n\n\tnode.value = replacePlaceholder(node.value, content, state);\n\tnode.attributes.forEach(function (attr) {\n\t\tif (attr.value) {\n\t\t\tnode.setAttribute(attr.name, replacePlaceholder(attr.value, content, state));\n\t\t}\n\t});\n\n\treturn state.replaced;\n}\n\n/**\n * Replaces all placeholder occurances in given `str` with `value`\n * @param  {String} str\n * @param  {String} value\n * @param  {Object} [_state] If provided, set `replaced` property of given\n * object to `true` if placeholder was found and replaced\n * @return {String}\n */\nfunction replacePlaceholder(str, value, _state) {\n\tif (typeof str === 'string') {\n\t\tvar ranges = findUnescapedTokens(str, placeholder);\n\t\tif (ranges.length) {\n\t\t\tif (_state) {\n\t\t\t\t_state.replaced = true;\n\t\t\t}\n\n\t\t\tstr = replaceRanges(str, ranges, value);\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * Finds node which is the deepest for in current node or node iteself.\n * @param  {Node} node\n * @return {Node}\n */\nfunction findDeepestNode$1(node) {\n\twhile (node.children.length) {\n\t\tnode = node.children[node.children.length - 1];\n\t}\n\n\treturn node;\n}\n\n/**\n * Updates content of given node\n * @param {Node} node\n * @param {String} content\n */\nfunction setNodeContent(node, content) {\n\t// find caret position and replace it with content, if possible\n\tif (node.value) {\n\t\tvar ranges = findUnescapedTokens(node.value, caret);\n\t\tif (ranges.length) {\n\t\t\tnode.value = replaceRanges(node.value, ranges, content);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (node.name.toLowerCase('a') || node.hasAttribute('href')) {\n\t\t// special case: inserting content into `<a>` tag\n\t\tif (reUrl.test(content)) {\n\t\t\tnode.setAttribute('href', (reProto.test(content) ? '' : 'http://') + content);\n\t\t} else if (reEmail.test(content)) {\n\t\t\tnode.setAttribute('href', 'mailto:' + content);\n\t\t}\n\t}\n\n\tnode.value = content;\n}\n\nvar defaultOptions$3 = {\n\telement: '__',\n\tmodifier: '_'\n};\n\nvar reElement  = /^(-+)([a-z0-9]+)/i;\nvar reModifier = /^(_+)([a-z0-9]+)/i;\nvar blockCandidates1 = function (className) { return /^[a-z]\\-/i.test(className); };\nvar blockCandidates2 = function (className) { return /^[a-z]/i.test(className); };\n\n/**\n * BEM transformer: updates class names written as `-element` and\n * `_modifier` into full class names as described in BEM specs. Also adds missing\n * class names: fir example, if node contains `.block_modifier` class, ensures\n * that element contains `.block` class as well\n */\nvar bem = function(tree, options) {\n\toptions = Object.assign({}, defaultOptions$3, options);\n\n\ttree.walk(function (node) { return expandClassNames(node, options); });\n\n\tvar lookup = createBlockLookup(tree);\n    tree.walk(function (node) { return expandShortNotation(node, lookup, options); });\n\n\treturn tree;\n};\n\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n * @param  {Node} node\n * @param  {Object} options\n * @return {Set}\n */\nfunction expandClassNames(node, options) {\n\tvar classNames = node.classList.reduce(function (out, cl) {\n\t\t// remove all modifiers from class name to get a base element name\n\t\tvar ix = cl.indexOf(options.modifier);\n\t\tif (ix !== -1) {\n\t\t\tout.add(cl.slice(0, ix));\n\t\t}\n\n\t\treturn out.add(cl);\n\t}, new Set());\n\n\tif (classNames.size) {\n\t\tnode.setAttribute('class', Array.from(classNames).join(' '));\n\t}\n}\n\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n * @param  {Node} node      Parsed Emmet abbreviation node\n * @param  {Map} lookup     BEM block name lookup\n * @param  {Object} options\n */\nfunction expandShortNotation(node, lookup, options) {\n\tvar classNames = node.classList.reduce(function (out, cl) {\n\t\tvar prefix, m;\n\t\tvar originalClass = cl;\n\n\t\t// parse element definition (could be only one)\n\t\tif (m = cl.match(reElement)) {\n\t\t\tprefix = getBlockName(node, lookup, m[1]) + options.element + m[2];\n\t\t\tout.add(prefix);\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\t// parse modifiers definitions (may contain multiple)\n\t\twhile (m = cl.match(reModifier)) {\n\t\t\tif (!prefix) {\n\t\t\t\tprefix = getBlockName(node, lookup, m[1]);\n\t\t\t\tout.add(prefix);\n\t\t\t}\n\n\t\t\tout.add((\"\" + prefix + (options.modifier) + (m[2])));\n\t\t\tcl = cl.slice(m[0].length);\n\t\t}\n\n\t\tif (cl === originalClass) {\n\t\t\t// class name wasnt modified: its not a BEM-specific class,\n\t\t\t// add it as-is into output\n\t\t\tout.add(originalClass);\n\t\t}\n\n\t\treturn out;\n\t}, new Set());\n\n\tnode.setAttribute('class', Array.from(classNames).join(' '));\n}\n\n/**\n * Creates block name lookup for each node in given tree, e.g. finds block\n * name explicitly for each node\n * @param  {Node} tree\n * @return {Map}\n */\nfunction createBlockLookup(tree) {\n\tvar lookup = new Map();\n\n\ttree.walk(function (node) {\n\t\tvar classNames = node.classList;\n\t\tif (classNames.length) {\n\t\t\t// guess best block name from class or use parents block name\n\t\t\tlookup.set(node,\n\t\t\t\tfind(classNames, blockCandidates1)\n\t\t\t\t|| find(classNames, blockCandidates2)\n\t\t\t\t|| lookup.get(node.parent)\n\t\t\t);\n\t\t}\n\t});\n\n\treturn lookup;\n}\n\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n * @param  {Node} node\n * @param  {Map} lookup\n * @param  {String} prefix\n * @return {String}\n */\nfunction getBlockName(node, lookup, prefix) {\n\tvar depth = prefix.length > 1 ? prefix.length : 0;\n\twhile (node.parent && depth--) {\n\t\tnode = node.parent;\n\t}\n\n\treturn lookup.get(node);\n}\n\nfunction find(arr, filter) {\n\treturn arr.filter(filter)[0];\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nvar jsx = function(tree) {\n\ttree.walk(function (node) {\n\t\treplace(node, 'class', 'className');\n\t\treplace(node, 'for', 'htmlFor');\n\t});\n\treturn tree;\n};\n\nfunction replace(node, oldName, newName) {\n\tvar attr = node.getAttribute(oldName);\n\tif (attr) {\n\t\tattr.name = newName;\n\t}\n}\n\nvar reSupporterNames = /^xsl:(variable|with\\-param)$/i;\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nvar xsl = function(tree) {\n\ttree.walk(function (node) {\n\t\tif (reSupporterNames.test(node.name || '') && (node.children.length || node.value)) {\n\t\t\tnode.removeAttribute('select');\n\t\t}\n\t});\n\treturn tree;\n};\n\nvar supportedAddons = { bem: bem, jsx: jsx, xsl: xsl };\n\n/**\n * Runs additional transforms on given tree.\n * These transforms may introduce side-effects and unexpected result\n * so they are not applied by default, authors must specify which addons\n * in `addons` argument as `{addonName: addonOptions}`\n * @param {Node} tree Parsed Emmet abbreviation\n * @param {Object} addons Add-ons to apply and their options\n */\nvar addons = function(tree, addons) {\n    Object.keys(addons || {}).forEach(function (key) {\n        if (key in supportedAddons) {\n            var addonOpt = typeof addons[key] === 'object' ? addons[key] : null;\n            tree = tree.use(supportedAddons[key], addonOpt);\n        }\n    });\n\n    return tree;\n};\n\n/**\n * Applies basic HTML-specific transformations for given parsed abbreviation:\n *  resolve implied tag names\n *  insert repeated content\n *  resolve node numbering\n */\nvar index$2 = function(tree, content, appliedAddons) {\n    if (typeof content === 'string') {\n        content = [content];\n    } else if (content && typeof content === 'object' && !Array.isArray(content)) {\n        appliedAddons = content;\n        content = null;\n    }\n\n    return tree\n    .use(implicitTags)\n    .use(prepare, Array.isArray(content) ? content.length : null)\n    .use(applyNumbering)\n    .use(insert, content)\n    .use(addons, appliedAddons);\n};\n\n/**\n * Replaces all unescaped ${variable} occurances in given parsed abbreviation\n * `tree` with values provided in `variables` hash. Precede `$` with `\\` to\n * escape it and skip replacement\n * @param {Node} tree Parsed abbreviation tree\n * @param {Object} variables Variables values\n * @return {Node}\n */\nfunction replaceVariables(tree, variables) {\n\tvariables = variables || {};\n    tree.walk(function (node) { return replaceInNode(node, variables); });\n    return tree;\n}\n\nfunction replaceInNode(node, variables) {\n    // Replace variables in attributes.\n    var attrs = node.attributes;\n\n    for (var i = 0, il = attrs.length; i < il; i++) {\n        var attr = attrs[i];\n        if (typeof attr.value === 'string') {\n            node.setAttribute(attr.name, replaceInString(attr.value, variables));\n        }\n    }\n\n    if (node.value != null) {\n        node.value = replaceInString(node.value, variables);\n    }\n\n    return node;\n}\n\n/**\n * Replaces all unescaped `${variable}` occurances in given string with values\n * from `variables` object\n * @param  {String} string\n * @param  {Object} variables\n * @return {String}\n */\nfunction replaceInString(string, variables) {\n    var model = createModel(string);\n    var offset = 0;\n    var output = '';\n\n    for (var i = 0, il = model.variables.length; i < il; i++) {\n        var v = model.variables[i];\n        var value = v.name in variables ? variables[v.name] : v.name;\n        if (typeof value === 'function') {\n            value = value(model.string, v, offset + v.location);\n        }\n\n        output += model.string.slice(offset, v.location) + value;\n        offset = v.location + v.length;\n    }\n\n    return output + model.string.slice(offset);\n}\n\n/**\n * Creates variable model from given string. The model contains a `string` with\n * all escaped variable tokens written without escape symbol and `variables`\n * property with all unescaped variables and their ranges\n * @param  {String} string\n * @return {Object}\n */\nfunction createModel(string) {\n    var reVariable = /\\$\\{([a-z][\\w\\-]*)\\}/ig;\n    var escapeCharCode = 92; // `\\` symbol\n    var variables = [];\n\n    // We have to replace unescaped (e.g. not preceded with `\\`) tokens.\n    // Instead of writing a stream parser, well cut some edges here:\n    // 1. Find all tokens\n    // 2. Walk string char-by-char and resolve only tokens that are not escaped\n    var tokens = new Map();\n    var m;\n    while (m = reVariable.exec(string)) {\n        tokens.set(m.index, m);\n    }\n\n    if (tokens.size) {\n        var start = 0, pos = 0, len = string.length;\n        var output = '';\n        while (pos < len) {\n            if (string.charCodeAt(pos) === escapeCharCode && tokens.has(pos + 1)) {\n                // Found escape symbol that escapes variable: we should\n                // omit this symbol in output string and skip variable\n                var token = tokens.get(pos + 1);\n                output += string.slice(start, pos) + token[0];\n                start = pos = token.index + token[0].length;\n                tokens.delete(pos + 1);\n                continue;\n            }\n\n            pos++;\n        }\n\n        string = output + string.slice(start);\n\n        // Not using `.map()` here to reduce memory allocations\n        var validMatches = Array.from(tokens.values());\n        for (var i = 0, il = validMatches.length; i < il; i++) {\n            var token$1 = validMatches[i];\n            variables.push({\n                name: token$1[1],\n                location: token$1.index,\n                length: token$1[0].length\n            });\n        }\n    }\n\n    return {string: string, variables: variables};\n}\n\nvar DOLLAR      = 36;  // $\nvar COLON$1       = 58;  // :\nvar ESCAPE$1      = 92;  // \\\nvar OPEN_BRACE  = 123; // {\nvar CLOSE_BRACE = 125; // }\n\n/**\n * Finds fields in given string and returns object with field-less string\n * and array of fileds found\n * @param  {String} string\n * @return {Object}\n */\nfunction parse$2$1(string) {\n\tvar stream = new StreamReader$1(string);\n\tvar fields = [];\n\tvar cleanString = '', offset = 0, pos = 0;\n\tvar code, field;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\t\tpos = stream.pos;\n\n\t\tif (code === ESCAPE$1) {\n\t\t\tstream.next();\n\t\t\tstream.next();\n\t\t} else if (field = consumeField(stream, cleanString.length + pos - offset)) {\n\t\t\tfields.push(field);\n\t\t\tcleanString += stream.string.slice(offset, pos) + field.placeholder;\n\t\t\toffset = stream.pos;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn new FieldString(cleanString + stream.string.slice(offset), fields);\n}\n\n/**\n * Marks given `string` with `fields`: wraps each field range with\n * `${index:placeholder}` (by default) or any other token produced by `token`\n * function, if provided\n * @param  {String} string String to mark\n * @param  {Array} fields Array of field descriptor. A field descriptor is a\n * `{index, location, length}` array. It is important that fields in array\n * must be ordered by their location in string: some fields my refer the same\n * location so they must appear in order that user expects.\n * @param  {Function} [token] Function that generates field token. This function\n * received two arguments: `index` and `placeholder` and should return string\n * @return {String}  String with marked fields\n */\nfunction mark(string, fields, token) {\n\ttoken = token || createToken;\n\n\t// order fields by their location and appearence\n\t// NB field ranges should not overlap! (not supported yet)\n\tvar ordered = fields\n\t.map(function (field, order) { return ({order: order, field: field, end: field.location + field.length}); })\n\t.sort(function (a, b) { return (a.end - b.end) || (a.order - b.order); });\n\n\t// mark ranges in string\n\tvar offset = 0;\n\tvar result = ordered.map(function (item) {\n\t\tvar placeholder = string.substr(item.field.location, item.field.length);\n\t\tvar prefix = string.slice(offset, item.field.location);\n\t\toffset = item.end;\n\t\treturn prefix + token(item.field.index, placeholder);\n\t});\n\n\treturn result.join('') + string.slice(offset);\n}\n\n/**\n * Creates field token for string\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, could be empty string\n * @return {String}\n */\nfunction createToken(index, placeholder) {\n\treturn placeholder ? (\"${\" + index + \":\" + placeholder + \"}\") : (\"${\" + index + \"}\");\n}\n\n/**\n * Consumes field from current stream position: it can be an `$index` or\n * or `${index}` or `${index:placeholder}`\n * @param  {StreamReader} stream\n * @param  {Number}       location Field location in *clean* string\n * @return {Object} Object with `index` and `placeholder` properties if\n * fieald was successfully consumed, `null` otherwise\n */\nfunction consumeField(stream, location) {\n\tvar start = stream.pos;\n\n\tif (stream.eat(DOLLAR)) {\n\t\t// Possible start of field\n\t\tvar index = consumeIndex(stream);\n\t\tvar placeholder = '';\n\n\t\t// consumed $index placeholder\n\t\tif (index != null) {\n\t\t\treturn new Field(index, placeholder, location);\n\t\t}\n\n\t\tif (stream.eat(OPEN_BRACE)) {\n\t\t\tindex = consumeIndex(stream);\n\t\t\tif (index != null) {\n\t\t\t\tif (stream.eat(COLON$1)) {\n\t\t\t\t\tplaceholder = consumePlaceholder(stream);\n\t\t\t\t}\n\n\t\t\t\tif (stream.eat(CLOSE_BRACE)) {\n\t\t\t\t\treturn new Field(index, placeholder, location);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we reached here then theres no valid field here, revert\n\t// back to starting position\n\tstream.pos = start;\n}\n\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumePlaceholder(stream) {\n\tvar code;\n\tvar stack = [];\n\tstream.start = stream.pos;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\tif (code === OPEN_BRACE) {\n\t\t\tstack.push(stream.pos);\n\t\t} else if (code === CLOSE_BRACE) {\n\t\t\tif (!stack.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t\tstream.next();\n\t}\n\n\tif (stack.length) {\n\t\tthrow stream.error('Unable to find matching \"}\" for curly brace at ' + stack.pop());\n\t}\n\n\treturn stream.current();\n}\n\n/**\n * Consumes integer from current stream position\n * @param  {StreamReader} stream\n * @return {Number}\n */\nfunction consumeIndex(stream) {\n\tstream.start = stream.pos;\n\tif (stream.eatWhile(isNumber$1)) {\n\t\treturn Number(stream.current());\n\t}\n}\n\nvar Field = function Field(index, placeholder, location) {\n\tthis.index = index;\n\tthis.placeholder = placeholder;\n\tthis.location = location;\n\tthis.length = this.placeholder.length;\n};\n\nvar FieldString = function FieldString(string, fields) {\n\tthis.string = string;\n\tthis.fields = fields;\n};\n\nFieldString.prototype.mark = function mark$1 (token) {\n\treturn mark(this.string, this.fields, token);\n};\n\nFieldString.prototype.toString = function toString () {\n\treturn string;\n};\n\nvar defaultFieldsRenderer = function (text) { return text; };\n\n/**\n * Output node is an object containing generated output for given Emmet\n * abbreviation node. Output node can be passed to various processors that\n * may shape-up final node output. The final output is simply a concatenation\n * of `.open`, `.text` and `.close` properties and its `.before*` and `.after*`\n * satellites\n * @param {Node}     node           Parsed Emmet abbreviation node\n * @param {Function} fieldsRenderer A function for rendering fielded text (text with\n * tabstops) for current node. @see ./render.js for details\n */\nvar OutputNode = function OutputNode(node, fieldsRenderer, options) {\n\tif (typeof fieldsRenderer === 'object') {\n\t\toptions = fieldsRenderer;\n\t\tfieldsRenderer = null;\n\t}\n\n\tthis.node = node;\n\tthis._fieldsRenderer = fieldsRenderer || defaultFieldsRenderer;\n\n\tthis.open = null;\n\tthis.beforeOpen = '';\n\tthis.afterOpen = '';\n\n\tthis.close = null;\n\tthis.beforeClose = '';\n\tthis.afterClose = '';\n\n\tthis.text = null;\n\tthis.beforeText = '';\n\tthis.afterText = '';\n\n\tthis.indent = '';\n\tthis.newline = '';\n\n\tif (options) {\n            Object.assign(this, options);\n        }\n};\n\nOutputNode.prototype.clone = function clone () {\n\treturn new this.constructor(this.node, this);\n};\n\n/**\n\t * Properly indents given multiline text\n\t * @param {String} text\n\t */\nOutputNode.prototype.indentText = function indentText (text) {\n\t\tvar this$1 = this;\n\n\tvar lines = splitByLines$2(text);\n        if (lines.length === 1) {\n            // no newlines, nothing to indent\n            return text;\n        }\n\n        // No newline and no indent means no formatting at all:\n        // in this case we should replace newlines with spaces\n        var nl = (!this.newline && !this.indent) ? ' ' : this.newline;\n        return lines.map(function (line, i) { return i ? this$1.indent + line : line; }).join(nl);\n};\n\n/**\n\t * Renders given text with fields\n\t * @param {String} text\n\t * @return {String}\n\t */\nOutputNode.prototype.renderFields = function renderFields (text) {\n\treturn this._fieldsRenderer(text);\n};\n\nOutputNode.prototype.toString = function toString (children) {\n\tvar open = this._wrap(this.open, this.beforeOpen, this.afterOpen);\n\tvar close = this._wrap(this.close, this.beforeClose, this.afterClose);\n\tvar text = this._wrap(this.text, this.beforeText, this.afterText);\n\n\treturn open + text + (children != null ? children : '') + close;\n};\n\nOutputNode.prototype._wrap = function _wrap (str, before, after) {\n\tbefore = before != null ? before : '';\n\tafter = after != null ? after : '';\n\n        // automatically trim whitespace for non-empty wraps\n        if (str != null) {\n            str = before ? str.replace(/^\\s+/, '') : str;\n            str = after ? str.replace(/\\s+$/, '') : str;\n            return before + this.indentText(str) + after;\n        }\n\n        return '';\n};\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines$2(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Default output of field (tabstop)\n * @param  {Number} index       Field index\n * @param  {String} placeholder Field placeholder, can be null\n * @return {String}\n */\nvar defaultField = function (index, placeholder) { return (placeholder || ''); };\n\n/**\n * Renders given parsed abbreviation `tree` via `formatter` function.\n\n * @param {Node}     tree      Parsed Emmet abbreviation\n * @param {Function} [field]   Optional function to format field/tabstop (@see `defaultField`)\n * @param {Function} formatter Output formatter function. It takes an output node\n * a special wrapper for parsed node that holds formatting and output properties\n * and updates its output properties to shape-up nodes output.\n * Function arguments:\n * \t `outNode`: OutputNode\n * \t `renderFields`: a helper function that parses fields/tabstops from given\n * \t   text and replaces them with `field` function output.\n * \t   It also takes care about field indicies and ensures that the same indicies\n * \t   from different nodes wont collide\n */\nfunction render(tree, field, formatter) {\n    if (typeof formatter === 'undefined') {\n        formatter = field;\n        field = null;\n    }\n\n    field = field || defaultField;\n\n    // Each node may contain fields like `${1:placeholder}`.\n\t// Since most modern editors will link all fields with the same\n\t// index, we have to ensure that different nodes has their own indicies.\n\t// Well use this `fieldState` object to globally increment field indices\n\t// during output\n\tvar fieldState = { index: 1 };\n\n    var fieldsRenderer = function (text) { return text == null\n        ? field(fieldState.index++)\n        : getFieldsModel(text, fieldState).mark(field); };\n\n\treturn run(tree.children, formatter, fieldsRenderer);\n}\n\nfunction run(nodes, formatter, fieldsRenderer) {\n\treturn nodes.filter(notGroup).map(function (node) {\n\t\tvar outNode = formatter(new OutputNode(node, fieldsRenderer));\n\t\treturn outNode ? outNode.toString(run(node.children, formatter, fieldsRenderer)) : '';\n\t}).join('');\n}\n\nfunction notGroup(node) {\n    return !node.isGroup;\n}\n\n/**\n * Returns fields (tab-stops) model with properly updated indices that wont\n * collide with fields in other nodes of foprmatted tree\n * @param  {String|Object} text Text to get fields model from or model itself\n * @param  {Object} fieldState Abbreviation tree-wide field state reference\n * @return {Object} Field model\n */\nfunction getFieldsModel(text, fieldState) {\n\tvar model = typeof text === 'object' ? text : parse$2$1(text);\n    var largestIndex = -1;\n\n    model.fields.forEach(function (field) {\n\t\tfield.index += fieldState.index;\n\t\tif (field.index > largestIndex) {\n\t\t\tlargestIndex = field.index;\n\t\t}\n\t});\n\n\tif (largestIndex !== -1) {\n\t\tfieldState.index = largestIndex + 1;\n\t}\n\n    return model;\n}\n\nvar TOKEN       = /^(.*?)([A-Z_]+)(.*?)$/;\nvar TOKEN_OPEN  = 91; // [\nvar TOKEN_CLOSE = 93; // ]\n\n/**\n * A basic templating engine.\n * Takes every `[TOKEN]` from given string and replaces it with\n * `TOKEN` value from given `data` attribute. The token itself may contain\n * various characters between `[`, token name and `]`. Contents of `[...]` will\n * be outputted only if `TOKEN` value is not empty. Also, only `TOKEN` name will\n * be replaced with actual value, all other characters will remain as is.\n *\n * Example:\n * ```\n * template('[<NAME>]', {NAME: 'foo'}) -> \"<foo>\"\n * template('[<NAME>]', {}) -> \"\"\n * ```\n */\nfunction template(str, data) {\n\tif (str == null) {\n\t\treturn str;\n\t}\n\n\t// NB since token may contain inner `[` and `]`, we cant just use regexp\n\t// for replacement, should manually parse string instead\n\tvar stack = [];\n\tvar replacer = function (str, left, token, right) { return data[token] != null ? left + data[token] + right : ''; };\n\n\tvar output = '';\n\tvar offset = 0, i = 0;\n\tvar code, lastPos;\n\n\twhile (i < str.length) {\n\t\tcode = str.charCodeAt(i);\n\t\tif (code === TOKEN_OPEN) {\n\t\t\tstack.push(i);\n\t\t} else if (code === TOKEN_CLOSE) {\n\t\t\tlastPos = stack.pop();\n\t\t\tif (!stack.length) {\n\t\t\t\toutput += str.slice(offset, lastPos) +\n\t\t\t\t\tstr.slice(lastPos + 1, i).replace(TOKEN, replacer);\n\t\t\t\toffset = i + 1;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn output + str.slice(offset);\n}\n\n/**\n * Various utility methods used by formatters\n */\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]}\n */\nfunction splitByLines$1(text) {\n\treturn (text || '').split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Check if given node is a first child in its parent\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isFirstChild(node) {\n\treturn node.parent.firstChild === node;\n}\n\n/**\n * Check if given node is a last child in its parent node\n * @param  {Node}  node\n * @return {Boolean}\n */\n\n\n/**\n * Check if given node is a root node\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRoot(node) {\n\treturn node && !node.parent;\n}\n\n/**\n * Check if given node is a pseudo-snippet: a text-only node with explicitly\n * defined children\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isPseudoSnippet(node) {\n    return node.isTextOnly && !!node.children.length;\n}\n\n/**\n * Handles pseudo-snippet node.\n * A pseudo-snippet is a text-only node with explicitly defined children.\n * For such case, we have to figure out if pseudo-snippet contains fields\n * (tab-stops) in node value and split it: make contents before field with\n * lowest index nodes open part and contents after lowest index  close\n * part. With this trick a final output will look like nodes children\n * are nested inside node value\n * @param  {OutputNode} outNode\n * @return {Boolean} Returns true if given node is a pseudo-snippets,\n * `false` otherwise\n */\nfunction handlePseudoSnippet(outNode) {\n\tvar node = outNode.node; // original abbreviaiton node\n\n\tif (isPseudoSnippet(node)) {\n\t\tvar fieldsModel = parse$2$1(node.value);\n\t\tvar field = findLowestIndexField(fieldsModel);\n\t\tif (field) {\n\t\t\tvar parts = splitFieldsModel(fieldsModel, field);\n            outNode.open = outNode.renderFields(parts[0]);\n\t\t\toutNode.close = outNode.renderFields(parts[1]);\n\t\t} else {\n\t\t\toutNode.text = outNode.renderFields(fieldsModel);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Finds field with lowest index in given text\n * @param  {Object} model\n * @return {Object}\n */\nfunction findLowestIndexField(model) {\n\treturn model.fields.reduce(function (result, field) { return !result || field.index < result.index ? field : result; }\n\t\t, null);\n}\n\n/**\n * Splits given fields model in two parts by given field\n * @param  {Object} model\n * @param  {Object} field\n * @return {Array} Two-items array\n */\nfunction splitFieldsModel(model, field) {\n\tvar ix = model.fields.indexOf(field);\n\n\tvar left = new model.constructor(\n\t\tmodel.string.slice(0, field.location),\n\t\tmodel.fields.slice(0, ix)\n\t);\n\n\tvar right = new model.constructor(\n\t\tmodel.string.slice(field.location + field.length),\n\t\tmodel.fields.slice(ix + 1)\n\t);\n\n\treturn [left, right];\n}\n\nvar commentOptions = {\n\t// enable node commenting\n\tenabled: false,\n\n\t// attributes that should trigger node commenting on specific node,\n\t// if commenting is enabled\n\ttrigger: ['id', 'class'],\n\n\t// comment before opening tag\n\tbefore: '',\n\n\t// comment after closing tag\n\tafter: '\\n<!-- /[#ID][.CLASS] -->'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as HTML, formatted according to\n * `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction html(tree, profile, options) {\n\toptions = Object.assign({}, options);\n\toptions.comment = Object.assign({}, commentOptions, options.comment);\n\n\treturn render(tree, options.field, function (outNode) {\n\t\toutNode = setFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tvar node = outNode.node;\n\n\t\t\tif (node.name) {\n\t\t\t\tvar name = profile.name(node.name);\n\t\t\t\tvar attrs = formatAttributes(outNode, profile);\n\n\t\t\t\toutNode.open = \"<\" + name + attrs + (node.selfClosing ? profile.selfClose() : '') + \">\";\n\t\t\t\tif (!node.selfClosing) {\n\t\t\t\t\toutNode.close = \"</\" + name + \">\";\n\t\t\t\t}\n\n\t\t\t\tcommentNode(outNode, options.comment);\n\t\t\t}\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(node.value);\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction setFormatting(outNode, profile) {\n\tvar node = outNode.node;\n\n    if (shouldFormatNode(node, profile)) {\n        outNode.indent = profile.indent(getIndentLevel(node, profile));\n        outNode.newline = '\\n';\n        var prefix = outNode.newline + outNode.indent;\n\n        // do not format the very first node in output\n        if (!isRoot(node.parent) || !isFirstChild(node)) {\n            outNode.beforeOpen = prefix;\n            if (node.isTextOnly) {\n                outNode.beforeText = prefix;\n            }\n        }\n\n        if (hasInnerFormatting(node, profile)) {\n            if (!node.isTextOnly) {\n                outNode.beforeText = prefix + profile.indent(1);\n            }\n            outNode.beforeClose = prefix;\n        }\n    }\n\n    return outNode;\n}\n\n/**\n * Check if given node should be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatNode(node, profile) {\n\tif (!profile.get('format')) {\n\t\treturn false;\n\t}\n\n    if (node.parent.isTextOnly\n        && node.parent.children.length === 1\n        && parse$2$1(node.parent.value).fields.length) {\n        // Edge case: do not format the only child of text-only node,\n        // but only if parent contains fields\n        return false;\n    }\n\n\treturn isInline(node, profile) ? shouldFormatInline(node, profile) : true;\n}\n\n/**\n * Check if given inline node should be formatted as well, e.g. it contains\n * enough adjacent siblings that should force formatting\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction shouldFormatInline(node, profile) {\n\tif (!isInline(node, profile)) {\n\t\treturn false;\n\t}\n\n    if (isPseudoSnippet(node)) {\n        return true;\n    }\n\n    // check if inline node is the next sibling of block-level node\n    if (node.childIndex === 0) {\n        // first node in parent: format if its followed by a block-level element\n        var next = node;\n        while (next = next.nextSibling) {\n            if (!isInline(next, profile)) {\n                return true;\n            }\n        }\n    } else if (!isInline(node.previousSibling, profile)) {\n        // node is right after block-level element\n        return true;\n    }\n\n    if (profile.get('inlineBreak')) {\n        // check for adjacent inline elements before and after current element\n        var adjacentInline = 1;\n        var before = node, after = node;\n\n        while (isInlineElement((before = before.previousSibling), profile)) {\n            adjacentInline++;\n        }\n\n        while (isInlineElement((after = after.nextSibling), profile)) {\n            adjacentInline++;\n        }\n\n\t\tif (adjacentInline >= profile.get('inlineBreak')) {\n\t\t\treturn true;\n\t\t}\n    }\n\n\t// Another edge case: inline node contains node that should receive foramtting\n\tfor (var i = 0, il = node.children.length; i < il; i++) {\n\t\tif (shouldFormatNode(node.children[i], profile)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    return false;\n}\n\n/**\n * Check if given node contains inner formatting, e.g. any of its children should\n * be formatted\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {Boolean}\n */\nfunction hasInnerFormatting(node, profile) {\n    // check if node if forced for inner formatting\n    var nodeName = (node.name || '').toLowerCase();\n    if (profile.get('formatForce').indexOf(nodeName) !== -1) {\n        return true;\n    }\n\n    // check if any of children should receive formatting\n    // NB dont use `childrent.some()` to reduce memory allocations\n    for (var i = 0; i < node.children.length; i++) {\n        if (shouldFormatNode(node.children[i], profile)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Outputs attributes of given abbreviation node as HTML attributes\n * @param  {OutputNode} outNode\n * @param  {Profile}    profile\n * @return {String}\n */\nfunction formatAttributes(outNode, profile) {\n\tvar node = outNode.node;\n\n    return node.attributes.map(function (attr) {\n        if (attr.options.implied && attr.value == null) {\n    \t\treturn null;\n    \t}\n\n    \tvar attrName = profile.attribute(attr.name);\n    \tvar attrValue = null;\n\n        // handle boolean attributes\n    \tif (attr.options.boolean || profile.get('booleanAttributes').indexOf(attrName.toLowerCase()) !== -1) {\n    \t\tif (profile.get('compactBooleanAttributes') && attr.value == null) {\n    \t\t\treturn (\" \" + attrName);\n    \t\t} else if (attr.value == null) {\n    \t\t\tattrValue = attrName;\n    \t\t}\n    \t}\n\n    \tif (attrValue == null) {\n    \t\tattrValue = outNode.renderFields(attr.value);\n    \t}\n\n    \treturn (\" \" + attrName + \"=\" + (profile.quote(attrValue)));\n    }).join('');\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline(node, profile) {\n\treturn (node && node.isTextOnly) || isInlineElement(node, profile);\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInlineElement(node, profile) {\n\treturn node && profile.isInline(node);\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel(node, profile) {\n\t// Increase indent level IF NOT:\n\t// * parent is text-only node\n\t// * theres a parent node with a name that is explicitly set to decrease level\n\tvar skip = profile.get('formatSkip') || [];\n\tvar level = node.parent.isTextOnly ? -2 : -1;\n\tvar ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tif (skip.indexOf( (ctx.name || '').toLowerCase() ) === -1) {\n\t\t\tlevel++;\n\t\t}\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\n/**\n * Comments given output node, if required\n * @param  {OutputNode} outNode\n * @param  {Object} options\n */\nfunction commentNode(outNode, options) {\n\tvar node = outNode.node;\n\n\tif (!options.enabled || !options.trigger || !node.name) {\n\t\treturn;\n\t}\n\n\tvar attrs = outNode.node.attributes.reduce(function (out, attr) {\n\t\tif (attr.name && attr.value != null) {\n\t\t\tout[attr.name.toUpperCase().replace(/-/g, '_')] = attr.value;\n\t\t}\n\n\t\treturn out;\n\t}, {});\n\n\t// add comment only if attribute trigger is present\n\tfor (var i = 0, il = options.trigger.length; i < il; i++) {\n\t\tif (options.trigger[i].toUpperCase() in attrs) {\n\t\t\toutNode.open = template(options.before, attrs) + outNode.open;\n\t\t\tif (outNode.close) {\n\t\t\t\toutNode.close += template(options.after, attrs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Common utility methods for indent-based syntaxes (Slim, Pug, etc.)\n */\n\nvar reId = /^id$/i;\nvar reClass = /^class$/i;\nvar defaultAttrOptions = {\n\tprimary: function (attrs) { return attrs.join(''); },\n\tsecondary: function (attrs) { return attrs.map(function (attr) { return attr.isBoolean ? attr.name : ((attr.name) + \"=\" + (attr.value)); }).join(', '); }\n};\n\nvar defaultNodeOptions = {\n\topen: null,\n\tclose: null,\n\tomitName: /^div$/i,\n\tattributes: defaultAttrOptions\n};\n\nfunction indentFormat(outNode, profile, options) {\n\toptions = Object.assign({}, defaultNodeOptions, options);\n\tvar node = outNode.node;\n\n\toutNode.indent = profile.indent(getIndentLevel$1(node, profile));\n\toutNode.newline = '\\n';\n\n\t// Do not format the very first node in output\n    if (!isRoot(node.parent) || !isFirstChild(node)) {\n        outNode.beforeOpen = outNode.newline + outNode.indent;\n    }\n\n\tif (node.name) {\n\t\tvar data = Object.assign({\n\t\t\tNAME: profile.name(node.name),\n\t\t\tSELF_CLOSE: node.selfClosing ? options.selfClose : null\n\t\t}, getAttributes(outNode, profile, options.attributes));\n\n\t\t// omit tag name if node has primary attributes\n\t\tif (options.omitName && options.omitName.test(data.NAME) && data.PRIMARY_ATTRS) {\n\t\t\tdata.NAME = null;\n\t\t}\n\n\t\tif (options.open != null) {\n\t\t\toutNode.open = template(options.open, data);\n\t\t}\n\n\t\tif (options.close != null) {\n\t\t\toutNode.close = template(options.close, data);\n\t\t}\n\t}\n\n\treturn outNode;\n}\n\n/**\n * Formats attributes of given node into a string.\n * @param  {OutputNode} node          Output node wrapper\n * @param  {Profile}    profile       Output profile\n * @param  {Object}     options       Additional formatting options\n * @return {String}\n */\nfunction getAttributes(outNode, profile, options) {\n\toptions = Object.assign({}, defaultAttrOptions, options);\n\tvar primary = [], secondary = [];\n\tvar node = outNode.node;\n\n\tnode.attributes.forEach(function (attr) {\n\t\tif (attr.options.implied && attr.value == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar name = profile.attribute(attr.name);\n\t\tvar value = outNode.renderFields(attr.value);\n\n\t\tif (reId.test(name)) {\n\t\t\tvalue && primary.push((\"#\" + value));\n\t\t} else if (reClass.test(name)) {\n\t\t\tvalue && primary.push((\".\" + (value.replace(/\\s+/g, '.'))));\n\t\t} else {\n\t\t\tvar isBoolean = attr.value == null\n\t\t\t\t&& (attr.options.boolean || profile.get('booleanAttributes').indexOf(name.toLowerCase()) !== -1);\n\n\t\t\tsecondary.push({ name: name, value: value, isBoolean: isBoolean });\n\t\t}\n\t});\n\n\treturn {\n\t\tPRIMARY_ATTRS: options.primary(primary) || null,\n\t\tSECONDARY_ATTRS: options.secondary(secondary) || null\n\t};\n}\n\n/**\n * Computes indent level for given node\n * @param  {Node} node\n * @param  {Profile} profile\n * @param  {Number} level\n * @return {Number}\n */\nfunction getIndentLevel$1(node, profile) {\n\tvar level = node.parent.isTextOnly ? -2 : -1;\n\tvar ctx = node;\n\twhile (ctx = ctx.parent) {\n\t\tlevel++;\n\t}\n\n\treturn level < 0 ? 0 : level;\n}\n\nvar reNl = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as HAML, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction haml(tree, profile, options) {\n\toptions = options || {};\n\tvar nodeOptions = {\n\t\topen: '[%NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)][SELF_CLOSE]',\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary: function secondary(attrs) {\n\t\t\t\treturn attrs.map(function (attr) { return attr.isBoolean\n\t\t\t\t\t? (\"\" + (attr.name) + (profile.get('compactBooleanAttributes') ? '' : '=true'))\n\t\t\t\t\t: ((attr.name) + \"=\" + (profile.quote(attr.value))); }\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, function (outNode) {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tvar node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, HAML is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting(outNode, profile) {\n\tvar node = outNode.node;\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n/**\n * Formats value of given node: for multiline text we should add a ` |` suffix\n * at the end of each line. Also ensure that text is perfectly aligned.\n * @param  {Node}    node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue(node, profile) {\n\tif (node.value != null && reNl.test(node.value)) {\n\t\tvar lines = splitByLines$1(node.value);\n\t\tvar indent = profile.indent(1);\n\t\tvar maxLength = lines.reduce(function (prev, line) { return Math.max(prev, line.length); }, 0);\n\n\t\treturn lines.map(function (line, i) { return (\"\" + (i ? indent : '') + (pad(line, maxLength)) + \" |\"); }).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nfunction pad(text, len) {\n\twhile (text.length < len) {\n\t\ttext += ' ';\n\t}\n\n\treturn text;\n}\n\nvar reNl$1 = /\\n|\\r/;\nvar secondaryAttrs = {\n\tnone:   '[ SECONDARY_ATTRS]',\n\tround:  '[(SECONDARY_ATTRS)]',\n\tcurly:  '[{SECONDARY_ATTRS}]',\n\tsquare: '[[SECONDARY_ATTRS]'\n};\n\n/**\n * Renders given parsed Emmet abbreviation as Slim, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction slim(tree, profile, options) {\n\toptions = options || {};\n\tvar SECONDARY_ATTRS = options.attributeWrap\n\t\t&& secondaryAttrs[options.attributeWrap]\n\t\t|| secondaryAttrs.none;\n\n\tvar booleanAttr = SECONDARY_ATTRS === secondaryAttrs.none\n\t\t? function (attr) { return ((attr.name) + \"=true\"); }\n\t\t: function (attr) { return attr.name; };\n\n\tvar nodeOptions = {\n\t\topen: (\"[NAME][PRIMARY_ATTRS]\" + SECONDARY_ATTRS + \"[SELF_CLOSE]\"),\n\t\tselfClose: '/',\n\t\tattributes: {\n\t\t\tsecondary: function secondary(attrs) {\n\t\t\t\treturn attrs.map(function (attr) { return attr.isBoolean\n\t\t\t\t\t? booleanAttr(attr)\n\t\t\t\t\t: ((attr.name) + \"=\" + (profile.quote(attr.value))); }\n\t\t\t\t).join(' ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, function (outNode, renderFields) {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$1(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tvar node = outNode.node;\n\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$1(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Slim is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of farsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$1(outNode, profile) {\n\tvar node = outNode.node;\n\tvar parent = node.parent;\n\n\t// Edge case: a single inline-level child inside node without text:\n\t// allow it to be inlined\n\tif (profile.get('inlineBreak') === 0 && isInline$1(node, profile)\n\t\t&& !isRoot(parent) && parent.value == null && parent.children.length === 1) {\n\t\toutNode.beforeOpen = ': ';\n\t}\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl$1.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$1(node, profile) {\n\tif (node.value != null && reNl$1.test(node.value)) {\n\t\tvar indent = profile.indent(1);\n\t\treturn splitByLines$1(node.value).map(function (line, i) { return (\"\" + indent + (i ? ' ' : '|') + \" \" + line); }).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\n/**\n * Check if given node is inline-level\n * @param  {Node}  node\n * @param  {Profile}  profile\n * @return {Boolean}\n */\nfunction isInline$1(node, profile) {\n\treturn node && (node.isTextOnly || profile.isInline(node));\n}\n\nvar reNl$2 = /\\n|\\r/;\n\n/**\n * Renders given parsed Emmet abbreviation as Pug, formatted according to\n * `profile` options\n * @param  {Node}    tree      Parsed Emmet abbreviation\n * @param  {Profile} profile   Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction pug(tree, profile, options) {\n\toptions = options || {};\n\tvar nodeOptions = {\n\t\topen: '[NAME][PRIMARY_ATTRS][(SECONDARY_ATTRS)]',\n\t\tattributes: {\n\t\t\tsecondary: function secondary(attrs) {\n\t\t\t\treturn attrs.map(function (attr) { return attr.isBoolean ? attr.name : ((attr.name) + \"=\" + (profile.quote(attr.value))); }).join(', ');\n\t\t\t}\n\t\t}\n\t};\n\n\treturn render(tree, options.field, function (outNode) {\n\t\toutNode = indentFormat(outNode, profile, nodeOptions);\n\t\toutNode = updateFormatting$2(outNode, profile);\n\n\t\tif (!handlePseudoSnippet(outNode)) {\n\t\t\tvar node = outNode.node;\n\t\t\t// Do not generate fields for nodes with empty value and children\n\t\t\t// or if node is self-closed\n\t\t\tif (node.value || (!node.children.length && !node.selfClosing) ) {\n\t\t\t\toutNode.text = outNode.renderFields(formatNodeValue$2(node, profile));\n\t\t\t}\n\t\t}\n\n        return outNode;\n\t});\n}\n\n/**\n * Updates formatting properties for given output node\n * NB Unlike HTML, Pug is indent-based format so some formatting options from\n * `profile` will not take effect, otherwise output will be broken\n * @param  {OutputNode} outNode Output wrapper of parsed abbreviation node\n * @param  {Profile}    profile Output profile\n * @return {OutputNode}\n */\nfunction updateFormatting$2(outNode, profile) {\n\tvar node = outNode.node;\n\n    if (!node.isTextOnly && node.value) {\n        // node with text: put a space before single-line text\n        outNode.beforeText = reNl$2.test(node.value)\n\t\t\t? outNode.newline + outNode.indent + profile.indent(1)\n\t\t\t: ' ';\n    }\n\n\treturn outNode;\n}\n\n/**\n * Formats value of given node: for multiline text we should precede each\n * line with `| ` with one-level deep indent\n * @param  {Node} node\n * @param  {Profile} profile\n * @return {String|null}\n */\nfunction formatNodeValue$2(node, profile) {\n\tif (node.value != null && reNl$2.test(node.value)) {\n\t\tvar indent = profile.indent(1);\n\t\treturn splitByLines$1(node.value).map(function (line) { return (indent + \"| \" + line); }).join('\\n');\n\t}\n\n\treturn node.value;\n}\n\nvar supportedSyntaxed = { html: html, haml: haml, slim: slim, pug: pug };\n\n/**\n * Outputs given parsed abbreviation in specified syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `html` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nvar index$3 = function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports(syntax)) {\n\t\t// fallback to HTML if given syntax is not supported\n\t\tsyntax = 'html';\n\t}\n\n\treturn supportedSyntaxed[syntax](tree, profile, options);\n};\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports(syntax) {\n\treturn !!syntax && syntax in supportedSyntaxed;\n}\n\n/**\n * A wrapper for holding CSS value\n */\nvar CSSValue = function CSSValue() {\n\tthis.type = 'css-value';\n\tthis.value = [];\n};\n\nvar prototypeAccessors$2 = { size: {} };\n\nprototypeAccessors$2.size.get = function () {\n\treturn this.value.length;\n};\n\nCSSValue.prototype.add = function add (value) {\n\tthis.value.push(value);\n};\n\nCSSValue.prototype.has = function has (value) {\n\treturn this.value.indexOf(value) !== -1;\n};\n\nCSSValue.prototype.toString = function toString () {\n\treturn this.value.join(' ');\n};\n\nObject.defineProperties( CSSValue.prototype, prototypeAccessors$2 );\n\nvar HASH$1 = 35; // #\nvar DOT$1$1  = 46; // .\n\n/**\n * Consumes a color token from given string\n * @param  {StreamReader} stream\n * @return {Color} Returns consumend color object, `undefined` otherwise\n */\nvar consumeColor = function(stream) {\n\t// supported color variations:\n\t// #abc    #aabbccc\n\t// #0      #000000\n\t// #fff.5  rgba(255, 255, 255, 0.5)\n\t// #t      transparent\n\tif (stream.peek() === HASH$1) {\n\t\tstream.start = stream.pos;\n\t\tstream.next();\n\n\t\tstream.eat(116) /* t */ || stream.eatWhile(isHex);\n\t\tvar base = stream.current();\n\n\t\t// a hex color can be followed by `.num` alpha value\n\t\tstream.start = stream.pos;\n\t\tif (stream.eat(DOT$1$1) && !stream.eatWhile(isNumber$1)) {\n\t\t\tthrow stream.error('Unexpected character for alpha value of color');\n\t\t}\n\n\t\treturn new Color(base, stream.current());\n\t}\n};\n\nvar Color = function Color(value, alpha) {\n\tthis.type = 'color';\n\tthis.raw = value;\n\tthis.alpha = Number(alpha != null && alpha !== '' ? alpha : 1);\n\tvalue = value.slice(1); // remove #\n\n\tvar r = 0, g = 0, b = 0;\n\n\tif (value === 't') {\n\t\tthis.alpha = 0;\n\t} else {\n\t\tswitch (value.length) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tr = g = b = value + value;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tr = g = b = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tr = value[0] + value[0];\n\t\t\t\tg = value[1] + value[1];\n\t\t\t\tb = value[2] + value[2];\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tvalue += value;\n\t\t\t\tr = value.slice(0, 2);\n\t\t\t\tg = value.slice(2, 4);\n\t\t\t\tb = value.slice(4, 6);\n\t\t}\n\t}\n\n\tthis.r = parseInt(r, 16);\n\tthis.g = parseInt(g, 16);\n\tthis.b = parseInt(b, 16);\n};\n\n/**\n\t * Output current color as hex value\n\t * @param {Boolean} shor Produce short value (e.g. #fff instead of #ffffff), if possible\n\t * @return {String}\n\t */\nColor.prototype.toHex = function toHex$1 (short) {\n\tvar fn = (short && isShortHex(this.r) && isShortHex(this.g) && isShortHex(this.b))\n\t\t? toShortHex : toHex;\n\n\treturn '#' + fn(this.r)  + fn(this.g) + fn(this.b);\n};\n\n/**\n\t * Output current color as `rgba?(...)` CSS color\n\t * @return {String}\n\t */\nColor.prototype.toRGB = function toRGB () {\n\tvar values = [this.r, this.g, this.b];\n\tif (this.alpha !== 1) {\n\t\tvalues.push(this.alpha.toFixed(8).replace(/\\.?0+$/, ''));\n\t}\n\n\treturn ((values.length === 3 ? 'rgb' : 'rgba') + \"(\" + (values.join(', ')) + \")\");\n};\n\nColor.prototype.toString = function toString (short) {\n\tif (!this.r && !this.g && !this.b && !this.alpha) {\n\t\treturn 'transparent';\n\t}\n\treturn this.alpha === 1 ? this.toHex(short) : this.toRGB();\n};\n\n/**\n * Check if given code is a hex value (/0-9a-f/)\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isHex(code) {\n\treturn isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F\n}\n\nfunction isShortHex(hex) {\n\treturn !(hex % 17);\n}\n\nfunction toShortHex(num) {\n\treturn (num >> 4).toString(16);\n}\n\nfunction toHex(num) {\n\treturn pad$1(num.toString(16), 2);\n}\n\nfunction pad$1(value, len) {\n\twhile (value.length < len) {\n\t\tvalue = '0' + value;\n\t}\n\treturn value;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaNumericWord(code) {\n\treturn isNumber$1(code) || isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAlphaWord(code) {\n\treturn code === 95 /* _ */ || isAlpha$1(code);\n}\n\nvar PERCENT = 37; // %\nvar DOT$1$2     = 46; // .\nvar DASH$1    = 45; // -\n\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n * @param  {StreamReader} stream\n * @return {NumericValue}\n */\nvar consumeNumericValue = function(stream) {\n\tstream.start = stream.pos;\n\tif (eatNumber(stream)) {\n\t\tvar num = stream.current();\n\t\tstream.start = stream.pos;\n\n\t\t// eat unit, which can be a % or alpha word\n\t\tstream.eat(PERCENT) || stream.eatWhile(isAlphaWord);\n\t\treturn new NumericValue(num, stream.current());\n\t}\n};\n\n/**\n * A numeric CSS value with optional unit\n */\nvar NumericValue = function NumericValue(value, unit) {\n\tthis.type = 'numeric';\n\tthis.value = Number(value);\n\tthis.unit = unit || '';\n};\n\nNumericValue.prototype.toString = function toString () {\n\treturn (\"\" + (this.value) + (this.unit));\n};\n\n/**\n * Eats number value from given stream\n * @param  {StreamReader} stream\n * @return {Boolean} Returns `true` if number was consumed\n */\nfunction eatNumber(stream) {\n\tvar start = stream.pos;\n\tvar negative = stream.eat(DASH$1);\n\tvar hadDot = false, consumed = false, code;\n\n\twhile (!stream.eof()) {\n\t\tcode = stream.peek();\n\n\t\t// either a second dot or not a number: stop parsing\n\t\tif (code === DOT$1$2 ? hadDot : !isNumber$1(code)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconsumed = true;\n\n\t\tif (code === DOT$1$2) {\n\t\t\thadDot = true;\n\t\t}\n\n\t\tstream.next();\n\t}\n\n\tif (negative && !consumed) {\n\t\t// edge case: consumed dash only, bail out\n\t\tstream.pos = start;\n\t}\n\n\treturn start !== stream.pos;\n}\n\nvar DOLLAR$1 = 36; // $\nvar DASH$2   = 45; // -\nvar AT$1     = 64; // @\n\n/**\n * Consumes a keyword: either a variable (a word that starts with $ or @) or CSS\n * keyword or shorthand\n * @param  {StreamReader} stream\n * @param  {Boolean} [short] Use short notation for consuming value.\n * The difference between short and full notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while full notation also supports numbers and dashes\n * @return {String} Consumed variable\n */\nvar consumeKeyword = function(stream, short) {\n\tstream.start = stream.pos;\n\n\tif (stream.eat(DOLLAR$1) || stream.eat(AT$1)) {\n\t\t// SCSS or LESS variable\n\t\tstream.eatWhile(isVariableName);\n\t} else if (short) {\n\t\tstream.eatWhile(isAlphaWord);\n\t} else {\n\t\tstream.eatWhile(isKeyword);\n\t}\n\n\treturn stream.start !== stream.pos ? new Keyword(stream.current()) : null;\n};\n\nvar Keyword = function Keyword(value) {\n\tthis.type = 'keyword';\n\tthis.value = value;\n};\n\nKeyword.prototype.toString = function toString () {\n\treturn this.value;\n};\n\nfunction isKeyword(code) {\n\treturn isAlphaNumericWord(code) || code === DASH$2;\n}\n\nfunction isVariableName(code) {\n\treturn code === 45 /* - */ || isAlphaNumericWord(code);\n}\n\nvar opt$1$1 = { throws: true };\n\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @param  {StreamReader} stream\n * @return {String}\n */\nvar consumeQuoted$1 = function(stream) {\n\tif (eatQuoted$1(stream, opt$1$1)) {\n\t\treturn new QuotedString(stream.current());\n\t}\n};\n\nvar QuotedString = function QuotedString(value) {\n\tthis.type = 'string';\n\tthis.value = value;\n};\n\nQuotedString.prototype.toString = function toString () {\n\treturn this.value;\n};\n\nvar LBRACE = 40; // (\nvar RBRACE = 41; // )\nvar COMMA  = 44; // ,\n\n/**\n * Consumes arguments from given string.\n * Arguments are comma-separated list of CSS values inside round braces, e.g.\n * `(1, a2, 'a3')`. Nested lists and quoted strings are supported\n * @param  {StreamReader} stream\n * @return {Array}        Array of arguments, `null` if arguments cannot be consumed\n */\nfunction consumeArgumentList(stream) {\n\tif (!stream.eat(LBRACE)) {\n\t\t// not an argument list\n\t\treturn null;\n\t}\n\n\tvar level = 1, code, arg;\n\tvar argsList = [];\n\n\twhile (!stream.eof()) {\n\t\tif (arg = consumeArgument(stream)) {\n\t\t\targsList.push(arg);\n\t\t} else {\n\t\t\t// didnt consumed argument, expect argument separator or end-of-arguments\n\t\t\tstream.eatWhile(isWhiteSpace$1);\n\n\t\t\tif (stream.eat(RBRACE)) {\n\t\t\t\t// end of arguments list\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!stream.eat(COMMA)) {\n\t\t\t\tthrow stream.error('Expected , or )');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn argsList;\n}\n\n/**\n * Consumes a single argument. An argument is a `CSSValue`, e.g. it could be\n * a space-separated string of value\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeArgument(stream) {\n\tvar result = new CSSValue();\n\tvar value;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isWhiteSpace$1);\n\t\tvalue = consumeNumericValue(stream) || consumeColor(stream)\n\t\t\t|| consumeQuoted$1(stream) || consumeKeywordOrFunction(stream);\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tresult.add(value);\n\t}\n\n\treturn result.size ? result : null;\n}\n\n/**\n * Consumes either function call like `foo()` or keyword like `foo`\n * @param  {StreamReader} stream\n * @return {Keyword|FunctionCall}\n */\nfunction consumeKeywordOrFunction(stream) {\n\tvar kw = consumeKeyword(stream);\n\tif (kw) {\n\t\tvar args = consumeArgumentList(stream);\n\t\treturn args ? new FunctionCall(kw.toString(), args) : kw;\n\t}\n}\n\nvar FunctionCall = function FunctionCall(name, args) {\n\tthis.type = 'function';\n\tthis.name = name;\n\tthis.args = args || [];\n};\n\nFunctionCall.prototype.toString = function toString () {\n\treturn ((this.name) + \"(\" + (this.args.join(', ')) + \")\");\n};\n\nvar EXCL$1   = 33; // !\nvar DOLLAR$1$1 = 36; // $\nvar PLUS   = 43; // +\nvar DASH   = 45; // -\nvar COLON$2  = 58; // :\nvar AT     = 64; // @\n\n/**\n * Parses given Emmet CSS abbreviation and returns it as parsed Node tree\n * @param {String} abbr\n * @return {Node}\n */\nvar index$4 = function(abbr) {\n\tvar root = new Node();\n\tvar stream = new StreamReader$1(abbr);\n\tvar node;\n\n\twhile (!stream.eof()) {\n\t\tvar node$1 = new Node(consumeIdent(stream));\n\t\tnode$1.value = consumeValue(stream);\n\n\t\tvar args = consumeArgumentList(stream);\n\t\tif (args) {\n\t\t\t// technically, arguments in CSS are anonymous Emmet Node attributes,\n\t\t\t// but since Emmet can support only one anonymous, `null`-name\n\t\t\t// attribute (for good reasons), well use argument index as name\n\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\tnode$1.setAttribute(String(i), args[i]);\n\t\t\t}\n\t\t}\n\n\t\t// Consume `!important` modifier at the end of expression\n\t\tif (stream.eat(EXCL$1)) {\n\t\t\tnode$1.value.add('!');\n\t\t}\n\n\t\troot.appendChild(node$1);\n\n\t\t// CSS abbreviations cannot be nested, only listed\n\t\tif (!stream.eat(PLUS)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!stream.eof()) {\n\t\tthrow stream.error('Unexpected character');\n\t}\n\n\treturn root;\n};\n\n/**\n * Consumes CSS property identifier from given stream\n * @param  {StreamReader} stream\n * @return {String}\n */\nfunction consumeIdent(stream) {\n\tstream.start = stream.pos;\n\tstream.eatWhile(isIdentPrefix);\n\tstream.eatWhile(isIdent$1);\n\treturn stream.start !== stream.pos ? stream.current() : null;\n}\n\n/**\n * Consumes embedded value from Emmet CSS abbreviation stream\n * @param  {StreamReader} stream\n * @return {CSSValue}\n */\nfunction consumeValue(stream) {\n\tvar values = new CSSValue();\n\tvar value;\n\n\twhile (!stream.eof()) {\n\t\t// use colon as value separator\n\t\tstream.eat(COLON$2);\n\t\tif (value = consumeNumericValue(stream) || consumeColor(stream)) {\n\t\t\t// edge case: a dash after unit-less numeric value or color should\n\t\t\t// be treated as value separator, not negative sign\n\t\t\tif (!value.unit) {\n\t\t\t\tstream.eat(DASH);\n\t\t\t}\n\t\t} else {\n\t\t\tstream.eat(DASH);\n\t\t\tvalue = consumeKeyword(stream, true);\n\t\t}\n\n\t\tif (!value) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\treturn values;\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdent$1(code) {\n\treturn isAlphaWord(code);\n}\n\n/**\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isIdentPrefix(code) {\n\treturn code === AT || code === DOLLAR$1$1 || code === EXCL$1;\n}\n\nvar DASH$1$1 = 45; // -\n\n/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param  {String} abbr        Abbreviation to score\n * @param  {String} string      String to match\n * @param  {Number} [fuzziness] Fuzzy factor\n * @return {Number}             Match score\n */\nvar stringScore = function(abbr, string) {\n    if (abbr === string) {\n        return 1;\n    }\n\n    // a string MUST start with the same character as abbreviation\n    if (!string || abbr.charCodeAt(0) !== string.charCodeAt(0)) {\n        return 0;\n    }\n\n    var abbrLength = abbr.length;\n    var stringLength = string.length;\n    var i = 1, j = 1, score = stringLength;\n    var ch1, ch2, found, acronym;\n\n    while (i < abbrLength) {\n        ch1 = abbr.charCodeAt(i);\n        found = false;\n        acronym = false;\n\n        while (j < stringLength) {\n            ch2 = string.charCodeAt(j);\n\n            if (ch1 === ch2) {\n                found = true;\n                score += (stringLength - j) * (acronym ? 2 : 1);\n                break;\n            }\n\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === DASH$1$1;\n            j++;\n        }\n\n        if (!found) {\n            break;\n        }\n\n        i++;\n    }\n\n    return score && score * (i / abbrLength) / sum(stringLength);\n};\n\n/**\n * Calculates sum of first `n` natural numbers, e.g. 1+2+3+...n\n * @param  {Number} n\n * @return {Number}\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nvar reProperty = /^([a-z\\-]+)(?:\\s*:\\s*([^\\n\\r]+))?$/;\nvar DASH$1$2 = 45; // -\n\n/**\n * Creates a special structure for resolving CSS properties from plain CSS\n * snippets.\n * Almost all CSS snippets are aliases for real CSS properties with available\n * value variants, optionally separated by `|`. Most values are keywords that\n * can be fuzzy-resolved as well. Some CSS properties are shorthands for other,\n * more specific properties, like `border` and `border-style`. For such cases\n * keywords from more specific properties should be available in shorthands too.\n * @param {Snippet[]} snippets\n * @return {CSSSnippet[]}\n */\nvar cssSnippets = function(snippets) {\n    return nest( snippets.map(function (snippet) { return new CSSSnippet(snippet.key, snippet.value); }) );\n};\n\nvar CSSSnippet = function CSSSnippet(key, value) {\n    this.key = key;\n    this.value = value;\n    this.property = null;\n\n    // detect if given snippet is a property\n    var m = value && value.match(reProperty);\n    if (m) {\n        this.property = m[1];\n        this.value = m[2];\n    }\n\n    this.dependencies = [];\n};\n\nvar prototypeAccessors$3 = { defaulValue: {} };\n\nCSSSnippet.prototype.addDependency = function addDependency (dep) {\n    this.dependencies.push(dep);\n};\n\nprototypeAccessors$3.defaulValue.get = function () {\n    return this.value != null ? splitValue(this.value)[0] : null;\n};\n\n/**\n * Returns list of unique keywords for current CSS snippet and its dependencies\n * @return {String[]}\n */\nCSSSnippet.prototype.keywords = function keywords () {\n    var stack = [];\n    var keywords = new Set();\n    var i = 0, item, candidates;\n\n    if (this.property) {\n        // scan valid CSS-properties only\n        stack.push(this);\n    }\n\n    while (i < stack.length) {\n        // NB Keep items in stack instead of push/pop to avoid possible\n        // circular references\n        item = stack[i++];\n\n        if (item.value) {\n            candidates = splitValue(item.value).filter(isKeyword$1);\n\n            // extract possible keywords from snippet value\n            for (var j = 0; j < candidates.length; j++) {\n                keywords.add(candidates[j].trim());\n            }\n\n            // add dependencies into scan stack\n            for (var j$1 = 0, deps = item.dependencies; j$1 < deps.length; j$1++) {\n                if (stack.indexOf(deps[j$1]) === -1) {\n                    stack.push(deps[j$1]);\n                }\n            }\n        }\n    }\n\n    return Array.from(keywords);\n};\n\nObject.defineProperties( CSSSnippet.prototype, prototypeAccessors$3 );\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * background-position-x -> background-position -> background\n * @param  {CSSSnippet[]} snippets\n * @return {CSSSnippet[]}\n */\nfunction nest(snippets) {\n    snippets = snippets.sort(snippetsSort);\n    var stack = [];\n\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // backgound -> background-position -> background-position-x\n    for (var i = 0, cur = (void 0), prev = (void 0); i < snippets.length; i++) {\n        cur = snippets[i];\n\n        if (!cur.property) {\n            // not a CSS property, skip it\n            continue;\n        }\n\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n\n            if (cur.property.indexOf(prev.property) === 0\n                && cur.property.charCodeAt(prev.property.length) === DASH$1$2) {\n                prev.addDependency(cur);\n                stack.push(cur);\n                break;\n            }\n\n            stack.pop();\n        }\n\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n\n    return snippets;\n}\n\n/**\n * A sorting function for array of snippets\n * @param  {CSSSnippet} a\n * @param  {CSSSnippet} b\n * @return {Number}\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n\n    return a.key < b.key ? -1 : 1;\n}\n\n/**\n * Check if given string is a keyword candidate\n * @param  {String}  str\n * @return {Boolean}\n */\nfunction isKeyword$1(str) {\n    return /^\\s*[\\w\\-]+/.test(str);\n}\n\nfunction splitValue(value) {\n    return String(value).split('|');\n}\n\nvar globalKeywords = ['auto', 'inherit', 'unset'];\nvar unitlessProperties = [\n    'z-index', 'line-height', 'opacity', 'font-weight', 'zoom',\n    'flex', 'flex-grow', 'flex-shrink'\n];\nvar unitAliases = {\n    e :'em',\n    p: '%',\n    x: 'ex',\n    r: 'rem'\n};\n\n/**\n * For every node in given `tree`, finds matching snippet from `registry` and\n * updates node with snippet data.\n *\n * This resolver uses fuzzy matching for searching matched snippets and their\n * keyword values.\n */\n\nvar index$5 = function(tree, registry) {\n\tvar snippets = convertToCSSSnippets(registry);\n\ttree.walk(function (node) { return resolveNode$1(node, snippets); });\n\treturn tree;\n};\n\nfunction convertToCSSSnippets(registry) {\n    return cssSnippets(registry.all({type: 'string'}))\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n * @param  {Node} node\n * @param  {CSSSnippet[]} snippets\n * @return {Node}\n */\nfunction resolveNode$1(node, snippets) {\n\tvar snippet = findBestMatch(node.name, snippets, 'key');\n\n\tif (!snippet) {\n\t\t// Edge case: `!important` snippet\n\t\treturn node.name === '!' ? setNodeAsText(node, '!important') : node;\n\t}\n\n\treturn snippet.property\n\t\t? resolveAsProperty(node, snippet)\n\t\t: resolveAsSnippet(node, snippet);\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS propery\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsProperty(node, snippet) {\n    var abbr = node.name;\n\tnode.name = snippet.property;\n\n\tif (node.value && typeof node.value === 'object') {\n\t\t// resolve keyword shortcuts\n\t\tvar keywords = snippet.keywords();\n\n\t\tif (!node.value.size) {\n\t\t\t// no value defined, try to resolve unmatched part as a keyword alias\n\t\t\tvar kw = findBestMatch(getUnmatchedPart(abbr, snippet.key), keywords);\n\n            if (!kw) {\n                // no matching value, try to get default one\n                kw = snippet.defaulValue;\n                if (kw && kw.indexOf('${') === -1) {\n                    // Quick and dirty test for existing field. If not, wrap\n                    // default value in a field\n                    kw = \"${1:\" + kw + \"}\";\n                }\n            }\n\n\t\t\tif (kw) {\n\t\t\t\tnode.value.add(kw);\n\t\t\t}\n\t\t} else {\n\t\t\t// replace keyword aliases in current node value\n\t\t\tfor (var i = 0, token = (void 0); i < node.value.value.length; i++) {\n\t\t\t\ttoken = node.value.value[i];\n\n\t\t\t\tif (token === '!') {\n\t\t\t\t\ttoken = (!i ? '${1} ' : '') + \"!important\";\n\t\t\t\t} else if (isKeyword$1$1(token)) {\n\t\t\t\t\ttoken = findBestMatch(token.value, keywords)\n\t\t\t\t\t\t|| findBestMatch(token.value, globalKeywords)\n\t\t\t\t\t\t|| token;\n\t\t\t\t} else if (isNumericValue(token)) {\n                    token = resolveNumericValue(node.name, token);\n                }\n\n                node.value.value[i] = token;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n * @param {Node} node\n * @param {CSSSnippet} snippet\n * @return {Node}\n */\nfunction resolveAsSnippet(node, snippet) {\n\treturn setNodeAsText(node, snippet.value);\n}\n\n/**\n * Sets given parsed abbreviation node as a text snippet\n * @param {Node} node\n * @param {String} text\n * @return {Node}\n */\nfunction setNodeAsText(node, text) {\n\tnode.name = null;\n\tnode.value = text;\n\treturn node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param {String} abbr  Abbreviation to match\n * @param {Array}  items List of items for match\n * @param {String} [key] If `items` is a list of objects, use `key` as object\n * property to test against\n * @return {*}\n */\nfunction findBestMatch(abbr, items, key) {\n\tif (!abbr) {\n\t\treturn null;\n\t}\n\n\tvar matchedItem = null;\n\tvar maxScore = 0;\n\n\tfor (var i = 0, item = (void 0); i < items.length; i++) {\n\t\titem = items[i];\n\t\tvar score = stringScore(abbr, getScoringPart(item, key));\n\n\t\tif (score === 1) {\n\t\t\t// direct hit, no need to look further\n\t\t\treturn item;\n\t\t}\n\n\t\tif (score && score >= maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tmatchedItem = item;\n\t\t}\n\t}\n\n\treturn matchedItem;\n}\n\nfunction getScoringPart(item, key) {\n    var value = item && typeof item === 'object' ? item[key] : item;\n    var m = (value || '').match(/^[\\w-@]+/);\n    return m ? m[0] : value;\n}\n\n/**\n * Returns a part of `abbr` that wasnt directly matched agains `string`.\n * For example, if abbreviation `poas` is matched against `position`, the unmatched part will be `as`\n * since `a` wasnt found in string stream\n * @param {String} abbr\n * @param {String} string\n * @return {String}\n */\nfunction getUnmatchedPart(abbr, string) {\n\tfor (var i = 0, lastPos = 0; i < abbr.length; i++) {\n\t\tlastPos = string.indexOf(abbr[i], lastPos);\n\t\tif (lastPos === -1) {\n\t\t\treturn abbr.slice(i);\n\t\t}\n        lastPos++;\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if given CSS value token is a keyword\n * @param {*} token\n * @return {Boolean}\n */\nfunction isKeyword$1$1(token) {\n\treturn tokenTypeOf(token, 'keyword');\n}\n\n/**\n * Check if given CSS value token is a numeric value\n * @param  {*}  token\n * @return {Boolean}\n */\nfunction isNumericValue(token) {\n    return tokenTypeOf(token, 'numeric');\n}\n\nfunction tokenTypeOf(token, type) {\n\treturn token && typeof token === 'object' && token.type === type;\n}\n\n/**\n * Resolves numeric value for given CSS property\n * @param  {String} property    CSS property name\n * @param  {NumericValue} token CSS numeric value token\n * @return {NumericValue}\n */\nfunction resolveNumericValue(property, token) {\n    if (token.unit) {\n        token.unit = unitAliases[token.unit] || token.unit;\n    } else if (token.value !== 0 && unitlessProperties.indexOf(property) === -1) {\n        // use `px` for integers, `em` for floats\n        // NB: num|0 is a quick alternative to Math.round(0)\n        token.unit = token.value === (token.value|0) ? 'px' : 'em';\n    }\n\n    return token;\n}\n\nvar defaultOptions$4 = {\n\tshortHex: true,\n\tformat: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t}\n};\n\n/**\n * Renders given parsed Emmet CSS abbreviation as CSS-like\n * stylesheet, formatted according to `profile` options\n * @param  {Node}     tree    Parsed Emmet abbreviation\n * @param  {Profile}  profile Output profile\n * @param  {Object}  [options] Additional formatter options\n * @return {String}\n */\nfunction css(tree, profile, options) {\n\toptions = Object.assign({}, defaultOptions$4, options);\n\n\treturn render(tree, options.field, function (outNode) {\n\t\tvar node = outNode.node;\n\t\tvar value = String(node.value || '');\n\n\t\tif (node.attributes.length) {\n\t\t\tvar fieldValues = node.attributes.map(function (attr) { return stringifyAttribute(attr, options); });\n\t\t\tvalue = injectFields(value, fieldValues);\n\t\t}\n\n\t\toutNode.open = node.name && profile.name(node.name);\n\t\toutNode.afterOpen = options.format.between;\n\t\toutNode.text = outNode.renderFields(value || null);\n\n\t\tif (outNode.open) {\n\t\t\toutNode.afterText = options.format.after;\n\t\t}\n\n\t\tif (profile.get('format')) {\n\t\t\toutNode.newline = '\\n';\n\t\t\tif (tree.lastChild !== node) {\n\t\t\t\toutNode.afterText += outNode.newline;\n\t\t\t}\n\t\t}\n\n\t\treturn outNode;\n\t});\n}\n\n/**\n * Injects given field values at each field of given string\n * @param  {String}   string\n * @param  {String[]} attributes\n * @return {FieldString}\n */\nfunction injectFields(string, values) {\n\tvar fieldsModel = parse$2$1(string);\n\tvar fieldsAmount = fieldsModel.fields.length;\n\n\tif (fieldsAmount) {\n\t\tvalues = values.slice();\n\t\tif (values.length > fieldsAmount) {\n\t\t\t// More values that output fields: collapse rest values into\n\t\t\t// a single token\n\t\t\tvalues = values.slice(0, fieldsAmount - 1)\n\t\t\t\t.concat(values.slice(fieldsAmount - 1).join(', '));\n\t\t}\n\n\t\twhile (values.length) {\n\t\t\tvar value = values.shift();\n\t\t\tvar field = fieldsModel.fields.shift();\n\t\t\tvar delta = value.length - field.length;\n\n\t\t\tfieldsModel.string = fieldsModel.string.slice(0, field.location)\n\t\t\t\t+ value\n\t\t\t\t+ fieldsModel.string.slice(field.location + field.length);\n\n\t\t\t// Update location of the rest fields in string\n\t\t\tfor (var i = 0, il = fieldsModel.fields.length; i < il; i++) {\n\t\t\t\tfieldsModel.fields[i].location += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fieldsModel;\n}\n\nfunction stringifyAttribute(attr, options) {\n\tif (attr.value && typeof attr.value === 'object' && attr.value.type === 'css-value') {\n\t\treturn attr.value.value\n\t\t.map(function (token) {\n\t\t\tif (token && typeof token === 'object') {\n\t\t\t\treturn token.type === 'color'\n\t\t\t\t\t? token.toString(options.shortHex)\n\t\t\t\t\t: token.toString();\n\t\t\t}\n\n\t\t\treturn String(token);\n\t\t})\n\t\t.join(' ');\n\t}\n\n\treturn attr.value != null ? String(attr.value) : '';\n}\n\nvar syntaxFormat = {\n\tcss: {\n\t\tbetween: ': ',\n\t\tafter: ';'\n\t},\n\tscss: 'css',\n\tless: 'css',\n\tsass: {\n\t\tbetween: ': ',\n\t\tafter: ''\n\t},\n\tstylus: {\n\t\tbetween: ' ',\n\t\tafter: ''\n\t}\n};\n\n/**\n * Outputs given parsed abbreviation in specified stylesheet syntax\n * @param {Node}     tree     Parsed abbreviation tree\n * @param {Profile}  profile  Output profile\n * @param {String}   [syntax] Output syntax. If not given, `css` syntax is used\n * @param {Function} options.field A function to output field/tabstop for\n * host editor. This function takes two arguments: `index` and `placeholder` and\n * should return a string that represents tabstop in host editor. By default\n * only a placeholder is returned\n * @example\n * {\n * \tfield(index, placeholder) {\n * \t\t// return field in TextMate-style, e.g. ${1} or ${2:foo}\n * \t\treturn `\\${${index}${placeholder ? ':' + placeholder : ''}}`;\n *  }\n * }\n * @return {String}\n */\nvar index$6 = function(tree, profile, syntax, options) {\n\tif (typeof syntax === 'object') {\n\t\toptions = syntax;\n\t\tsyntax = null;\n\t}\n\n\tif (!supports$1(syntax)) {\n\t\t// fallback to CSS if given syntax is not supported\n\t\tsyntax = 'css';\n\t}\n\n\toptions = Object.assign({}, options, {\n\t\tformat: getFormat(syntax, options)\n\t});\n\n\t// CSS abbreviations doesnt support nesting so simply\n\t// output root node children\n\treturn css(tree, profile, options);\n};\n\n/**\n * Check if given syntax is supported\n * @param {String} syntax\n * @return {Boolean}\n */\nfunction supports$1(syntax) {\n\treturn !!syntax && syntax in syntaxFormat;\n}\n\n/**\n * Returns formatter object for given syntax\n * @param  {String} syntax\n * @param  {Object} [options]\n * @return {Object} Formatter object as defined in `syntaxFormat`\n */\nfunction getFormat(syntax, options) {\n\tvar format = syntaxFormat[syntax];\n\tif (typeof format === 'string') {\n\t\tformat = syntaxFormat[format];\n\t}\n\n\treturn Object.assign({}, format, options && options.format);\n}\n\nvar html$1 = {\n\t\"a\": \"a[href]\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"style\": \"style\",\n\t\"script\": \"script[!src]\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n    \"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar css$1 = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:flex-start|flex-end|center|space-between|space-around|stretch\",\n\t\"ai\": \"align-items:flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:${1:time}\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:#${1:000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:#${1:000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:#${1:000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:#${1:000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:#${1:000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:#${1:000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:#${1:000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters({$0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fz\": \"font-size\",\n\t\"fza\": \"font-size-adjust\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:flex-start|flex-end|center|space-between|space-around\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:#${1:000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar index$7 = { html: html$1, css: css$1 };\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"-\", \"\", \"\", \"\", \" \", \"\", \" \", \"\", \"\", \"\"],\n\t\"words\": [\"\", \" \", \"\", \"\", \"\", \" \", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \" \", \"\", \"\",\"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",\"\", \"\", \"\", \"lorem\", \"ipsum\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",  \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"ms\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"pao\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"dems\", \"oficinista\", \"excepcin\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"curum\", \"dignsimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedicin\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"len\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"squito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asuncin\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentacin\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindo\", \"pcima\",\n\t\t\"voluble\", \"dbito\", \"sinti\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mnima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaa\", \"enigma\",\n\t\t\"total\", \"deletreo\", \"dcima\", \"cbala\", \"fotografa\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnfico\", \"distincin\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abada\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almcigo\", \"vos\", \"pan\",\n\t\t\"represin\", \"nmeros\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrn\", \"explcito\",\n\t\t\"paloma\", \"sndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propsito\",\n\t\t\"fantasa\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nvar langs = { latin: latin, ru: ru, sp: sp };\n\nvar defaultOptions$5 = {\n\twordCount: 30,\n\tskipCommon: false,\n\tlang: 'latin'\n};\n\n/**\n * Replaces given parsed Emmet abbreviation node with nodes filled with\n * Lorem Ipsum stub text.\n * @param {Node} node\n * @return {Node}\n */\nvar index$8 = function(node, options) {\n\toptions = Object.assign({}, defaultOptions$5, options);\n\tvar dict = langs[options.lang] || langs.latin;\n    var startWithCommon = !options.skipCommon && !isRepeating(node);\n\n\tif (!node.repeat && !isRoot$1(node.parent)) {\n\t\t// non-repeating element, insert text stub as a content of parent node\n\t\t// and remove current one\n\t\tnode.parent.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.remove();\n\t} else {\n\t\t// Replace named node with generated content\n\t\tnode.value = paragraph(dict, options.wordCount, startWithCommon);\n\t\tnode.name = resolveImplicitName(node.parent.name);\n\t}\n\n\treturn node;\n};\n\nfunction isRoot$1(node) {\n\treturn !node.parent;\n}\n\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n * @param {Number} from\n * @param {Number} to\n * @returns {Number}\n */\nfunction rand(from, to) {\n\treturn Math.floor(Math.random() * (to - from) + from);\n}\n\n/**\n * @param {Array} arr\n * @param {Number} count\n * @returns {Array}\n */\nfunction sample(arr, count) {\n\tvar len = arr.length;\n\tvar iterations = Math.min(len, count);\n\tvar result = new Set();\n\n\twhile (result.size < iterations) {\n\t\tresult.add(arr[rand(0, len)]);\n\t}\n\n\treturn Array.from(result);\n}\n\nfunction choice(val) {\n\treturn val[rand(0, val.length - 1)];\n}\n\nfunction sentence(words, end) {\n\tif (words.length) {\n\t\twords = [capitalize(words[0])].concat(words.slice(1));\n\t}\n\n\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\n\nfunction capitalize(word) {\n\treturn word[0].toUpperCase() + word.slice(1);\n}\n\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside <code>words</code> array\n * @param {Array} words\n */\nfunction insertCommas(words) {\n\tif (words.length < 2) {\n\t\treturn words;\n\t}\n\n\twords = words.slice();\n\tvar len = words.length;\n\tvar hasComma = /,$/;\n\tvar totalCommas = 0;\n\n\tif (len > 3 && len <= 6) {\n\t\ttotalCommas = rand(0, 1);\n\t} else if (len > 6 && len <= 12) {\n\t\ttotalCommas = rand(0, 2);\n\t} else {\n\t\ttotalCommas = rand(1, 4);\n\t}\n\n\tfor (var i = 0, pos = (void 0), word = (void 0); i < totalCommas; i++) {\n\t\tpos = rand(0, len - 2);\n\t\tif (!hasComma.test(words[pos])) {\n\t\t\twords[pos] += ',';\n\t\t}\n\t}\n\n\treturn words;\n}\n\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param {Object} dict Words dictionary (see `lang/*.json`)\n * @param {Number} wordCount Words count in paragraph\n * @param {Boolean} startWithCommon Should paragraph start with common\n * \"lorem ipsum\" sentence.\n * @returns {String}\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n\tvar result = [];\n\tvar totalWords = 0;\n\tvar words;\n\n\tif (startWithCommon && dict.common) {\n\t\twords = dict.common.slice(0, wordCount);\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words), '.'));\n\t}\n\n\twhile (totalWords < wordCount) {\n\t\twords = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n\t\ttotalWords += words.length;\n\t\tresult.push(sentence(insertCommas(words)));\n\t}\n\n\treturn result.join(' ');\n}\n\n/**\n * Check if given node is in repeating context, e.g. node itself or one of its\n * parent is repeated\n * @param  {Node}  node\n * @return {Boolean}\n */\nfunction isRepeating(node) {\n    while (node.parent) {\n        if (node.repeat && node.repeat.value && node.repeat.value > 1) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {String}\n */\nfunction expand$1(abbr, options) {\n\toptions = options || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$1(abbr, options);\n\t}\n\n\treturn index$3(abbr, options.profile, options.syntax, options.format);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String} Abbreviation to parse\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$1(abbr, options) {\n\treturn index(abbr)\n\t.use(index$1, options.snippets)\n\t.use(replaceVariables, options.variables)\n\t.use(index$2, options.text, options.addons);\n}\n\n/**\n * Expands given abbreviation into code\n * @param  {String|Node} abbr    Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {String}\n */\nfunction expand$2(abbr, options) {\n\toptions = options || {};\n\n\tif (typeof abbr === 'string') {\n\t\tabbr = parse$2(abbr, options);\n\t}\n\n\treturn index$6(abbr, options.profile, options.syntax, options.format);\n}\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n * @param {String|Node} Abbreviation to parse or already parsed abbreviation\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$2(abbr, options) {\n\tif (typeof abbr === 'string') {\n\t\tabbr = index$4(abbr);\n\t}\n\n\treturn abbr.use(index$5, options.snippets);\n}\n\nvar reLorem = /^lorem([a-z]*)(\\d*)$/;\n\n/**\n * Constructs a snippets registry, filled with snippets, for given options\n * @param  {String} syntax  Abbreviation syntax\n * @param  {Object|Object[]} snippets Additional snippets\n * @return {SnippetsRegistry}\n */\nvar snippetsRegistryFactory = function(syntax, snippets) {\n\tvar registrySnippets = [index$7[syntax] || index$7.html];\n\n\tif (Array.isArray(snippets)) {\n\t\tsnippets.forEach(function (item) {\n\t\t\t// if array item is a string, treat it as a reference to globally\n\t\t\t// defined snippets\n\t\t\tregistrySnippets.push(typeof item === 'string' ? index$7[item] : item);\n\t\t});\n\t} else if (typeof snippets === 'object') {\n\t\tregistrySnippets.push(snippets);\n\t}\n\n\tvar registry = new SnippetsRegistry(registrySnippets.filter(Boolean));\n\n\t// for non-stylesheet syntaxes add Lorem Ipsum generator\n\tif (syntax !== 'css') {\n\t\tregistry.get(0).set(reLorem, loremGenerator);\n\t}\n\n\treturn registry;\n};\n\nfunction loremGenerator(node) {\n\tvar options = {};\n\tvar m = node.name.match(reLorem);\n\tif (m[1]) {\n\t\toptions.lang = m[1];\n\t}\n\n\tif (m[2]) {\n\t\toptions.wordCount = +m[2];\n\t}\n\n\treturn index$8(node, options);\n}\n\n/**\n * Default variables used in snippets to insert common values into predefined snippets\n * @type {Object}\n */\nvar defaultVariables = {\n\tlang: 'en',\n\tlocale: 'en-US',\n\tcharset: 'UTF-8'\n};\n\n/**\n * A list of syntaxes that should use Emmet CSS abbreviations:\n * a variations of default abbreivation that holds values right in abbreviation name\n * @type {Set}\n */\nvar stylesheetSyntaxes = new Set(['css', 'sass', 'scss', 'less', 'stylus', 'sss']);\n\nvar defaultOptions = {\n\t/**\n\t * Abbreviation output syntax\n\t * @type {String}\n\t */\n\tsyntax: 'html',\n\n\t/**\n\t * Field/tabstop generator for editor. Most editors support TextMate-style\n\t * fields: ${0} or ${1:item}. So for TextMate-style fields this function\n\t * will look like this:\n\t * @example\n\t * (index, placeholder) => `\\${${index}${placeholder ? ':' + placeholder : ''}}`\n\t *\n\t * @param  {Number} index         Placeholder index. Fields with the same indices\n\t * should be linked\n\t * @param  {String} [placeholder] Field placeholder\n\t * @return {String}\n\t */\n\tfield: function (index$$1, placeholder) { return placeholder || ''; },\n\n\t/**\n\t * Insert given text string(s) into expanded abbreviation\n\t * If array of strings is given, the implicitly repeated element (e.g. `li*`)\n\t * will be repeated by the amount of items in array\n\t * @type {String|String[]}\n\t */\n\ttext: null,\n\n\t/**\n\t * Either predefined output profile or options for output profile. Used for\n\t * abbreviation output\n\t * @type {Profile|Object}\n\t */\n\tprofile: null,\n\n\t/**\n\t * Custom variables for variable resolver\n\t * @see @emmetio/variable-resolver\n\t * @type {Object}\n\t */\n\tvariables: {},\n\n\t/**\n\t * Custom predefined snippets for abbreviation. The expanded abbreviation\n\t * will try to match given snippets that may contain custom elements,\n\t * predefined attributes etc.\n\t * May also contain array of items: either snippets (Object) or references\n\t * to default syntax snippets (String; the key in default snippets hash)\n\t * @see @emmetio/snippets\n\t * @type {Object|SnippetsRegistry}\n\t */\n\tsnippets: {},\n\n\t/**\n\t * Hash of additional transformations that should be applied to expanded\n\t * abbreviation, like BEM or JSX. Since these transformations introduce\n\t * side-effect, they are disabled by default and should be enabled by\n\t * providing a transform name as a key and transform options as value:\n\t * @example\n\t * {\n\t *     bem: {element: '--'},\n\t *     jsx: true // no options, just enable transform\n\t * }\n\t * @see @emmetio/html-transform/lib/addons\n\t * @type {Object}\n\t */\n\taddons: null,\n\n\t/**\n\t * Additional options for syntax formatter\n\t * @see @emmetio/markup-formatters\n\t * @type {Object}\n\t */\n\tformat: null\n};\n\n/**\n * Expands given abbreviation into string, formatted according to provided\n * syntax and options\n * @param  {String|Node} abbr        Abbreviation string or parsed abbreviation tree\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {String}\n */\nfunction expand$$1(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn isStylesheet(options.syntax)\n\t\t? expand$2(abbr, options)\n\t\t: expand$1(abbr, options);\n}\n\n/**\n * Parses given abbreviation into AST tree. This tree can be later formatted to\n * string with `expand` function\n * @param  {String} abbr             Abbreviation to parse\n * @param  {String|Object} [options] Parsing and formatting options (object) or\n * abbreviation syntax (string)\n * @return {Node}\n */\nfunction parse$$1(abbr, options) {\n\toptions = createOptions(options);\n\n\treturn isStylesheet(options.syntax)\n\t\t? parse$2(abbr, options)\n\t\t: parse$1(abbr, options);\n}\n\n/**\n * Creates snippets registry for given syntax and additional `snippets`\n * @param  {String} syntax   Snippets syntax, used for retreiving predefined snippets\n * @param  {SnippetsRegistry|Object|Object[]} [snippets] Additional snippets\n * @return {SnippetsRegistry}\n */\nfunction createSnippetsRegistry(syntax, snippets) {\n\treturn snippets instanceof SnippetsRegistry\n\t\t? snippets\n\t\t: snippetsRegistryFactory(isStylesheet(syntax) ? 'css' : syntax, snippets);\n}\n\nfunction createOptions(options) {\n\tif (typeof options === 'string') {\n\t\toptions = { syntax: options };\n\t}\n\n\toptions = Object.assign({}, defaultOptions, options);\n\toptions.format = Object.assign({field: options.field}, options.format);\n\toptions.profile = createProfile(options);\n\toptions.variables = Object.assign({}, defaultVariables, options.variables);\n\toptions.snippets = createSnippetsRegistry(isStylesheet(options.syntax) ? 'css' : options.syntax, options.snippets);\n\n\treturn options;\n}\n\n/**\n * Check if given syntax belongs to stylesheet markup.\n * Emmet uses different abbreviation flavours: one is a default markup syntax,\n * used for HTML, Slim, Pug etc, the other one is used for stylesheets and\n * allows embedded values in abbreviation name\n * @param  {String}  syntax\n * @return {Boolean}\n */\nfunction isStylesheet(syntax) {\n\treturn stylesheetSyntaxes.has(syntax);\n}\n\n/**\n * Creates output profile from given options\n * @param  {Object} options\n * @return {Profile}\n */\nfunction createProfile(options) {\n\treturn options.profile instanceof Profile\n\t\t? options.profile\n\t\t: new Profile(options.profile);\n}\n\nvar Node$2 = function Node(stream, type, open, close) {\n\tthis.stream = stream;\n\tthis.type = type;\n\tthis.open = open;\n\tthis.close = close;\n\n\tthis.children = [];\n\tthis.parent = null;\n};\n\nvar prototypeAccessors$4 = { name: {},attributes: {},start: {},end: {},firstChild: {},nextSibling: {},previousSibling: {} };\n\n/**\n\t * Returns node name\n\t * @return {String}\n\t */\nprototypeAccessors$4.name.get = function () {\n\tif (this.type === 'tag' && this.open) {\n\t\treturn this.open && this.open.name && this.open.name.value;\n\t}\n\n\treturn '#' + this.type;\n};\n\n/**\n\t * Returns attributes of current node\n\t * @return {Array}\n\t */\nprototypeAccessors$4.attributes.get = function () {\n\treturn this.open && this.open.attributes;\n};\n\n/**\n\t * Returns nodes start position in stream\n\t * @return {*}\n\t */\nprototypeAccessors$4.start.get = function () {\n\treturn this.open && this.open.start;\n};\n\n/**\n\t * Returns nodes start position in stream\n\t * @return {*}\n\t */\nprototypeAccessors$4.end.get = function () {\n\treturn this.close ? this.close.end : this.open && this.open.end;\n};\n\nprototypeAccessors$4.firstChild.get = function () {\n\treturn this.children[0];\n};\n\nprototypeAccessors$4.nextSibling.get = function () {\n\tvar ix = this.getIndex();\n\treturn ix !== -1 ? this.parent.children[ix + 1] : null;\n};\n\nprototypeAccessors$4.previousSibling.get = function () {\n\tvar ix = this.getIndex();\n\treturn ix !== -1 ? this.parent.children[ix - 1] : null;\n};\n\n/**\n\t * Returns current elements index in parent list of child nodes\n\t * @return {Number}\n\t */\nNode$2.prototype.getIndex = function getIndex () {\n\treturn this.parent ? this.parent.children.indexOf(this) : -1;\n};\n\n/**\n\t * Adds given node as a child\n\t * @param {Node} node\n\t * @return {Node} Current node\n\t */\nNode$2.prototype.addChild = function addChild (node) {\n\tthis.removeChild(node);\n\tthis.children.push(node);\n\tnode.parent = this;\n\treturn this;\n};\n\n/**\n\t * Removes given node from current nodes child list\n\t * @param  {Node} node\n\t * @return {Node} Current node\n\t */\nNode$2.prototype.removeChild = function removeChild (node) {\n\tvar ix = this.children.indexOf(node);\n\tif (ix !== -1) {\n\t\tthis.children.splice(ix, 1);\n\t\tnode.parent = null;\n\t}\n\n\treturn this;\n};\n\nObject.defineProperties( Node$2.prototype, prototypeAccessors$4 );\n\n/**\n * A token factory method\n * @param  {StreamReader}   stream\n * @param  {Point|Function} start  Tokens start location or stream consumer\n * @param  {Point}          [end]  Tokens end location\n * @return {Token}\n */\nvar token = function(stream, start, end) {\n\treturn typeof start === 'function'\n\t\t? eatToken(stream, start)\n\t\t: new Token(stream, start, end);\n};\n\n/**\n * Consumes characters from given stream that matches `fn` call and returns it\n * as token, if consumed\n * @param  {StreamReader} stream\n * @param  {Function} test\n * @return {Token}\n */\nfunction eatToken(stream, test) {\n\tvar start = stream.pos;\n\tif (stream.eatWhile(test)) {\n\t\treturn new Token(stream, start, stream.pos);\n\t}\n\n\tstream.pos = start;\n}\n\n/**\n * A structure describing text fragment in content stream\n */\nvar Token = function Token(stream, start, end) {\n\tthis.stream = stream;\n\tthis.start = start != null ? start : stream.start;\n\tthis.end   = end   != null ? end   : stream.pos;\n\tthis._value = null;\n};\n\nvar prototypeAccessors$1$1 = { value: {} };\n\n/**\n\t * Returns token textual value\n\t * NB implemented as getter to reduce unnecessary memory allocations for\n\t * strings that not required\n\t * @return {String}\n\t */\nprototypeAccessors$1$1.value.get = function () {\n\tif (this._value === null) {\n\t\tvar start = this.stream.start;\n\t\tvar end = this.stream.pos;\n\n\t\tthis.stream.start = this.start;\n\t\tthis.stream.pos = this.end;\n\t\tthis._value = this.stream.current();\n\n\t\tthis.stream.start = start;\n\t\tthis.stream.pos = end;\n\t}\n\n\treturn this._value;\n};\n\nToken.prototype.toString = function toString () {\n\treturn this.value;\n};\n\nToken.prototype.valueOf = function valueOf () {\n\treturn ((this.value) + \" [\" + (this.start) + \"; \" + (this.end) + \"]\");\n};\n\nObject.defineProperties( Token.prototype, prototypeAccessors$1$1 );\n\nvar LANGLE  = 60;\nvar RANGLE  = 62;  // < and >\nvar LSQUARE = 91;\nvar RSQUARE = 93;  // [ and ]\nvar LROUND  = 40;\nvar RROUND  = 41;  // ( and )\nvar LCURLY$1  = 123;\nvar RCURLY$1  = 125; // { and }\n\nvar opt$2 = { throws: true };\n\n/**\n * Consumes paired tokens (like `[` and `]`) with respect of nesting and embedded\n * quoted values\n * @param  {StreamReader} stream\n * @return {Token} A token with consumed paired character\n */\nvar eatPaired = function(stream) {\n\tvar start = stream.pos;\n\tvar consumed = eatPair(stream, LANGLE, RANGLE, opt$2)\n\t\t|| eatPair(stream, LSQUARE, RSQUARE, opt$2)\n\t\t|| eatPair(stream, LROUND,  RROUND,  opt$2)\n\t\t|| eatPair(stream, LCURLY$1,  RCURLY$1,  opt$2);\n\n\tif (consumed) {\n\t\treturn token(stream, start);\n\t}\n};\n\nvar SLASH$1$1        = 47;  // /\nvar EQUALS$2       = 61;  // =\nvar RIGHT_ANGLE$1  = 62;  // >\n\n/**\n * Consumes attributes from given stream\n * @param {StreamReader} stream\n * @return {Array} Array of consumed attributes\n */\nvar eatAttributes = function(stream) {\n\tvar result = [];\n\tvar name, value, attr;\n\n\twhile (!stream.eof()) {\n\t\tstream.eatWhile(isSpace);\n\t\tattr = { start: stream.pos };\n\n\t\t// A name could be a regular name or expression:\n\t\t// React-style  <div {...props}>\n\t\t// Angular-style  <div [ng-for]>\n\t\tif (attr.name = eatAttributeName(stream)) {\n\t\t\t// Consumed attribute name. Can be an attribute with name\n\t\t\t// or boolean attribute. The value can be React-like expression\n\t\t\tif (stream.eat(EQUALS$2)) {\n\t\t\t\tattr.value = eatAttributeValue(stream);\n\t\t\t} else {\n\t\t\t\tattr.boolean = true;\n\t\t\t}\n\t\t\tattr.end = stream.pos;\n\t\t\tresult.push(attr);\n\t\t} else if (isTerminator(stream.peek())) {\n\t\t\t// look for tag terminator in order to skip any other possible characters\n\t\t\t// (maybe junk)\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Consumes attribute name from current location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeName(stream) {\n\treturn eatPaired(stream) || token(stream, isAttributeName);\n}\n\n/**\n * Consumes attribute value from given location\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatAttributeValue(stream) {\n\tvar start = stream.pos;\n\tif (eatQuoted$1(stream)) {\n\t\t// Should return token that points to unquoted value.\n\t\t// Use stream readers public API to traverse instead of direct\n\t\t// manipulation\n\t\tvar current = stream.pos;\n\t\tvar valueStart, valueEnd;\n\n\t\tstream.pos = start;\n\t\tstream.next();\n\t\tvalueStart = stream.start = stream.pos;\n\n\t\tstream.pos = current;\n\t\tstream.backUp(1);\n\t\tvalueEnd = stream.pos;\n\n\t\tvar result = token(stream, valueStart, valueEnd);\n\t\tstream.pos = current;\n\t\treturn result;\n\t}\n\n\treturn eatPaired(stream) || eatUnquoted$1(stream);\n}\n\n/**\n * Check if given code belongs to attribute name.\n * NB some custom HTML variations allow non-default values in name, like `*ngFor`\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isAttributeName(code) {\n\treturn code !== EQUALS$2 && !isTerminator(code) && !isSpace(code);\n}\n\n/**\n * Check if given code is tag terminator\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTerminator(code) {\n\treturn code === RIGHT_ANGLE$1 || code === SLASH$1$1;\n}\n\n/**\n * Eats unquoted value from stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatUnquoted$1(stream) {\n\treturn token(stream, isUnquoted$1);\n}\n\n/**\n * Check if given character code is valid unquoted value\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isUnquoted$1(code) {\n\treturn !isNaN(code) && !isQuote$1(code) && !isSpace(code) && !isTerminator(code);\n}\n\nvar DASH$2$1        = 45; // -\nvar DOT$2         = 46; // .\nvar SLASH$2       = 47; // /\nvar COLON$3       = 58; // :\nvar LEFT_ANGLE  = 60; // <\nvar RIGHT_ANGLE = 62; // >\nvar UNDERSCORE  = 95; // _\n\n/**\n * Parses tag definition (open or close tag) from given stream state\n * @param {StreamReader} stream Content stream reader\n * @return {Object}\n */\nvar tag = function(stream) {\n\tvar start = stream.pos;\n\n\tif (stream.eat(LEFT_ANGLE)) {\n\t\tvar model = { type: stream.eat(SLASH$2) ? 'close' : 'open' };\n\n\t\tif (model.name = eatTagName(stream)) {\n\t\t\tif (model.type !== 'close') {\n\t\t\t\tmodel.attributes = eatAttributes(stream);\n\t\t\t\tstream.eatWhile(isSpace);\n\t\t\t\tmodel.selfClosing = stream.eat(SLASH$2);\n\t\t\t}\n\n\t\t\tif (stream.eat(RIGHT_ANGLE)) {\n\t\t\t\t// tag properly closed\n\t\t\t\treturn Object.assign(token(stream, start), model);\n\t\t\t}\n\t\t}\n\t}\n\n\t// invalid tag, revert to original position\n\tstream.pos = start;\n\treturn null;\n};\n\n/**\n * Eats HTML identifier (tag or attribute name) from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nfunction eatTagName(stream) {\n\treturn token(stream, isTagName);\n}\n\n/**\n * Check if given character code can be used as HTML/XML tag name\n * @param  {Number}  code\n * @return {Boolean}\n */\nfunction isTagName(code) {\n\treturn isAlphaNumeric(code)\n\t\t|| code === COLON$3 // colon is used for namespaces\n\t\t|| code === DOT$2   // in rare cases declarative tag names may have dots in names\n\t\t|| code === DASH$2$1\n\t\t|| code === UNDERSCORE;\n}\n\n/**\n * Eats array of character codes from given stream\n * @param  {StreamReader} stream\n * @param  {Number[]} codes  Array of character codes\n * @return {Boolean}\n */\nfunction eatArray(stream, codes) {\n\tvar start = stream.pos;\n\n\tfor (var i = 0; i < codes.length; i++) {\n\t\tif (!stream.eat(codes[i])) {\n\t\t\tstream.pos = start;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstream.start = start;\n\treturn true;\n}\n\n/**\n * Consumes section from given string which starts with `open` character codes\n * and ends with `close` character codes\n * @param  {StreamReader} stream\n * @param  {Number[]} open\n * @param  {Number[]} close\n * @return {Boolean}  Returns `true` if section was consumed\n */\nfunction eatSection(stream, open, close, allowUnclosed) {\n\tvar start = stream.pos;\n\tif (eatArray(stream, open)) {\n\t\t// consumed `<!--`, read next until we find ending part or reach the end of input\n\t\twhile (!stream.eof()) {\n\t\t\tif (eatArray(stream, close)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream.next();\n\t\t}\n\n\t\t// unclosed section is allowed\n\t\tif (allowUnclosed) {\n\t\t\treturn true;\n\t\t}\n\n\t\tstream.pos = start;\n\t\treturn false;\n\t}\n\n\t// unable to find section, revert to initial position\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Converts given string into array of character codes\n * @param  {String} str\n * @return {Number[]}\n */\nfunction toCharCodes(str) {\n\treturn str.split('').map(function (ch) { return ch.charCodeAt(0); });\n}\n\nvar open  = toCharCodes('<!--');\nvar close = toCharCodes('-->');\n\n/**\n * Consumes HTML comment from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar comment = function(stream) {\n\tvar start = stream.pos;\n\tif (eatSection(stream, open, close, true)) {\n\t\tvar result = token(stream, start);\n\t\tresult.type = 'comment';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nvar open$1  = toCharCodes('<![CDATA[');\nvar close$1 = toCharCodes(']]>');\n\n/**\n * Consumes CDATA from given stream\n * @param  {StreamReader} stream\n * @return {Token}\n */\nvar cdata = function(stream) {\n\tvar start = stream.pos;\n\tif (eatSection(stream, open$1, close$1, true)) {\n\t\tvar result = token(stream, start);\n\t\tresult.type = 'cdata';\n\t\treturn result;\n\t}\n\n\treturn null;\n};\n\nvar defaultOptions$6 = {\n\t/**\n\t * Expect XML content in searching content. It alters how should-be-empty\n\t * elements are treated: for example, in XML mode parser will try to locate\n\t * closing pair for `<br>` tag\n\t * @type {Boolean}\n\t */\n\txml: false,\n\n\tspecial: ['script', 'style'],\n\n\t/**\n\t * List of elements that should be treated as empty (e.g. without closing tag)\n\t * in non-XML syntax\n\t * @type {Array}\n\t */\n\tempty: ['img', 'meta', 'link', 'br', 'base', 'hr', 'area', 'wbr']\n};\n\n/**\n * Parses given content into a DOM-like structure\n * @param  {String|StreamReader} content\n * @param  {Object} options\n * @return {Node}\n */\nfunction parse$3(content, options) {\n\toptions = Object.assign({}, defaultOptions$6, options);\n\tvar stream = typeof content === 'string'\n\t\t? new StreamReader$1(content)\n\t\t: content;\n\n\tvar root = new Node$2(stream, 'root');\n\tvar empty = new Set(options.empty);\n\tvar special = options.special.reduce(\n\t\tfunction (map, name) { return map.set(name, toCharCodes((\"</\" + name + \">\"))); }, new Map());\n\tvar isEmpty = function (token, name) { return token.selfClosing || (!options.xml && empty.has(name)); };\n\n\tvar m, node, name, stack = [root];\n\n\twhile (!stream.eof()) {\n\t\tif (m = match(stream)) {\n\t\t\tname = getName(m);\n\n\t\t\tif (m.type === 'open') {\n\t\t\t\t// opening tag\n\t\t\t\tnode = new Node$2(stream, 'tag', m);\n\t\t\t\tlast$1(stack).addChild(node);\n\t\t\t\tif (special.has(name)) {\n\t\t\t\t\tnode.close = consumeSpecial(stream, special.get(name));\n\t\t\t\t} else if (!isEmpty(m, name)) {\n\t\t\t\t\tstack.push(node);\n\t\t\t\t}\n\t\t\t} else if (m.type === 'close') {\n\t\t\t\t// closing tag, find its matching opening tag\n\t\t\t\tfor (var i = stack.length - 1; i > 0; i--) {\n\t\t\t\t\tif (stack[i].name.toLowerCase() === name) {\n\t\t\t\t\t\tstack[i].close = m;\n\t\t\t\t\t\tstack = stack.slice(0, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlast$1(stack).addChild(new Node$2(stream, m.type, m));\n\t\t\t}\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t}\n\n\treturn root;\n}\n\n/**\n * Matches known token in current state of given stream\n * @param  {ContentStreamReader} stream\n * @return {Token}\n */\nfunction match(stream) {\n\t// fast-path optimization: check for `<` code\n\tif (stream.peek() === 60 /* < */) {\n\t\treturn comment(stream) || cdata(stream) || tag(stream);\n\t}\n}\n\n/**\n * @param  {StreamReader} stream\n * @param  {Number[]} codes\n * @return {Token}\n */\nfunction consumeSpecial(stream, codes) {\n\tvar start = stream.pos;\n\tvar m;\n\n\twhile (!stream.eof()) {\n\t\tif (eatArray(stream, codes)) {\n\t\t\tstream.pos = stream.start;\n\t\t\treturn tag(stream);\n\t\t}\n\t\tstream.next();\n\t}\n\n\tstream.pos = start;\n\treturn null;\n}\n\n/**\n * Returns name of given matched token\n * @param  {Token} tag\n * @return {String}\n */\nfunction getName(tag$$1) {\n\treturn tag$$1.name ? tag$$1.name.value.toLowerCase() : (\"#\" + (tag$$1.type));\n}\n\nfunction last$1(arr) {\n\treturn arr[arr.length - 1];\n}\n\n/**\n * Syntaxes known by Emmet. All other syntaxes shoud map to one of these\n * @type {Set}\n */\nvar knownSyntaxes = new Set([\n\t'html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml',\n\t'css', 'sass', 'scss', 'less', 'sss', 'stylus'\n]);\n\n/**\n * Common context checker for abbreviation auto-activation for\n * stylesheet syntaxes (CSS, SCSS, LESS etc.)\n * @param  {CodeMirror} editor\n * @return {Boolean}\n */\nvar stylesheetAutoActivationContext = function (editor, pos) {\n\tvar tokenType = editor.getTokenTypeAt(pos || editor.getCursor());\n\t// NB may return `property` or `property error` type\n\treturn tokenType && /^property\\b/.test(tokenType);\n};\n\nvar autoActivationContext = {\n\thtml: function html(editor, pos) {\n\t\t// Do not provide automatic abbreviation completion inside HTML tags,\n\t\t// e.g. work only inside plain text token\n\t\treturn editor.getTokenTypeAt(pos || editor.getCursor()) === null;\n\t},\n\n\tcss:  stylesheetAutoActivationContext,\n\tless: stylesheetAutoActivationContext,\n\tsass: stylesheetAutoActivationContext,\n\tscss: stylesheetAutoActivationContext\n};\n\n/**\n * Detect Emmet syntax from given editors position.\n * @param {CodeMirror}     editor\n * @param {CodeMirror.Pos} [pos]\n * @return {String}        Returns `null` if Emmet syntax cant be detected\n */\nfunction detectSyntax(editor, pos) {\n\tvar mode = editor.getModeAt(pos || editor.getCursor());\n\tvar syntax = mode.name === 'xml' ? 'html' : mode.name;\n\n\tif (isSupported(syntax)) {\n\t\treturn syntax;\n\t}\n\n\t// No supported syntax found, try from Emmet-specific options\n\tvar emmetOpt = editor.getOption('emmet');\n\tif (emmetOpt && isSupported(emmetOpt.syntax)) {\n\t\treturn emmetOpt.syntax;\n\t}\n\n\treturn null;\n}\n\n/**\n * Check if given syntax is supported by Emmet\n * @param  {String}  syntax\n * @return {Boolean}\n */\nfunction isSupported(syntax) {\n\treturn knownSyntaxes.has(syntax);\n}\n\n/**\n * Check if current editors context (syntax, scope) allows automatic Emmet\n * abbreviation activation as user types text. If this function returns `false`,\n * it is recommended to not create any Emmet completions when user types text,\n * but insert them when user activated autocomplete popup manually\n * @param  {CodeMirror}  editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {Boolean}\n */\nfunction hasAutoActivateContext(editor, pos) {\n\tvar syntax = detectSyntax(editor, pos);\n\treturn syntax && (!autoActivationContext[syntax] || autoActivationContext[syntax](editor, pos));\n}\n\n/**\n * Returns token used for single indentation in given editor\n * @param  {CodeMirror} editor\n * @return {String}\n */\nfunction getIndentation(editor) {\n\tif (!editor.getOption('indentWithTabs')) {\n\t\treturn repeatString(' ', editor.getOption('indentUnit'));\n\t}\n\n\treturn '\\t';\n}\n\n/**\n * Normalizes text according to given CodeMirror instance indentation\n * preferences\n * @param  {String}     text\n * @param  {CodeMirror} editor\n * @param  {String}     [indentation] Applies `indentText()` with given argument,\n *                                    if provided\n * @return {String}\n */\nfunction normalizeText(editor, text, indentation) {\n\tvar lines = splitByLines(text);\n\tvar indent = getIndentation(editor);\n\n\tif (indent !== '\\t') {\n\t\tlines = lines.map(function (line) { return line.replace(/^\\t+/,\n\t\t\tfunction (tabs) { return repeatString(indent, tabs.length); }); });\n\t}\n\n\tif (indentation) {\n\t\tlines = lines.map(function (line, i) { return i ? indentation + line : line; });\n\t}\n\n\treturn lines.join('\\n');\n}\n\n/**\n * Indents each line, except first one, in given text\n * @param  {String} text\n * @param  {String} indentation\n * @return {String}\n */\n\n\n/**\n * Splits given text by lines\n * @param  {String} text\n * @return {String[]} Lines of text\n */\nfunction splitByLines(text) {\n\treturn Array.isArray(text) ? text : text.split(/\\r\\n|\\r|\\n/g);\n}\n\nfunction repeatString(str, count) {\n\tvar result = '';\n\twhile (0 < count--) {\n\t\tresult += str;\n\t}\n\n\treturn result;\n}\n\n/**\n * Quick and dirty way to remove fields from given string\n * @param  {String} str\n * @return {String}\n */\nfunction removeFields(str) {\n\treturn str.replace(/\\$\\{\\d+(:[^\\}]+)?\\}/g, '');\n}\n\n/**\n * Check if given range contains point\n * @param  {CodeMirror.Range} range\n * @param  {CodeMirror.Pos} pos\n * @param  {Boolean} [exclude] Exclude range and and start\n * @return {Boolean}\n */\nfunction containsPos(range, pos, exclude) {\n\treturn exclude\n\t\t? comparePos(pos, range.from) > 0 && comparePos(pos, range.to) < 0\n\t\t: comparePos(pos, range.from) >= 0 && comparePos(pos, range.to) <= 0;\n}\n\nfunction comparePos(a, b) {\n\treturn a.line - b.line || a.ch - b.ch;\n}\n\nvar cursorMark = '[[::emmet-cursor::]]';\n\n// NB CodeMirror doesnt natively supports tabstops\nvar editorField = function (index, placeholder) {\n\tif ( placeholder === void 0 ) placeholder = '';\n\n\treturn placeholder;\n};\n\n/**\n * Expands given abbreviation for given editor.\n * The editor is used to detect abbreviation syntax and provide\n * tag context for markup abbreviations\n * @param  {String|Node} abbr\n * @param  {CodeMirror}  editor\n * @return {String}\n * @throws Error if abbreviation is invalid\n */\nfunction expandAbbreviation(abbr, editor, options) {\n\treturn expand$$1(abbr, Object.assign({\n\t\tsyntax: detectSyntax(editor),\n\t\tfield: editorField\n\t}, getExpandOptions(editor), options));\n}\n\n/**\n * Parses abbreviation for given editor\n * @param  {String} abbr\n * @param  {CodeMirror} editor\n * @return {Node}\n * @throws Error if abbreviation is invalid\n */\nfunction parseAbbreviation(abbr, editor) {\n\treturn parse$$1(abbr, Object.assign({\n\t\tsyntax: detectSyntax(editor),\n\t}, getExpandOptions(editor)));\n}\n\n/**\n * Extracts abbreviation from given position of editor\n * @param  {CodeMirror}     editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {Object}         Object with `{abbreviation, location}` properties or `null`\n */\nfunction extractAbbreviation(editor, pos) {\n\tpos = pos || pos.getCursor();\n\tvar line = editor.getLine(pos.line);\n\n\treturn extractAbbreviation$1(line, pos.ch, true);\n}\n\n/**\n * Returns abbreviation model: object with `ast` and `snippet` properties\n * that contains parsed and expanded abbreviation respectively\n * @param  {String} abbreviation\n * @param  {CodeMirror} editor\n * @return {Object} Returns `null` if abbreviation cannot be parsed\n */\nfunction createAbbreviationModel(abbreviation, editor) {\n\ttry {\n\t\tvar ast = parseAbbreviation(abbreviation, editor);\n\t\treturn {\n\t\t\tast: ast,\n\t\t\tabbreviation: abbreviation,\n\t\t\tsnippet: expandAbbreviation(abbreviation, editor)\n\t\t};\n\t} catch (err) {\n\t\t// console.warn('Unable to build Emmet abbreviation model', err);\n\t\treturn null;\n\t}\n}\n\n/**\n * Expands given abbreviation and inserts expanded result into editor, maintaining\n * proper indentation and final cursor position\n * @param  {CodeMirror} editor CodeMirror editor instance\n * @param  {String|Object} abbr  Abbreviation to expand (string or parsed)\n * @param  {CodeMirror.Range} range Location of abbreviation in editor\n * @return {Boolean} Returns `true` if abbreviation was successfully expanded and inserted\n */\nfunction expandAndInsert(editor, abbr, range) {\n\tvar cursorMarked = false;\n\tvar newSelectionSize = 0;\n\tvar expanded;\n\n\ttry {\n\t\texpanded = expandAbbreviation(abbr, editor, {\n\t\t\t// CodeMirror doesnt support snippets with tab-stops natively so we have\n\t\t\t// to mark first output with a special token so we can find it later\n\t\t\t// to properly plant cursor into new position\n\t\t\tfield: function field(index, placeholder) {\n\t\t\t\tif ( placeholder === void 0 ) placeholder = '';\n\n\t\t\t\tif (!cursorMarked) {\n\t\t\t\t\tcursorMarked = true;\n\t\t\t\t\tnewSelectionSize = placeholder.length;\n\t\t\t\t\tplaceholder = cursorMark + placeholder;\n\t\t\t\t}\n\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t});\n\t} catch (err) {\n\t\t// Invalid abbreviation\n\t\t// console.warn(err);\n\t\treturn false;\n\t}\n\n\tvar line = editor.getLine(range.from.line);\n\tvar matchIndent = line.match(/^\\s+/);\n\texpanded = normalizeText(editor, expanded, matchIndent && matchIndent[0]);\n\n\tvar newCursorPos = expanded.length;\n\n\tif (cursorMarked) {\n\t\t// Remove cursor stub and re-position cursor\n\t\tnewCursorPos = expanded.indexOf(cursorMark);\n\t\texpanded = expanded.slice(0, newCursorPos) + expanded.slice(newCursorPos + cursorMark.length);\n\t}\n\n\t// Replace abbreviation with expanded result\n\treturn editor.operation(function () {\n\t\teditor.replaceRange(expanded, range.from, range.to);\n\n\t\t// Position cursor\n\t\tvar startIx = editor.indexFromPos(range.from);\n\t\tvar newCursor = editor.posFromIndex(newCursorPos + startIx);\n\t\tif (newSelectionSize) {\n\t\t\teditor.setSelection(newCursor, {\n\t\t\t\tline: newCursor.line,\n\t\t\t\tch: newCursor.ch + newSelectionSize\n\t\t\t});\n\t\t} else {\n\t\t\teditor.setCursor(newCursor);\n\t\t}\n\n\t\treturn true;\n\t});\n}\n\n/**\n * Returns options object for syntax from given editor. In most cases, it detects\n * XML-style syntax (HTML, XML, XHTML) and returns options configured for proper\n * output\n * @param  {CodeMirror} editor\n * @param  {Point}      [pos]  Point in editor where syntax should be detected.\n *                             Uses `editor.getCursor()` in not given\n * @return {Object}\n */\nfunction getExpandOptions(editor, pos) {\n\tvar mode = editor.getModeAt(pos || editor.getCursor());\n\tvar emmetOpt = editor.getOption('emmet');\n\tvar profile = emmetOpt && emmetOpt.profile;\n\n\tif (mode.name === 'xml') {\n\t\tprofile = Object.assign({ selfClosingStyle: mode.configuration }, profile);\n\t}\n\n\treturn Object.assign({\n\t\tprofile: profile,\n\t\tsnippets: snippetsFromOptions(editor, detectSyntax(editor, pos))\n\t}, emmetOpt);\n}\n\n/**\n * Returns custom snippets from Emmet options of given editor\n * @param  {CodeMirror} editor\n * @param  {String} syntax\n * @return {Object}\n */\nfunction snippetsFromOptions(editor, syntax) {\n\tvar emmetOpt = editor.getOption('emmet');\n\tif (emmetOpt) {\n\t\treturn isStylesheet(syntax)\n\t\t\t? emmetOpt.stylesheetSnippets\n\t\t\t: emmetOpt.markupSnippets;\n\t}\n}\n\nvar emmetMarkerClass = 'emmet-abbreviation';\n\n/**\n * Editors `change` event handler that marks Emmet abbreviation when editor\n * content is updated\n * @param  {CodeMirror} editor\n */\nfunction markOnEditorChange(editor) {\n\tvar marker = findMarker(editor, editor.getCursor());\n\tif (marker && isValidMarker(editor, marker)) {\n\t\treturn;\n\t}\n\n\t// No valid marker under caret, remove all registered markers\n\t// and create a new one\n\tclearMarkers(editor);\n\tif (hasAutoActivateContext(editor)) {\n\t\tmarkAbbreviation(editor, editor.getCursor());\n\t}\n}\n\n/**\n * Returns *valid* Emmet abbreviation marker (if any) for given position of editor\n * @param  {CodeMirror}     editor\n * @param  {CodeMirror.Pos} [pos]\n * @return {CodeMirror.TextMarker}\n */\nfunction findMarker(editor, pos) {\n\tvar markers = editor.findMarksAt(pos);\n\tfor (var i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\treturn markers[i];\n\t\t}\n\t}\n}\n\n/**\n * Marks Emmet abbreviation for given editor position, if possible\n * @param  {TextEditor} editor   Editor where abbreviation marker should be created\n * @param  {Point}      pos      Buffer position where abbreviation should be created.\n *                               Abbreviation will be automatically extracted from\n *                               given position\n * @param  {Boolean}    [forced] Indicates that user forcibly requested abbreviation\n *                               marker (e.g. was not activated automatically).\n *                               Affects abbreviation detection policy\n * @return {DisplayMarker} Returns `undefined` if no valid abbreviation under caret\n */\nfunction markAbbreviation(editor, pos, forced) {\n\tvar marker = findMarker(editor, pos);\n\tif (marker) {\n\t\t// theres active marker with valid abbreviation\n\t\treturn marker;\n\t}\n\n\t// No active marker: remove previous markers and create new one, if possible\n\tclearMarkers(editor);\n\n\tvar extracted = extractAbbreviation(editor, pos);\n\tvar model = extracted && createAbbreviationModel(extracted.abbreviation, editor);\n\n\tif (model && (forced || allowedForAutoActivation(model))) {\n\t\tvar from = { line: pos.line, ch: extracted.location };\n\t\tvar to = { line: pos.line, ch: extracted.location + extracted.abbreviation.length };\n\n\t\tvar marker$1 = editor.markText(from, to, {\n\t\t\tinclusiveRight: true,\n\t\t\tclearWhenEmpty: true,\n\t\t\tclassName: emmetMarkerClass\n\t\t});\n\t\tmarker$1.model = model;\n\t\treturn marker$1;\n\t}\n}\n\n/**\n * Removes Emmmet abbreviation markers from given editor\n * @param  {TextEditor} editor\n */\nfunction clearMarkers(editor) {\n\tvar markers = editor.getAllMarks();\n\tfor (var i = 0; i < markers.length; i++) {\n\t\tif (markers[i].className === emmetMarkerClass) {\n\t\t\tmarkers[i].clear();\n\t\t}\n\t}\n}\n\n/**\n * Check if given abbreviation model is allowed for auto-activated abbreviation\n * marker. Used to reduce falsy activations\n * @param  {Object} model Parsed abbreviation model (see `createAbbreviationModel()`)\n * @return {Boolean}\n */\nfunction allowedForAutoActivation(model) {\n\tvar rootNode = model.ast.children[0];\n\t// The very first node should start with alpha character\n\t// Skips falsy activations for something like `$foo` etc.\n\treturn rootNode && /^[a-z]/i.test(rootNode.name);\n}\n\n/**\n * Ensures that given editor Emmet abbreviation marker contains valid Emmet abbreviation\n * and updates abbreviation model if required\n * @param {CodeMirror} editor\n * @param {CodeMirror.TextMarket} marker\n * @return {Boolean} `true` if marker contains valid abbreviation\n */\nfunction isValidMarker(editor, marker) {\n\tvar range = marker.find();\n\n\t// No newlines inside abreviation\n\tif (range.from.line !== range.to.line) {\n\t\treturn false;\n\t}\n\n\t// Make sure marker contains valid abbreviation\n\tvar text = editor.getRange(range.from, range.to);\n\tif (!text || /^\\s|\\s$/g.test(text)) {\n\t\treturn false;\n\t}\n\n\tif (!marker.model || marker.model.abbreviation !== text) {\n\t\t// marker contents was updated, re-parse abbreviation\n\t\tmarker.model = createAbbreviationModel(text, editor);\n\t}\n\n\treturn !!(marker.model && marker.model.snippet);\n}\n\n/**\n * Expand abbreviation command\n * @param  {CodeMirror} editor\n */\nvar emmetExpandAbbreviation = function(editor) {\n\tif (editor.somethingSelected()) {\n\t\treturn editor.constructor.Pass;\n\t}\n\n\tvar pos = editor.getCursor();\n\tvar marker = findMarker(editor, pos);\n\n\tvar result = false;\n\n\t// Handle two possible options: expand abbreviation from Emmet marker that\n\t// matches given location or extract & expand abbreviation from cursor\n\t// position. The last one may happen if either `markeEmmetAbbreviation`\n\t// option is turned off or user moved cursor away from Emmet marker and\n\t// tries to expand another abbreviation\n\n\tif (marker) {\n\t\tresult = expandAndInsert(editor, marker.model.ast, marker.find());\n\t} else {\n\t\tvar abbrData = extractAbbreviation(editor, pos);\n\t\tif (abbrData) {\n\t\t\tvar range = {\n\t\t\t\tfrom: {\n\t\t\t\t\tline: pos.line,\n\t\t\t\t\tch: abbrData.location\n\t\t\t\t},\n\t\t\t\tto: {\n\t\t\t\t\tline: pos.line,\n\t\t\t\t\tch: abbrData.location + abbrData.abbreviation.length\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tresult = expandAndInsert(editor, abbrData.abbreviation, range);\n\t\t}\n\t}\n\n\tclearMarkers(editor);\n\n\t// If no abbreviation was expanded, allow editor to handle different\n\t// action for keyboard shortcut (Tab key mostly)\n\treturn result || editor.constructor.Pass;\n};\n\n/**\n * Inserts formatted line tag between tags\n * @param  {CodeMirror} editor\n */\nvar emmetInsertLineBreak = function(editor) {\n\tvar cursor = editor.getCursor();\n\tvar mode = editor.getModeAt(cursor);\n\n\tif (mode.name === 'xml') {\n\t\tvar next = Object.assign({}, cursor, { ch: cursor.ch + 1 });\n\t\tvar left = editor.getTokenAt(cursor);\n\t\tvar right = editor.getTokenAt(Object.assign({}, cursor, { ch: cursor.ch + 1 }));\n\n\t\tif (left.type === 'tag bracket' && left.string === '>'\n\t\t\t&& right.type === 'tag bracket' && right.string === '</') {\n\t\t\t\tvar matchIndent = editor.getLine(cursor.line).match(/^\\s+/);\n\t\t\t\tvar curIndent = matchIndent ? matchIndent[0] : '';\n\t\t\t\tvar indent = getIndentation(editor);\n\n\t\t\t\t// Insert formatted line break\n\t\t\t\tvar before = \"\\n\" + curIndent + indent;\n\t\t\t\tvar after = \"\\n\" + curIndent;\n\t\t\t\teditor.replaceRange(before + after, cursor, cursor);\n\n\t\t\t\t// Position cursor\n\t\t\t\tvar startIx = editor.indexFromPos(cursor);\n\t\t\t\tvar newCursor = editor.posFromIndex(startIx + before.length);\n\t\t\t\teditor.setCursor(newCursor);\n\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\n\treturn editor.constructor.Pass;\n};\n\n/**\n * Returns available completions from given editor\n * @param  {CodeMirror}      editor\n * @param  {String}          abbrModel   Parsed Emmet abbreviation model for which\n *                                       completions should be populated\n *                                       (see `createAbbreviationModel()`)\n * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor\n * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nvar autocompleteProvider = function(editor, abbrModel, abbrPos, cursorPos) {\n\tcursorPos = cursorPos || editor.getCursor();\n\tvar syntax = detectSyntax(editor, cursorPos);\n\tif (!syntax) {\n\t\t// Unsupported syntax\n\t\treturn [];\n\t}\n\n\treturn isStylesheet(syntax)\n\t\t? getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos)\n\t\t: getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos);\n};\n\n/**\n * Returns completions for markup syntaxes (HTML, Slim, Pug etc.)\n * @param  {CodeMirror}      editor\n * @param  {Object}          abbrModel   Parsed Emmet abbreviation model for which\n *                                       completions should be populated\n *                                       (see `createAbbreviationModel()`)\n * @param  {CodeMirror.Pos}  abbrPos     Abbreviation location in editor\n * @param  {CodeMirror.Pos}  [cursorPos] Cursor position in editor\n * @return {EmmetCompletion[]}\n */\nfunction getMarkupCompletions(editor, abbrModel, abbrPos, cursorPos) {\n\tvar result = [];\n\tcursorPos = cursorPos || editor.getCursor();\n\n\tvar abbrRange = {\n\t\tfrom: abbrPos,\n\t\tto: { line: abbrPos.line, ch: abbrPos.ch + abbrModel.abbreviation.length }\n\t};\n\n\tresult.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',\n\t\tabbrModel.snippet, function () { return expandAndInsert(editor, abbrModel.abbreviation, abbrRange); }));\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tvar prefix = getMarkupPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);\n\tif (prefix !== null) {\n\t\tvar prefixRange = {\n\t\t\tfrom: { line: cursorPos.line, ch: cursorPos.ch - prefix.length },\n\t\t\tto: cursorPos\n\t\t};\n\n\t\tvar completions = getSnippetCompletions(editor, cursorPos)\n\t\t.filter(function (snippet) { return snippet.key !== prefix && snippet.key.indexOf(prefix) === 0; })\n\t\t.map(function (snippet) { return new EmmetCompletion('snippet', editor, prefixRange, snippet.key,\n\t\t\tsnippet.preview, snippet.key); });\n\n\t\tresult = result.concat(completions);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns completions for stylesheet syntaxes\n * @param  {CodeMirror} editor\n * @param  {Object} abbrModel\n * @param  {CodeMirror.Pos} abbrPos\n * @param  {CodeMirror.Pos} cursorPos\n * @return {EmmetCompletion[]}\n */\nfunction getStylesheetCompletions(editor, abbrModel, abbrPos, cursorPos) {\n\tvar result = [];\n\tcursorPos = cursorPos || editor.getCursor();\n\n\tvar abbrRange = {\n\t\tfrom: abbrPos,\n\t\tto: { line: abbrPos.line, ch: abbrPos.ch + abbrModel.abbreviation.length }\n\t};\n\n\tresult.push(new EmmetCompletion('expanded-abbreviation', editor, abbrRange, 'Expand abbreviation',\n\t\tabbrModel.snippet, function () { return expandAndInsert(editor, abbrModel.abbreviation, abbrRange); }));\n\n\t// Make sure that current position precedes element name (e.g. not attribute,\n\t// class, id etc.)\n\tvar prefix = getStylesheetPrefix(abbrModel.abbreviation, cursorPos.ch - abbrPos.ch);\n\tif (prefix !== null) {\n\t\tvar prefixRange = {\n\t\t\tfrom: { line: cursorPos.line, ch: cursorPos.ch - prefix.length },\n\t\t\tto: cursorPos\n\t\t};\n\n\t\tvar completions = getSnippetCompletions(editor, cursorPos)\n\t\t.filter(function (snippet) { return snippet.key !== prefix && snippet.key.indexOf(prefix) === 0; })\n\t\t.map(function (snippet) { return new EmmetCompletion('snippet', editor, prefixRange,\n\t\t\tsnippet.key, snippet.preview, snippet.key); });\n\n\t\tresult = result.concat(completions);\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns all possible snippets completions for given editor context.\n * Completions are cached in editor for for re-use\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Array}\n */\nfunction getSnippetCompletions(editor, pos) {\n\tvar syntax = detectSyntax(editor, pos);\n\n\tif (!editor.state.emmetCompletions) {\n\t\teditor.state.emmetCompletions = {};\n\t}\n\n\tvar cache = editor.state.emmetCompletions;\n\n\tif (!(syntax in cache)) {\n\t\tvar registry = createSnippetsRegistry(syntax, snippetsFromOptions(editor, syntax));\n\n\t\tif (isStylesheet(syntax)) {\n\t\t\t// Collect snippets for stylesheet context: just a plain list of\n\t\t\t// snippets, converted specifically for CSS context\n\t\t\tcache[syntax] = convertToCSSSnippets(registry).map(function (snippet) {\n\t\t\t\tvar preview = snippet.property;\n\t\t\t\tvar keywords = snippet.keywords();\n\t\t\t\tif (keywords.length) {\n\t\t\t\t\tpreview += \": \" + (removeFields(keywords.join(' | ')));\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tkey: snippet.key,\n\t\t\t\t\tvalue: snippet.value,\n\t\t\t\t\tkeywords: keywords,\n\t\t\t\t\tpreview: preview\n\t\t\t\t};\n\t\t\t});\n\t\t} else {\n\t\t\t// Collect snippets for markup syntaxes: HTML, XML, Slim, Pug etc.\n\t\t\t// Not just a plain snippets list but thier expanded result as well\n\t\t\tvar field = function (index, placeholder) { return placeholder || ''; };\n\t\t\tvar expandOpt = { syntax: syntax, field: field };\n\n\t\t\tcache[syntax] = registry.all({type: 'string'}).map(function (snippet) { return ({\n\t\t\t\tkey: snippet.key,\n\t\t\t\tvalue: snippet.value,\n\t\t\t\tpreview: expandAbbreviation(snippet.value, editor, expandOpt)\n\t\t\t}); });\n\t\t}\n\t}\n\n\treturn cache[syntax];\n}\n\n/**\n * Returns node element prefix, if applicable, for given `pos` in abbreviation\n * for markup syntaxes completions\n * @param  {String} abbr\n * @param  {Number} pos\n * @return {String} Returns `null` if not in element name context\n */\nfunction getMarkupPrefix(abbr, pos) {\n\treturn getPrefix(abbr, pos, /[\\w:\\-\\$@]+$/);\n}\n\n/**\n * Returns node element prefix, if applicable, for given `pos` in abbreviation\n * for stylesheet syntaxes completions\n * @param  {String} abbr\n * @param  {Number} pos\n * @return {String} Returns `null` if not in element name context\n */\nfunction getStylesheetPrefix(abbr, pos) {\n\treturn getPrefix(abbr, pos, /[\\w-@$]+$/);\n}\n\n/**\n * Get snippet completion prefix that matches given `match` regexp from `pos`\n * character pasition of given `abbr` abbreviation\n * @param  {String} abbr\n * @param  {Number} pos\n * @param  {RegExp} match\n * @return {String}\n */\nfunction getPrefix(abbr, pos, match$$1) {\n\tif (pos === 0) {\n\t\t// Word prefix is at the beginning of abbreviation: its an element\n\t\t// context for sure\n\t\treturn '';\n\t}\n\n\tvar m = abbr.slice(0, pos).match(match$$1);\n\tvar prefix = m && m[0] || '';\n\n\t// Check if matched prefix is either at the beginning of abbreviation or\n\t// at the element bound, e.g. right after operator\n\tif (prefix && (prefix === abbr || /[>\\^\\+\\(\\)]/.test(abbr[pos - prefix.length - 1]))) {\n\t\treturn prefix;\n\t}\n\n\treturn null;\n}\n\nvar EmmetCompletion = function EmmetCompletion(type, editor, range, label, preview, snippet) {\n\tthis.type = type;\n\tthis.editor = editor;\n\tthis.range = range;\n\tthis.label = label;\n\tthis.preview = preview;\n\tthis.snippet = snippet;\n\n\tthis._inserted = false;\n};\n\nEmmetCompletion.prototype.insert = function insert () {\n\tif (!this._inserted) {\n\t\tthis._inserted = true;\n\t\tif (typeof this.snippet === 'function') {\n\t\t\tthis.snippet(this.editor, this.range);\n\t\t} else {\n\t\t\tthis.editor.replaceRange(this.snippet, this.range.from, this.range.to);\n\n\t\t\t// Position cursor\n\t\t\tvar startIx = this.editor.indexFromPos(this.range.from);\n\t\t\tvar newCursor = this.editor.posFromIndex(startIx + this.snippet.length);\n\t\t\tthis.editor.setCursor(newCursor);\n\t\t}\n\t}\n};\n\n/**\n * A syntax-specific model container, used to get unified access to underlying\n * parsed document\n */\nvar SyntaxModel = function SyntaxModel(dom, type, syntax) {\n\tthis.dom = dom;\n\tthis.type = type;\n\tthis.syntax = syntax;\n};\n\n/**\n\t * Returns best matching node for given point\n\t * @param  {CodeMirror.Pos}   pos\n\t * @param  {Boolean} [exclude] Exclude nodes start and end positions from\n\t *                             search\n\t * @return {Node}\n\t */\nSyntaxModel.prototype.nodeForPoint = function nodeForPoint (pos, exclude) {\n\tvar ctx = this.dom.firstChild;\n\tvar found = null;\n\n\twhile (ctx) {\n\t\tif (containsPos(range(ctx), pos, exclude)) {\n\t\t\t// Found matching tag. Try to find deeper, more accurate match\n\t\t\tfound = ctx;\n\t\t\tctx = ctx.firstChild;\n\t\t} else {\n\t\t\tctx = ctx.nextSibling;\n\t\t}\n\t}\n\n\treturn found;\n};\n\nfunction range(node) {\n\treturn {\n\t\tfrom: node.start,\n\t\tto: node.end\n\t};\n}\n\nvar LINE_END = 10; // \\n\n\n/**\n * A stream reader for CodeMirror editor\n */\nvar CodeMirrorStreamReader = (function (StreamReader) {\n\tfunction CodeMirrorStreamReader(editor, pos, limit) {\n\t\tStreamReader.call(this);\n\t\tvar CodeMirror = editor.constructor;\n\t\tthis.editor = editor;\n\t\tthis.start = this.pos = pos || CodeMirror.Pos(0, 0);\n\n\t\tvar lastLine = editor.lastLine();\n\t\tthis._eof = limit ? limit.to   : CodeMirror.Pos(lastLine, this._lineLength(lastLine));\n\t\tthis._sof = limit ? limit.from : CodeMirror.Pos(0, 0);\n\t}\n\n\tif ( StreamReader ) CodeMirrorStreamReader.__proto__ = StreamReader;\n\tCodeMirrorStreamReader.prototype = Object.create( StreamReader && StreamReader.prototype );\n\tCodeMirrorStreamReader.prototype.constructor = CodeMirrorStreamReader;\n\n\t/**\n\t * Returns true only if the stream is at the beginning of the file.\n\t * @returns {Boolean}\n\t */\n\tCodeMirrorStreamReader.prototype.sof = function sof () {\n\t\treturn comparePos(this.pos, this._sof) <= 0;\n\t};\n\n\t/**\n\t * Returns true only if the stream is at the end of the file.\n\t * @returns {Boolean}\n\t */\n\tCodeMirrorStreamReader.prototype.eof = function eof () {\n\t\treturn comparePos(this.pos, this._eof) >= 0;\n\t};\n\n\t/**\n\t * Creates a new stream instance which is limited to given `start` and `end`\n\t * points for underlying buffer\n\t * @param  {CodeMirror.Pos} start\n\t * @param  {CodeMirror.Pos} end\n\t * @return {CodeMirrorStreamReader}\n\t */\n\tCodeMirrorStreamReader.prototype.limit = function limit (from, to) {\n\t\treturn new this.constructor(this.editor, from, { from: from, to: to });\n\t};\n\n\t/**\n\t * Returns the next character code in the stream without advancing it.\n\t * Will return NaN at the end of the file.\n\t * @returns {Number}\n\t */\n\tCodeMirrorStreamReader.prototype.peek = function peek () {\n\t\tvar ref = this.pos;\n\t\tvar line = ref.line;\n\t\tvar ch = ref.ch;\n\t\tvar lineStr = this.editor.getLine(this.pos.line);\n\t\treturn ch < lineStr.length ? lineStr.charCodeAt(ch) : LINE_END;\n\t};\n\n\t/**\n\t * Returns the next character in the stream and advances it.\n\t * Also returns NaN when no more characters are available.\n\t * @returns {Number}\n\t */\n\tCodeMirrorStreamReader.prototype.next = function next () {\n\t\tif (!this.eof()) {\n\t\t\tvar code = this.peek();\n\t\t\tthis.pos = Object.assign({}, this.pos, { ch: this.pos.ch + 1 });\n\n\t\t\tif (this.pos.ch >= this._lineLength(this.pos.line)) {\n\t\t\t\tthis.pos.line++;\n\t\t\t\tthis.pos.ch = 0;\n\t\t\t}\n\n\t\t\tif (this.eof()) {\n\t\t\t\t// handle edge case where position can move on next line\n\t\t\t\t// after EOF\n\t\t\t\tthis.pos = Object.assign({}, this._eof);\n\t\t\t}\n\n\t\t\treturn code;\n\t\t}\n\n\t\treturn NaN;\n\t};\n\n\t/**\n\t * Backs up the stream n characters. Backing it up further than the\n\t * start of the current token will cause things to break, so be careful.\n\t * @param {Number} n\n\t */\n\tCodeMirrorStreamReader.prototype.backUp = function backUp (n) {\n\t\tvar this$1 = this;\n\n\t\tvar CodeMirror = this.editor.constructor;\n\n\t\tvar ref = this.pos;\n\t\tvar line = ref.line;\n\t\tvar ch = ref.ch;\n\t\tch -= (n || 1);\n\n\t\twhile (line >= 0 && ch < 0) {\n\t\t\tline--;\n\t\t\tch += this$1._lineLength(line);\n\t\t}\n\n\t\tthis.pos = line < 0 || ch < 0\n\t\t\t? CodeMirror.Pos(0, 0)\n\t\t\t: CodeMirror.Pos(line, ch);\n\n\t\treturn this.peek();\n\t};\n\n\t/**\n\t * Get the string between the start of the current token and the\n\t * current stream position.\n\t * @returns {String}\n\t */\n\tCodeMirrorStreamReader.prototype.current = function current () {\n\t\treturn this.substring(this.start, this.pos);\n\t};\n\n\t/**\n\t * Returns contents for given range\n\t * @param  {Point} from\n\t * @param  {Point} to\n\t * @return {String}\n\t */\n\tCodeMirrorStreamReader.prototype.substring = function substring (from, to) {\n\t\treturn this.editor.getRange(from, to);\n\t};\n\n\t/**\n\t * Creates error object with current stream state\n\t * @param {String} message\n\t * @return {Error}\n\t */\n\tCodeMirrorStreamReader.prototype.error = function error (message) {\n\t\tvar err = new Error((message + \" at line \" + (this.pos.line) + \", column \" + (this.pos.ch)));\n\t\terr.originalMessage = message;\n\t\terr.pos = this.pos;\n\t\terr.string = this.string;\n\t\treturn err;\n\t};\n\n\t/**\n\t * Returns length of given line, including line ending\n\t * @param  {Number} line\n\t * @return {Number}\n\t */\n\tCodeMirrorStreamReader.prototype._lineLength = function _lineLength (line) {\n\t\tvar isLast = line === this.editor.lastLine();\n\t\treturn this.editor.getLine(line).length + (isLast ? 0 : 1);\n\t};\n\n\treturn CodeMirrorStreamReader;\n}(StreamReader$1));\n\n/**\n * Creates DOM-like model for given text editor\n * @param  {CodeMirror} editor\n * @param  {String}     syntax\n * @return {Node}\n */\nfunction create(editor, syntax) {\n\tvar stream = new CodeMirrorStreamReader(editor);\n\tvar xml = syntax === 'xml';\n\n\ttry {\n\t\treturn new SyntaxModel(parse$3(stream, { xml: xml }), 'html', syntax || 'html');\n\t} catch (err) {\n\t\tconsole.warn(err);\n\t}\n}\n\nfunction getModel(editor) {\n\tvar syntax = getSyntax(editor);\n\treturn create(editor, syntax);\n}\n\nfunction getCachedModel(editor) {\n\tif (!editor.state._emmetModel) {\n\t\teditor.state._emmetModel = getModel(editor);\n\t}\n\n\treturn editor.state._emmetModel;\n}\n\nfunction resetCachedModel(editor) {\n\teditor.state._emmetModel = null;\n}\n\n/**\n * Returns parser-supported syntax of given editor (like 'html', 'css' etc.).\n * Returns `null` if editors syntax is unsupported\n * @param  {CodeMirror} editor\n * @return {String}\n */\nfunction getSyntax(editor) {\n\tvar mode = editor.getMode();\n\n\tif (mode.name === 'htmlmixed') {\n\t\treturn 'html';\n\t}\n\n\treturn mode.name === 'xml' ? mode.configuration : mode.name;\n}\n\nvar openTagMark = 'emmet-open-tag';\nvar closeTagMark = 'emmet-close-tag';\n\n/**\n * Finds matching tag pair for given position in editor\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Object}\n */\nfunction matchTag(editor, pos) {\n\tpos = pos || editor.getCursor();\n\n\t// First, check if there are tag markers in editor\n\tvar marked = getMarkedTag(editor);\n\n\t// If marks found, validate them: make sure cursor is either in open\n\t// or close tag\n\tif (marked) {\n\t\tif (containsPos(marked.open.find(), pos)) {\n\t\t\t// Point is inside open tag, make sure if theres a closing tag,\n\t\t\t// it matches open tag content\n\t\t\tif (!marked.close || text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t} else if (marked.close) {\n\t\t\t// Theres a close tag, make sure pointer is inside it and it matches\n\t\t\t// open tag\n\t\t\tif (containsPos(marked.close.find(), pos) && text(editor, marked.open) === text(editor, marked.close)) {\n\t\t\t\treturn marked;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Markers are not valid anymore, remove them\n\tclearTagMatch(editor);\n\n\t// Find new tag pair from parsed HTML model and mark them\n\tvar node = findTagPair(editor, pos);\n\tif (node && node.type === 'tag') {\n\t\treturn {\n\t\t\topen: createTagMark(editor, node.open.name, openTagMark),\n\t\t\tclose: node.close && createTagMark(editor, node.close.name, closeTagMark)\n\t\t};\n\t}\n}\n\nfunction getMarkedTag(editor) {\n\tvar open, close;\n\teditor.getAllMarks().forEach(function (mark) {\n\t\tif (mark.className === openTagMark) {\n\t\t\topen = mark;\n\t\t} else if (mark.className === closeTagMark) {\n\t\t\tclose = mark;\n\t\t}\n\t});\n\n\treturn open ? { open: open, close: close } : null;\n}\n\n/**\n * Removes all matched tag pair markers from editor\n * @param  {CodeMirror} editor\n */\nfunction clearTagMatch(editor) {\n\teditor.getAllMarks().forEach(function (mark) {\n\t\tif (mark.className === openTagMark || mark.className === closeTagMark) {\n\t\t\tmark.clear();\n\t\t}\n\t});\n}\n\n/**\n * Finds tag pair (open and close, if any) form parsed HTML model of given editor\n * @param  {CodeMirror} editor\n * @param  {CodeMirror.Pos} pos\n * @return {Object}\n */\nfunction findTagPair(editor, pos) {\n\tvar model = editor.getEmmetDocumentModel();\n\treturn model && model.nodeForPoint(pos || editor.getCursor());\n}\n\nfunction createTagMark(editor, tag, className) {\n\treturn editor.markText(tag.start, tag.end, {\n\t\tclassName: className,\n\t\tinclusiveLeft: true,\n\t\tinclusiveRight: true,\n\t\tclearWhenEmpty: false\n\t});\n}\n\nfunction text(editor, mark) {\n\tvar range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n\nfunction renameTag(editor, obj) {\n\tvar tag = getMarkedTag(editor);\n\tvar pos = obj.from;\n\n\tif (!tag) {\n\t\treturn;\n\t}\n\n\tif (containsPos(tag.open.find(), pos) && tag.close) {\n\t\t// Update happened inside open tag, update close tag as well\n\t\tupdateTag(editor, tag.open, tag.close);\n\t} else if (tag.close && containsPos(tag.close.find(), pos)) {\n\t\t// Update happened inside close tag, update open tag as well\n\t\tupdateTag(editor, tag.close, tag.open);\n\t}\n}\n\nfunction updateTag(editor, source, dest) {\n\tvar name = text$1(editor, source);\n\tvar range = dest.find();\n\tvar m = name.match(/[\\w:\\-]+/);\n\tvar newName = !name ? '' : (m && m[0]);\n\n\tif (newName != null) {\n\t\tif (editor.getRange(range.from, range.to) !== newName) {\n\t\t\teditor.replaceRange(newName, range.from, range.to);\n\t\t}\n\t} else {\n\t\t// User entered something that wasnt a valid tag name.\n\t\tclearTagMatch(editor);\n\t}\n}\n\nfunction text$1(editor, mark) {\n\tvar range = mark.find();\n\treturn range ? editor.getRange(range.from, range.to) : '';\n}\n\nvar commands = { emmetExpandAbbreviation: emmetExpandAbbreviation, emmetInsertLineBreak: emmetInsertLineBreak };\n\n/**\n * Registers Emmet extension on given CodeMirror constructor.\n * This file is designed to be imported somehow into the app (CommonJS, ES6,\n * Rollup/Webpack/whatever). If you simply want to add a <script> into your page\n * that registers Emmet extension on global CodeMirror constructor, use\n * `browser.js` instead\n */\nfunction registerEmmetExtension(CodeMirror) {\n\t// Register Emmet commands\n\tObject.assign(CodeMirror.commands, commands);\n\n\t// Defines options that allows abbreviation marking in text editor\n\tCodeMirror.defineOption('markEmmetAbbreviation', true, function (editor, value) {\n\t\tif (value) {\n\t\t\teditor.on('change', markOnEditorChange);\n\t\t} else {\n\t\t\teditor.off('change', markOnEditorChange);\n\t\t\tclearMarkers(editor);\n\t\t}\n\t});\n\n\tCodeMirror.defineOption('autoRenameTags', true, function (editor, value) {\n\t\tvalue ? editor.on('change', renameTag) : editor.off('change', renameTag);\n\t});\n\n\tCodeMirror.defineOption('markTagPairs', false, function (editor, value) {\n\t\tif (value) {\n\t\t\teditor.on('cursorActivity', matchTag);\n\t\t\teditor.on('change', resetCachedModel);\n\t\t} else {\n\t\t\teditor.off('cursorActivity', matchTag);\n\t\t\teditor.off('change', resetCachedModel);\n\t\t\tresetCachedModel(editor);\n\t\t\tclearTagMatch(editor);\n\t\t}\n\t});\n\n\t// Additional options for Emmet, for Expand Abbreviation action mostly:\n\t// https://github.com/emmetio/expand-abbreviation/blob/master/index.js#L26\n\tCodeMirror.defineOption('emmet', {});\n\n\t/**\n\t * Returns Emmet completions for context from `pos` position.\n\t * Abbreviations are calculated for marked abbreviation at given position.\n\t * If no parsed abbreviation marker is available and `force` argument is\n\t * given, tries to mark abbreviation and populate completions list again.\n\t * @param  {CodeMirror.Pos} [pos]\n\t * @param  {Boolean}        [force]\n\t * @return {EmmetCompletion[]}\n\t */\n\tCodeMirror.defineExtension('getEmmetCompletions', function(pos, force) {\n\t\tvar editor = this;\n\t\tif (typeof pos === 'boolean') {\n\t\t\tforce = pos;\n\t\t\tpos = null;\n\t\t}\n\n\t\tvar abbrRange, list;\n\n\t\tpos = pos || editor.getCursor();\n\t\tif (editor.getOption('markEmmetAbbreviation')) {\n\t\t\t// Get completions from auto-inserted marker\n\t\t\tvar marker = findMarker(editor, pos) || (force && markAbbreviation(editor, pos, true));\n\t\t\tif (marker) {\n\t\t\t\tabbrRange = marker.find();\n\t\t\t\tlist = autocompleteProvider(editor, marker.model, abbrRange.from, pos);\n\t\t\t}\n\t\t} else {\n\t\t\t// No abbreviation auto-marker, try to extract abbreviation from given\n\t\t\t// cursor location\n\t\t\tvar extracted = extractAbbreviation(editor, pos);\n\t\t\tif (extracted) {\n\t\t\t\tvar model = createAbbreviationModel(extracted.abbreviation, editor);\n\t\t\t\tif (model) {\n\t\t\t\t\tabbrRange = {\n\t\t\t\t\t\tfrom: { line: pos.line, ch: extracted.location },\n\t\t\t\t\t\tto: { line: pos.line, ch: extracted.location + extracted.abbreviation.length }\n\t\t\t\t\t};\n\t\t\t\t\tlist = autocompleteProvider(editor, model, abbrRange.from, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (list && list.length) {\n\t\t\treturn {\n\t\t\t\tfrom: abbrRange.from,\n\t\t\t\tto: abbrRange.to,\n\t\t\t\tlist: list\n\t\t\t};\n\t\t}\n\t});\n\n\t/**\n\t * Returns valid Emmet abbreviation and its location in editor from given\n\t * position\n\t * @param  {CodeMirror.Pos} [pos] Position from which abbreviation should be\n\t *                                extracted. If not given, current cursor\n\t *                                position is used\n\t * @return {Object} Object with `abbreviation` and `location` properties\n\t * or `null` if theres no valid abbreviation\n\t */\n\tCodeMirror.defineExtension('getEmmetAbbreviation', function(pos) {\n\t\tvar editor = this;\n\t\tpos = pos || editor.getCursor();\n\t\tvar marker = findMarker(editor, pos);\n\n\t\tif (marker) {\n\t\t\treturn {\n\t\t\t\tabbreviation: marker.model.abbreviation,\n\t\t\t\tast: marker.model.ast,\n\t\t\t\tlocation: marker.find().from,\n\t\t\t\tfromMarker: true\n\t\t\t};\n\t\t}\n\n\t\tvar extracted = extractAbbreviation(editor, pos);\n\t\tif (extracted) {\n\t\t\ttry {\n\t\t\t\treturn {\n\t\t\t\t\tabbreviation: extracted.abbreviation,\n\t\t\t\t\tast: parseAbbreviation(extracted.abbreviation, editor),\n\t\t\t\t\tlocation: { line: pos.line,  ch: extracted.location },\n\t\t\t\t\tfromMarker: false\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\t// Will throw if abbreviation is invalid\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t});\n\n\tCodeMirror.defineExtension('findEmmetMarker', function(pos) {\n\t\treturn findMarker(this, pos || this.getCursor());\n\t});\n\n\tCodeMirror.defineExtension('getEmmetDocumentModel', function() {\n\t\tvar editor = this;\n\t\treturn editor.getOption('markTagPairs')\n\t\t\t? getCachedModel(editor)\n\t\t\t: getModel(editor);\n\t});\n}\n\nreturn registerEmmetExtension;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_codemirror-emmet@1.0.0@codemirror-emmet/dist/codemirror-emmet.js\n// module id = 6iYb\n// module chunks = 2"],"sourceRoot":""}