/**
 * The edit window of markdown and the preview window are scrolled synchronously
 * markdown的编辑窗口与预览窗口同步滚动功能
 */
import Loader from './loader'
const loader = new Loader()

export default class SyncScroll {
  /**
   * Initialize the synchronous scrolling class SyncScroll (singleton)
   * 初始化同步滚动类SyncScroll(单例)
   * @param {Object} cm 当前CodeMirror实例
   * @param {Document} preview 当前预览窗口
   */
  constructor(cm, preview) {
    if (!SyncScroll.instance) {
      this.cm = cm
      this.preWindow = preview.contentWindow
      this.matchTagsStr = 'p, h1, h2, h3, h4, h5, h6, li, pre, blockquote, hr, table, code>span'
      this.topEle = null
      this.init()
      SyncScroll.instance = this
    }
    return SyncScroll.instance
  }
  init () {
    this.setScroll()
    this.isInit = true
  }
  /**
   * Monitor the scroll event of the edit window
   * 监听编辑窗口滚动事件
   */
  setScroll () {
    const cm = this.cm
    cm.on('scroll', () => {
      const length = this.getCMMatchEleLen()
      this.setPreviewScrollPos(length)
    })
  }
  /**
   * Get the top line number of the currently visible window of the markdown editor
   * Get the matching element column generated by all markdown codes before the line, and return the length
   * 获取markdown编辑器当前可见窗口最顶行行号
   * 获取该行之前所有markdown代码所生成的匹配元素列，并返回长度
   * @returns {Number} 匹配元素列长度
   */
  getCMMatchEleLen () {
    const cm = this.cm
    const scrollInfo = cm.getScrollInfo()
    const lineNumber = cm.lineAtHeight(scrollInfo.top, 'local')
    const range = cm.getRange({ line: 0, ch: null }, { line: lineNumber, ch: null })
    const marked = this.getMarked()
    const doc = new DOMParser().parseFromString(marked(range), 'text/html')
    const matchEleList = doc.body.querySelectorAll(this.matchTagsStr)
    return matchEleList.length
  }
  /**
   * Get matching tags in preview
   * Position the length of the element in the list of matched elements at the top of the preview visible area
   * 获取preview中的匹配标签
   * 将preview可见区域的顶部定位匹配元素列表中第length个元素
   * @param {Number} length 匹配元素列长度
   */
  setPreviewScrollPos (length) {
    const preWindow = this.preWindow
    if (length) {
      const matchEleList = preWindow.document.body.querySelectorAll(this.matchTagsStr)
      if (length === 1) length--
      if (matchEleList.length) {
        const target = matchEleList[length]
        target.scrollIntoView()
      }
    } else {
      preWindow.scrollTo(0, 0)
    }
  }
  /**
   * @returns {Object} marked
   */
  getMarked () {
    let marked
    if (!loader.get('markdown')) {
      marked = require('marked')
      loader.set('markdown', marked)
    } else {
      marked = loader.get('markdown')
    }
    return marked
  }
  clearSyncScroll () {
    if (this.isInit) {
      const cm = this.cm
      cm.on('scroll', () => { })
      this.isInit = false
    }
  }
}
